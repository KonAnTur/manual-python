<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <title>Python</title>
        <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
        <link href="css/grid.css" rel="stylesheet">
        <link href="css/font.css" rel="stylesheet">
        <link href="css/style.css" rel="stylesheet">
    </head>

    <body>
        <div class="menu">
            <a href="#" class="menu-btn"></a>
            <nav class="menu-list">
                <ol id="list">
                </ol>                      
            </nav>
        </div>
        <div class="main">          
        <div class="container">
            <div class="row">
                <div class="col-6">
                    <div class="header-h1 header-h1-left">
                        <h1>Методичка по Python</h1>
                    </div>
                    <h2 id="1">1. Операторы:</h2>
                    <div class="card">
                        <h3><b>1.1 Арифметические операторы:</b> <span class="code">+, -, *, /, //, %, **</span></h3>
                        <div class="text-in-card">
                            <p>В пояснении нужнаются пожалуй только операторы <b class="red">//</b> и <b class="red">%</b></p>
                            <p>
                                Целочисленное деление <b class="red">//</b> - Деление в котором 
                                возвращается только целая часть результата.
                            </p>
                            <p>
                                Примеры: 
                                <br><span class="code">12 // 5 в результате будет 2</span>
                                <br><span class="code">4 // 3 в результате будет 1</span>
                            </p>
                            <p>
                                Деление по модулю <b class="red">%</b> - Делит левый операнд на правый и возвращает остаток.
                            </p>
                            <p>
                                Примеры: 
                                <br><span class="code">7 % 2 в результате будет 1</span>
                                <br><span class="code">13.2 % 5 в результате 3.2</span>
                            </p>
                        </div>
                        <h3><b>1.2 Битовые операторы:</b> <span class="code">&, |, ^, >>, <<, ~</span></h3> 
                        <div class="text-in-card">
                            <p>
                                Переменные типа int хранятся в двоичной системе счисления в виде 
                                последовательности бит. Биты нумеруются от 0, биты будем записывать 
                                справа налево (то есть бит с номером 0 будет записан самым правым, 
                                а самый старший бит — самым левым).
                            </p>
                            <p>
                                Для двух переменных одинакового скалярного типа определены битовые операции:
                                <br><b class="red">& битовое И (AND)</b>
                                <br><b class="red">| битовое ИЛИ (OR)</b>
                                <br><b class="red">^ битовое ИСКЛЮЧАЮЩЕЕ ИЛИ (XOR)</b>
                                <br><b class="red">~ битовое ОТРИЦАНИЕ (NOT) — унарная операция.</b>
                            </p>
                            <p>
                                Битовые операторы работают следующим образом. 
                                Берутся два операнда, и к каждой паре соответствующих бит для левого 
                                и правого операнда применяется данная операция, результатом 
                                будет переменная того же типа, каждый бит которой есть результат 
                                применения соответствующей логической операции к соответствующим 
                                битам двух операндов. 
                            </p>
                            <p>
                                Рассмотрим примеры:
                                <br><span class="code">a = 5     #0b101</span>
                                <br><span class="code">b = 6     #0b110</span>
                                <br><span class="code">c = a & b #0b100 == 4</span>
                                <br><span class="code">d = a | b #0b111 == 7</span>
                                <br><span class="code">e = a ^ b #0b11 == 3</span>
                                <br><span class="code">f =  ~ a  #0b1...11111010 == -6</span>
                            </p>
                            <p>
                                Есть еще две операции, работающие с битами: это битовые сдвиги. 
                                Их два: сдвиг влево и вправо. Оператор a >> n возвращает число, 
                                которое получается из a сдвигом всех бит на n позиций вправо, 
                                при этом самые правые n бит отбрасываются. 
                            </p>
                            <p>
                                Например:
                                <br><span class="code">a = 43      #0b101011</span>
                                <br><span class="code">b = a >> 1  #0b10101 == 21</span>
                                <br><span class="code">c = a >> 2  #0b1010 == 10</span>
                            </p>
                        </div>
                        <h3>
                            <b>1.3 Операторы присваивания:</b> 
                            <br><span class="code">=, +=, -=, *=, /=, %=, //=, **=, &=, |=, ^=, >>=, <<=</span>
                        </h3>
                        <h3>
                            <b>1.4 Операторы сравнения:</b> 
                            <span class="code">==, !=, >, <, >=, <=</span>
                        </h3>
                        <div class="text-in-card">
                            <p>
                                Результатом выполнения операторов сравнения являются значения: True и False.
                            </p>
                        </div>
                        <h3>
                            <b>1.5 Логические операторы:</b> 
                            <span class="code">and, or, not</span>
                        </h3>
                        <div class="text-in-card">
                            <p>
                                Логические операторы используются для объединения операторов сравнения,
                                в операциях с логическим типом данных и в операторах ветвления.
                            </p>
                            <p>
                                <b class="red">and</b> - Логический оператор "И". Условие будет истинным если оба операнда истина.
                                <br><span class="code">first_number > 0 and second_number < 20 #True если оба True</span>
                            </p>
                            <p>Примеры:
                                <br><b class="red">True and True равно True.</b>
                                <br><b class="red">True and False равно False.</b>
                                <br><b class="red">False and True равно False.</b>
                                <br><b class="red">False and False равно False.</b>
                            </p>
                            <p>
                                <b class="red">or</b> - Логический оператор "ИЛИ". Если хотя бы один из операндов истинный, то и все выражение будет истинным.
                                <br><span class="code">first_number > 5 or second_number < 20 #True если хотябы один True</span>
                            </p>
                            <p>Примеры:
                                <br><b class="red">True or True равно True.</b>
                                <br><b class="red">True or False равно True.</b>
                                <br><b class="red">False or True равно True.</b>
                                <br><b class="red">False or False равно False.</b>
                            </p>
                            <p>
                                <b class="red">not</b> - Логический оператор "НЕ". Изменяет логическое значение операнда на противоположное.
                                <br><span class="code">not first_number == second_number #True если было False</span>
                            </p>
                            <p>Примеры:
                                <br><b class="red">not True равно False.</b>
                                <br><b class="red">not False равно True.</b>
                            </p>
                        </div>
                        <h3>
                            <b>1.6 Операторы идентификации:</b> 
                            <span class="code">is, is not</span>
                        </h3>
                        <div class="text-in-card">
                            <p>Операторы идентификации сравнивают ячейки памяти двух объектов.</p>
                            <p>
                                <b class="red">is</b> - Возвращает истину, если переменные по обе стороны от точки 
                                оператора указывают на тот же объект и ложь в противном случае.
                            </p>
                            <p>
                                <b class="red">is not</b> - Возвращает ложным, если 
                                переменные по обе стороны от точки оператора указывают на тот же объект и 
                                верно в противном случае.
                            </p>
                            <p>
                                Примеры:
                                <pre class="code">a = ["apple", "banana"]<br>b = ["apple", "banana"]<br>c = a<br>a is c # Вернёт True т.к. это один и тот же объект<br>a is b # Вернёт True т.к. это разные объекты<br>a == b # Вернёт True т.к. контект объектов одинаков</pre>
                            </p>
                            <p>Последний пример показывает разницу между <span class="code">is</span> и <span class="code">==</span></p>
                        </div>
                        <h3>
                            <b>1.7 Операторы членства:</b> 
                            <span class="code">in, not in</span>
                        </h3>
                        <div class="text-in-card">
                            <p>Операторы идентификации сравнивают ячейки памяти двух объектов.</p>
                            <p>
                                <b class="red">in</b> - Истина, если он находит переменную в указанной 
                                последовательности и ложь в противном случае.
                            </p>
                            <p>
                                <b class="red">not in</b> - Истина, если он не находит переменную в указанной 
                                последовательности и ложь в противном случае.
                            </p>
                            <p>
                                Примеры:
                                <pre class="code">a = ["apple", "banana"]<br>"banana" in a #Выдаст True<br>"pineapple" not a #Выдаст True</pre>
                            </p>
                        </div>
                    </div>
                    <h2 id="3">3. Логические операторы:</h2>
                    <div class="card">
                        <h3><b>3.1 Оператор ветвления:</b> <span class="code">if</span></h3>
                        <div class="text-in-card">
                            <p>
                                Оператор условного выбора ветви Python-программы. 
                                Его можно использовать для направления выполнения программы по двум различным ветвям.
                                Чтобы написать несколько условий ветвления нужно использовать конструкцию 
                                <b class="red">elif</b>, слово <b class="red">else</b> используется если условие не подходит. Синтаксис:
                                <pre class="code">number = 15<br>conclusion = ''<br><br>if number < 0:<br>    conclusion = 'Number is less than zero'<br>elif number == 0:<br>    conclusion = 'Number equals to zero'<br> elif number < 1:<br>    conclusion = 'Number is greater than zero but less than one'<br>else:<br>    conclusion = 'Number bigger than or equal to one'</pre>
                            </p>
                        </div>
                        <h3><b>3.2 Цикл for (и функция range()):</b> <span class="code">for, range()</span></h3>
                        <div class="text-in-card">
                            <p>
                                Оператор Python for перебирает элементы любой последовательности 
                                (списка или строки) в том порядке, что они появляются в последовательности. 
                                А функция, <b class="red">range(x,y,z)</b> создаёт массив из чисел от x до y c шагом z 
                                (если аргумент только 1 то от 0 до этого аргумента).
                                <br>Например:
                                <pre class="code">for number in range(5):<br>    iterated_numbers.append(number)<br><br>assert iterated_numbers == [0, 1, 2, 3, 4]</pre>
                            </p>
                        </div>
                        <h3><b>3.3 Цикл while:</b> <span class="code">while</span></h3>
                        <div class="text-in-card">
                            <p>
                                Цикл <b class="red">while</b> выполняется до тех пор, пока условие остается верным. 
                                <br>Например:
                                <pre class="code">number = 2<br>power = 5<br><br>result = 1<br><br>while power > 0:<br>    result *= number<br>    power -= 1</pre>
                            </p>
                        </div>
                        <h3><b>3.4 Инструкция break:</b> <span class="code">break</span></h3>
                        <div class="text-in-card">
                            <p>
                                Оператор <b class="red">break</b>, выходит из внутреннего цикла «for» или «while».
                                <br>Пример:
                                <pre class="code">number_to_be_found = 42<br>number_of_iterations = 0<br><br>for number in range(100):<br>    if number == number_to_be_found:<br>        # Выходим из цикла.<br>        break<br>    else:<br>        number_of_iterations += 1
                                </pre>
                            </p>
                        </div>
                        <h3><b>3.5 Оператор continue:</b> <span class="code">continue</span></h3>
                        <div class="text-in-card">
                            <p>
                                Оператор <b class="red">continue</b>, прерывает настоящую итерацию 
                                цикла и продолжает цикл со следующей итерации.
                                <br>Пример:
                                <pre class="code">for number in range(0, 10):<br>if number % 2 == 0:<br>    even_numbers.append(number)<br>    # Итерация препрывается и начинается новая<br>    continue<br>rest_of_the_numbers.append(number)</pre>
                            </p>
                        </div>
                    </div>
                    <h2 id="4">4. Функции:</h2>
                    <div class="card">
                        <h3><b>4.1 Инициализация функции: <span class="code">def</span></b></h3>
                        <div class="text-in-card">
                            <p>
                                Ключевое слово <b class="red">def</b> вводит определение функции. 
                                За ним должно следовать имя функции и заключенный в скобки список формальных параметров. 
                                Операторы, которые формируют тело функции, начинаются с следующей строки 
                                и должны быть с отступом. Слово <b class="red">return</b> указывает на вывод.
                                <pre class="code">def greet(name):<br>    return 'Hello, ' + name</pre>
                            </p>
                            <p>
                                Можно вкладывать функции друг в друга:
                                <pre class="code">def greet_again(name):<br>    def get_message():<br>        return 'Hello, '<br><br>    result = get_message() + name<br>    return result</pre>
                            </p>
                            <p>
                                Вызвать функцию можно по её имени:
                                <br><span class="code">greet_again('John') == 'Hello, John'</span>
                            </p>
                        </div>
                        <h3><b>4.2 Область видимости переменных: <span class="code">global, nonlocal</span></b></h3>
                        <div class="text-in-card">
                            <p>
                                У переменных в Python есть область видимости. 
                                В зависимости от места в коде, где переменная была определена, 
                                определяется и область видимости, то есть, где переменная будет доступна.
                                <br>При использовании имен переменных в программе, Python каждый раз ищет, 
                                создает или изменяет эти имена в соответствующем пространстве имен. 
                                Пространство имен, которое доступно в каждый момент, зависит от области, в которой находится код.
                            </p>
                            <p>
                                У Python есть правило <b class="red">LEGB</b>, которым он пользуется при поиске переменных.
                                <ul>
                                    <li>
                                        <b class="red">L (local)</b> - в локальной (внутри функции).
                                    </li>
                                    <li>
                                        <b class="red">E (enclosing)</b> - в локальной области объемлющих функций 
                                        (это те функции, внутри которых находится наша функция).
                                    </li>
                                    <li>
                                        <b class="red">G (global)</b> - в глобальной (в скрипте).
                                    </li>
                                    <li>
                                        <b class="red">B (built-in)</b> - в встроенной (зарезервированные значения Python).
                                    </li>
                                </ul>
                            </p>
                            <p>
                                Оператор <b class="red">global</b> объявляет переменную доступной для блока кода, следующим за оператором.
                                Её можно применять к переменным внутри функции.
                                <br><pre class="code">def my_func(a, b):<br>    global x<br>    print(x)<br>    x = 5<br>    print(x) <br> <br>x = 10<br>my_func(1, 2)<br>print(x) #10 5 5</pre>
                            </p>
                            <p>
                                С помощью <b class="red">nonlocal</b> мы можем добавлять переопределение области во внутреннюю область. 
                                <pre class="code">def counter():<br>    num = 0<br>    def incrementer():<br>        nonlocal num<br>        num += 1<br>        return num<br>    return incrementer</pre>
                            </p>
                        </div>
                        <h3><b>4.3 Аргументы функции.</b></h3>
                        <div class="text-in-card">
                            <p>
                                Можно указать значение аргументов функции по умолчанию. 
                                Тогда функцию можно вызывать с меньшим количеством аргументов.
                                <br>Пример:
                                <pre class="code">def power_of(number, power=2):<br>    return number ** power<br><br>power_of(3) == 9</pre>
                            </p>
                            <p>
                                <b class="red">Аргументы</b> - ключевые слова используются при вызове функции. 
                                Благодаря ключевым аргументам, вы можете задавать произвольный 
                                (то есть не такой каким он описан, при создании функции) порядок аргументов.
                                <pre class="code">def person(name, age):<br>    print name, "is", age, "years old"<br><br> # Мы можем вызвать функцию вот так<br><br>person(age = 23, name = "John")</pre>
                            </p>
                            <p>
                                Функция также может принимать переменное количество позиционных аргументов, 
                                тогда перед именем ставится *:
                                <pre class="code">def func(*args):<br>    return args<br><br>func(1, 2, 3, 'abc') == (1, 2, 3, 'abc')</pre>
                            </p>
                            <p>
                                Как видно из примера, <b class="red">*args</b> - это кортеж из всех переданных 
                                аргументов функции, и с переменной можно работать также, как и с кортежем.
                            </p>
                            <p>
                                Функция может принимать и произвольное число именованных аргументов, 
                                тогда перед именем ставится <b class="red">**</b>:
                                <pre class="code">def func(**kwargs):<br>    return kwargs<br><br>func(a=1, b=2, c=3) == {'a': 1, 'c': 3, 'b': 2}<br>func() == {}<br>func(a='python') == {'a': 'python'}</pre>
                            </p>
                            <p>
                                В переменной <b class="red">**kwargs</b> у нас хранится словарь, с которым мы, опять-таки, 
                                можем делать все, что нам заблагорассудится.
                            </p>
                        </div>
                        <h3><b>4.4 Анонимные (Лямбда) функции: <span class="code">lambda</span></b></h3>
                        <div class="text-in-card">
                            <p>
                                Анонимные функции могут содержать лишь одно выражение, 
                                но и выполняются они быстрее. Анонимные функции создаются с помощью инструкции 
                                <b class="red">lambda</b>. 
                                Кроме этого, их не обязательно присваивать переменной, 
                                как делали мы инструкцией def func():
                                <pre class="code">func = lambda x, y: x + y<br>func(1, 2) == 3<br>func('a', 'b') == 'ab'<br>(lambda x, y: x + y)(1, 2) == 3<br>(lambda x, y: x + y)('a', 'b') == 'ab'</pre>
                            </p>
                            <p>
                                lambda функции, в отличие от обычной, не требуется инструкция return, 
                                а в остальном, ведет себя точно так же:
                                <pre class="code">func = lambda *args: args<br>func(1, 2, 3, 4) == (1, 2, 3, 4)</pre>
                            </p>
                        </div>
                        <h3><b>4.5 Документация функций: <span class="code">"""..."""</span></b></h3>
                        <div class="text-in-card">
                            <p>
                                Документирование кода в python - достаточно важный аспект, 
                                ведь от нее порой зависит читаемость и быстрота понимания вашего кода, 
                                как другими людьми, так и вами через полгода. Чтобы задокументировать объект 
                                нужно перед кодом этого объекта записать <b class="red">""" doc """</b>. Тогда его можно получить с
                                помощью метода <b class="red">__doc__</b>. 
                                <br>Например:
                                <pre class="code">def do_nothing():<br>    """Do nothing, but document it.<br>    No, really, it doesn't do anything.<br>    """<br>    pass<br>do_nothing.__doc__ <br>#"""Do nothing, but document it. No, really, it doesn't do anything."""</pre>
                            </p>
                        </div>
                        <h3><b>4.6 Декораторы.</b></h3>
                        <div class="text-in-card">
                            <p>
                                <b class="red">Декоратор</b> — это функция, которая позволяет обернуть другую функцию для расширения 
                                её функциональности без непосредственного изменения её кода. 
                                Вот почему декораторы можно рассматривать как практику метапрограммирования, 
                                когда программы могут работать с другими программами как со своими данными. 
                            </p>
                            <p>
                                Тот факт, что всё является объектами, открывает перед нами множество возможностей. 
                                Мы можем сохранять функции в переменные, передавать их в качестве аргументов и 
                                возвращать из других функций. Можно даже определить одну функцию внутри другой. 
                                Иными словами, функции — это объекты первого класса. Мы знаем и о функциях высших порядков
                                в математике это, например, производная d/dx, которая принимает в себя функцию и 
                                возвращает функцию.
                            </p>
                            <p>
                                Посмотрим на пример декоратора:
                                <pre class="code">def decorator_function(func):<br>    def wrapper():<br>        print('Функция-обёртка!')<br>        print('Оборачиваемая функция: {}'.format(func))<br>        print('Выполняем обёрнутую функцию...')<br>        func()<br>        print('Выходим из обёртки')<br>    return wrapper</pre>
                            </p>
                            <p>
                                Теперь посмотрим на декоратор в действии:
                                <pre class="code">@decorator_function<br>def hello_world():<br>    print('Hello world!')<br><br>hello_world()<br>#Оборачиваемая функция: <function hello_world at 0x032B26A8><br>#Выполняем обёрнутую функцию...<br>#Hello world!<br>#Выходим из обёртки</pre>
                            </p>
                            <p>
                                Просто добавив <span class="code">@decorator_function</span> перед определением 
                                функции <span class="code">hello_world()</span>, мы модифицировали её поведение. 
                                Выражение с <b class="red">@</b> является всего лишь синтаксическим сахаром для 
                                <span class="code">hello_world = decorator_function(hello_world)</span>.
                                <br>Иными словами, выражение <span class="code">@decorator_function</span> вызывает 
                                <span class="code">decorator_function()</span> с <span class="code">hello_world</span> 
                                в качестве аргумента и присваивает имени <span class="code">hello_world</span> 
                                возвращаемую функцию.
                            </p>
                            <p>
                                Ещё примеры:
                                <pre class="code">def benchmark(func):<br>    import time<br>    <br>    def wrapper():<br>        start = time.time()<br>        func()<br>        end = time.time()<br>        print('[*] Время выполнения: {} секунд.'.format(end-start))<br>    return wrapper<br><br>@benchmark<br>def fetch_webpage():<br>    import requests<br>    webpage = requests.get('https://google.com')<br><br>fetch_webpage()</pre>
                            </p>
                            <p>
                                Здесь мы создаём декоратор, замеряющий время выполнения функции. 
                                Далее мы используем его на функции, которая делает GET-запрос 
                                к главной странице Google. Чтобы измерить скорость, мы сначала 
                                сохраняем время перед выполнением обёрнутой функции, выполняем её, 
                                снова сохраняем текущее время и вычитаем из него начальное.
                            </p>
                        </div>
                    </div>
                    <h2 id="7">7. Ошибки и исключения:</h2>
                    <div class="card">
                        <h3><b>7.1 Оператор try: <span class="code">try, except, else, finally</span></b></h3>
                        <div class="text-in-card">
                        <p>
                            Оператор <b class="red">try</b> используется для обработки исключений. 
                            Когда возникает ошибка или исключение, как мы ее называем, 
                            Python обычно останавливается и генерирует сообщение-ошибку. 
                            Эти исключения могут быть обработаны с помощью оператора try.
                            <br>Блок <b class="red">try</b> позволяет проверить блок кода на наличие ошибок. 
                            <br>Блок <b class="red">except</b> позволяет вам обработать ошибку. 
                            <br>Блок <b class="red">else</b> позволяет выполнить код, если ошибок не было. 
                            <br>Блок <b class="red">finally</b> позволяет выполнять код независимо от результата блоков try и except.
                            <br>Например:
                            <pre class="code">message = ''<br>try:<br>    print(not_existing_variable)  # noqa: F821<br>except NameError:<br>    message += 'Something went wrong.'<br>finally:<br>    message += 'The "try except" is finished.'</pre>
                        </p>
                        </div>
                        <h3><b>7.2 Создание исключений: <span class="code">raise</span></b></h3>
                        <div class="text-in-card">
                            <p>
                                Оператор <b class="red">raise</b> позволяет программисту принудительно вызвать указанное исключение.
                                Например, мы можем вызвать исключение NameError и отловить его в try:
                                <pre class="code">try:<br>    raise NameError('HiThere') <br>except NameError:<br>    exception_is_caught = True<br><br>assert exception_is_caught</pre>
                            </p>
                            <p>
                                Мы можем создавать собственные исключения с помощью классов:
                                <pre class="code">class MyCustomError(Exception):<br>"""Example of MyCustomError exception."""<br>def __init__(self, message):<br>    super().__init__(message)<br>    self.message = message<br><br>custom_exception_is_caught = False<br><br>try:<br>    raise MyCustomError('My custom message')<br>except MyCustomError:<br>    custom_exception_is_caught = True</pre>
                            </p>
                        </div>
                    </div>
                    <h2 id="9">9. Дополнения:</h2>
                    <div class="card">
                        <h3><b>9.1 Оператор "пропуск": <span class="code">pass</span></b></h3>
                        <div class="text-in-card">
                            <p>
                                Оператор <b class="red">pass</b> ничего не делает. 
                                Он может использоваться, когда оператор 
                                требуется синтаксически, но программа не требует никаких действий 
                                (Аналог return, только ничего не делает).
                            </p>
                        </div>
                        <h3><b>9.2 Генераторы: <span class="code">yield</span></b></h3>
                        <div class="text-in-card">
                            <p>
                                <b class="red">Генератор</b> - это функция, возвращающая подвид итератора, 
                                генерирующий значения.
                                <b class="red">Итератор генератора</b> — это объект, порождаемый функцией-генератором.
                                <br>Выглядят функции-генераторы также как и обычные, но содержат 
                                выражения с ключевым словом <b class="red">yield</b> для последовательного 
                                генерирования значений, 
                                которые могут быть использованы в циклах for in, либо их получения при помощи 
                                функции <b class="red">next()</b>.
                            </p>
                            <p>
                                На каждой <b class="red">yield</b> работа функции временно приостанавливается, при этом 
                                сохраняется состояние исполнения, включая локальные переменные, 
                                указатель на текущую инструкцию, внутренний стек и состояние обработки исключения. 
                                При последующем обращении к итератору генератора (при вызовах его методов) функция 
                                продолжает своё исполнение с места, на котором была приостановлена. 
                                Этим функции-генераторы отличаются от обычных функций, при вызове которых 
                                исполнение всякий раз начинается с начала.
                                <br>Если функция достигает инструкции return, либо конца 
                                (без указания упомянутой инструкции), возбуждается исключение 
                                <b class="red">StopIteration</b> и 
                                итератор исчерпывает себя.
                                <pre class="code">def my_animal_generator():<br><br>    yield 'корова'<br><br>    for animal in ['кот', 'собака', 'медведь']:<br>       yield animal<br><br>    yield 'кит'<br><br>for animal in my_animal_generator():<br>    print(animal)<br># корова кот собака медведь кит</pre>
                            </p>
                        </div>
                    </div>
                    <h2 id="10">10. Стандартные библиотеки для работы с математикой:</h2>
                    <div class="card">
                        <h3><b>10.1 Библиотека Math.</b></h3>
                        <div class="text-in-card">
                            <p>
                                Модуль <b class="red">math</b> – один из наиважнейших в Python. 
                                Этот модуль предоставляет обширный функционал для работы с числами.
                                <br><span class="code">import math</span>
                                <ul>
                                    <li>
                                        <span class="code">math.ceil(X)</span> – округление до ближайшего большего числа.
                                    </li>
                                    <li>
                                        <span class="code">math.copysign(X, Y)</span> - возвращает число, имеющее модуль такой же, как и у числа X, а знак - как у числа Y.
                                    </li>
                                    <li>
                                        <span class="code">math.fabs(X)</span> - модуль X.
                                    </li>
                                    <li>
                                        <span class="code">math.factorial(X)</span> - факториал числа X.
                                    </li>
                                    <li>
                                        <span class="code">math.floor(X)</span> - округление вниз.
                                    </li>
                                    <li>
                                        <span class="code">math.fmod(X, Y)</span> - остаток от деления X на Y.
                                    </li>
                                    <li>
                                        <span class="code">math.frexp(X)</span> - возвращает мантиссу и экспоненту числа.
                                    </li>
                                    <li>
                                        <span class="code">math.ldexp(X, i)</span> - X * 2<sup>i</sup>. 
                                        Функция, обратная функции math.frexp().
                                    </li>
                                    <li>
                                        <span class="code">math.fsum(последовательность)</span> - сумма всех членов последовательности. 
                                        Эквивалент встроенной функции sum(), но math.fsum() более точна для чисел с плавающей точкой.
                                    </li>
                                    <li>
                                        <span class="code">math.isfinite(X)</span> - является ли X числом.
                                    </li>
                                    <li>
                                        <span class="code">math.isinf(X)</span> - является ли X бесконечностью.
                                    </li>
                                    <li>
                                        <span class="code">math.isnan(X)</span> - является ли X NaN (Not a Number - не число).
                                    </li>
                                    <li>
                                        <span class="code">math.modf(X)</span> - возвращает дробную и целую часть числа X. Оба числа имеют тот же знак, что и X.
                                    </li>
                                    <li>
                                        <span class="code">math.trunc(X)</span> - усекает значение X до целого.
                                    </li>
                                    <li>
                                        <span class="code">math.exp(X)</span> - e<sup>X</sup>.
                                    </li>
                                    <li>
                                        <span class="code">math.expm1(X)</span> - e<sup>X</sup> - 1. При X → 0 точнее, чем math.exp(X)-1.
                                    </li>
                                    <li>
                                        <span class="code">math.log(X, [base])</span> - логарифм X по основанию base. Если base не указан, вычисляется натуральный логарифм.
                                    </li>
                                    <li>
                                        <span class="code">math.log1p(X)</span> - натуральный логарифм (1 + X). При X → 0 точнее, чем math.log(1+X)
                                    </li>
                                    <li>
                                        <span class="code">math.log10(X)</span> - логарифм X по основанию 10.
                                    </li>
                                    <li>
                                        <span class="code">math.log2(X)</span> - логарифм X по основанию 2.
                                    </li>
                                    <li>
                                        <span class="code">math.pow(X, Y)</span> - X<sup>Y</sup>.
                                    </li>
                                    <li>
                                        <span class="code">math.sqrt(X)</span> - квадратный корень из X.
                                    </li>
                                    <li>
                                        <span class="code">math.acos(X)</span> - арккосинус X. В радианах.
                                    </li>
                                    <li>
                                        <span class="code">math.asin(X)</span> - арксинус X. В радианах.
                                    </li>
                                    <li>
                                        <span class="code">math.atan(X)</span> - арктангенс X. В радианах.
                                    </li>
                                    <li>
                                        <span class="code">math.atan2(Y, X)</span> - арктангенс Y/X. В радианах. 
                                        С учетом четверти, в которой находится точка (X, Y).
                                    </li>
                                    <li>
                                        <span class="code">math.cos(X)</span> - косинус X (X указывается в радианах).
                                    </li>
                                    <li>
                                        <span class="code">math.sin(X)</span> - синус X (X указывается в радианах).
                                    </li>
                                    <li>
                                        <span class="code">math.tan(X)</span> - тангенс X (X указывается в радианах).
                                    </li>
                                    <li>
                                        <span class="code">math.hypot(X, Y)</span> - вычисляет гипотенузу треугольника 
                                        с катетами X и Y (math.sqrt(x * x + y * y))
                                    </li>
                                    <li>
                                        <span class="code">math.degrees(X)</span> - конвертирует радианы в градусы.
                                    </li>
                                    <li>
                                        <span class="code">math.radians(X)</span> - конвертирует градусы в радианы.
                                    </li>
                                    <li>
                                        <span class="code">math.cosh(X)</span> - вычисляет гиперболический косинус.
                                    </li>
                                    <li>
                                        <span class="code">math.sinh(X)</span> - вычисляет гиперболический синус.
                                    </li>
                                    <li>
                                        <span class="code">math.tanh(X)</span> - вычисляет гиперболический тангенс.
                                    </li>
                                    <li>
                                        <span class="code">math.acosh(X)</span> - вычисляет обратный гиперболический косинус.
                                    </li>
                                    <li>
                                        <span class="code">math.asinh(X)</span> - вычисляет обратный гиперболический синус.
                                    </li>
                                    <li>
                                        <span class="code">math.atanh(X)</span> - вычисляет обратный гиперболический тангенс.
                                    </li>
                                    <li>
                                        <span class="code">math.erf(X)</span> - функция ошибок.
                                    </li>
                                    <li>
                                        <span class="code">math.erfc(X)</span> - дополнительная функция ошибок (1 - math.erf(X)).
                                    </li>
                                    <li>
                                        <span class="code">math.gamma(X)</span> - гамма-функция X.
                                    </li>
                                    <li>
                                        <span class="code">math.lgamma(X)</span> - натуральный логарифм гамма-функции X.
                                    </li>
                                    <li>
                                        <span class="code">math.pi</span> - pi = 3,1415926...
                                    </li>
                                    <li>
                                        <span class="code">math.e</span> - e = 2,718281...
                                    </li>
                                </ul>
                            </p>
                        </div>
                        <h3><b>10.2 Библиотека random.</b></h3>
                        <div class="text-in-card">
                            <p>
                                Модуль <b class="red">random</b> позволяет генерировать случайные числа.
                                Python порождает случайные числа на основе формулы, так что они не на самом деле случайные, 
                                а, как говорят, псевдослучайные. Этот способ удобен для большинства приложений 
                                (кроме онлайновых казино).
                                <br><span class="code">import random</span>
                                <ul>
                                    <li>
                                        <span class="code">random.random()</span> — 
                                        возвращает псевдослучайное число от 0.0 до 1.0
                                    </li>
                                    <li>
                                        <span class="code">random.seed(<Параметр>)</span> — настраивает генератор 
                                        случайных чисел на новую последовательность. 
                                        По умолчанию используется системное время. 
                                        Если значение параметра будет одиноким, то генерируется одинокое число:
                                        <pre class="code">random.seed(20)<br>random.random()<br>0.9056396761745207<br><br>random.random()<br>0.6862541570267026<br><br>random.seed(20)<br>random.random()<br>0.9056396761745207<br><br>random.random()<br>0.7665092563626442</pre>
                                    </li>
                                    <li>
                                        <span class="code">random.uniform(<Начало>, <Конец>)</span> — возвращает 
                                        псевдослучайное вещественное число в диапазоне от <Начало> до <Конец>.
                                    </li>
                                    <li>
                                        <span class="code">random.randint(<Начало>, <Конец>)</span> — возвращает псевдослучайное целое 
                                        число в диапазоне от <Начало> до <Конец>.
                                    </li>
                                    <li>
                                        <span class="code">random.choince(<Последовательность>)</span> — возвращает 
                                        случайный элемент из любой последовательности (строки, списка, кортежа):
                                        <pre class="code">random.choice('Chewbacca') #'h'<br>random.choice([1,2,'a','b']) #2</pre>
                                    </li>
                                    <li>
                                        <span class="code">random.randrange(<Начало>, <Конец>, <Шаг>)</span> — 
                                        возвращает случайно выбранное число из последовательности.
                                    </li>
                                    <li>
                                        <span class="code">random.shuffle(<Список>)</span> — перемешивает 
                                        последовательность (изменяется сама последовательность). 
                                        Поэтому функция не работает для неизменяемых объектов.
                                    </li>
                                </ul>
                            </p>
                            <p>
                                <b>Вероятностные распределения</b>
                                <ul>
                                    <li>
                                        <span class="code">random.triangular(low, high, mode)</span> — случайное число с плавающей точкой, low ≤ N ≤ high. Mode - распределение.
                                    </li>
                                    <li>
                                        <span class="code">random.betavariate(alpha, beta)</span> — бета-распределение. alpha>0, beta>0. Возвращает от 0 до 1.
                                    </li>
                                    <li>
                                        <span class="code">random.expovariate(lambd)</span> — экспоненциальное распределение. 
                                        lambd равен 1/среднее желаемое. Lambd должен быть отличным от нуля. 
                                        Возвращаемые значения от 0 до плюс бесконечности, если lambd положительно, 
                                        и от минус бесконечности до 0, если lambd отрицательный.
                                    </li>
                                    <li>
                                        <span class="code">random.gammavariate(alpha, beta)</span> — гамма-распределение. 
                                        Условия на параметры alpha>0 и beta>0.
                                    </li>
                                    <li>
                                        <span class="code">random.gauss(значение, стандартное отклонение)</span>
                                         — распределение Гаусса.
                                    </li>
                                    <li>
                                        <span class="code">random.lognormvariate(mu, sigma)</span> — логарифм нормального распределения. 
                                        Если взять натуральный логарифм этого распределения, 
                                        то вы получите нормальное распределение со средним mu и стандартным отклонением sigma. 
                                        mu может иметь любое значение, и sigma должна быть больше нуля.
                                    </li>
                                    <li>
                                        <span class="code">random.normalvariate(mu, sigma)</span> — нормальное распределение. 
                                        mu — среднее значение, sigma — стандартное отклонение.
                                    </li>
                                    <li>
                                        <span class="code">random.vonmisesvariate(mu, kappa)</span> — mu — средний угол, выраженный в 
                                        радианах от 0 до 2π, и kappa — параметр концентрации, который должен быть 
                                        больше или равен нулю. Если каппа равна нулю, 
                                        это распределение сводится к случайному углу в диапазоне от 0 до 2π.
                                    </li>
                                    <li>
                                        <span class="code">random.paretovariate(alpha)</span> — распределение Парето.
                                    </li>
                                    <li>
                                        <span class="code">random.weibullvariate(alpha, beta)</span> — распределение Вейбулла.
                                    </li>
                                </ul>
                            </p>
                        </div>
                        <h3><b><a href="https://docs.python.org/3/library/statistics.html" target="_blank">10.3 Модуль statistics.</a></b></h3>
                        <div class="text-in-card">
                            <p>
                                Этот модуль предоставляет функции для расчета математической статистики числовых данных.
                                <br><span class="code">import statistics</span>
                                <ul>
                                    <b>Средние показатели:</b>
                                    <br>Эти функции рассчитывают среднее или типичное значение из совокупности или выборки.
                                    <li>
                                        <span class="code">statistics.mean()</span> - Среднее арифметическое.
                                    </li>
                                    <li>
                                        <span class="code">statistics.harmonic_mean()</span> - Гармоническое среднее.
                                        <img class="formula" src="img/Harmo.svg" alt="Формула кармонического среднего."> 
                                    </li>
                                    <li>
                                        <span class="code">statistics.median()</span> - Медиана.
                                    </li>
                                    <li>
                                        <span class="code">statistics.median_low()</span> - Нижняя медиана.
                                    </li>
                                    <li>
                                        <span class="code">statistics.median_high()</span> - Верхняя медиана.
                                    </li>
                                    <li>
                                        <span class="code">statistics.mode()</span> - Наиболее распространенное значение дискретных данных.
                                    </li>
                                </ul>
                            </p>
                            <p>
                                <b>Меры распространения</b>
                                <br>Эти функции вычисляют меру того, насколько популяция или выборка имеют тенденцию 
                                отклоняться от типичных или средних значений.
                                <ul>
                                    <li>
                                        <span class="code">statistics.pstdev()</span> - Популяционное стандартное отклонение данных.
                                    </li>
                                    <li>
                                        <span class="code">statistics.pvariance()</span> - Популяционная дисперсия данных.
                                    </li>
                                    <li>
                                        <span class="code">statistics.stdev()</span> - Стандартное отклонение выборки (квадратный корень дисперсии выборки).
                                    </li>
                                    <li>
                                        <span class="code">statistics.variance()</span> - Дисперсии данных.
                                    </li>
                                </ul>
                            </p>
                        </div>
                    </div>
                    <h2 id="12">12. Библиотека glob:</h2>
                    <div class="card">
                        <div class="text-in-card">
                            <p>
                                Модуль <b class="red">glob</b> предоставляет функцию для создания списков файлов из 
                                поиска по шаблону в каталоге. glob находит все пути, совпадающие с заданным 
                                шаблоном в соответствии с правилами, используемыми оболочкой Unix. 
                                Обрабатываются символы "*" (произвольное количество символов), "?" (один символ), 
                                и диапазоны символов с помощью []. Для использования тильды "~" 
                                и переменных окружения необходимо использовать os.path.expanduser() и os.path.expandvars().
                                <br>Для поиска спецсимволов, заключайте их в квадратные скобки. 
                                Например, [?] соответствует символу "?".
                                <br><span class="code">import glob</span>
                                <ul>
                                    <li>
                                        <span class="code">glob.glob(pathname)</span> - возвращает список (возможно, пустой) путей, 
                                        соответствующих шаблону pathname. Путь может быть как абсолютным 
                                        (например, /usr/src/Python-1.5/Makefile) или относительный (как ../../Tools/*/*.gif).
                                    </li>
                                    <li>
                                        <span class="code">glob.iglob(pathname)</span> - возвращает итератор, 
                                        дающий те же значения, что и glob.glob.
                                    </li>
                                    <li>
                                        <span class="code">glob.escape(pathname)</span> - экранирует все специальные символы 
                                        для glob ("?", "*" и "["). Специальные символы в имени диска не экранируются 
                                        (так как они там не учитываются), то есть в Windows escape("//?/c:/Quo vadis?.txt") 
                                        возвращает "//?/c:/Quo vadis[?].txt".
                                    </li>
                                </ul>
                                <p>
                                    Примеры:
                                </p>
                                <pre class="code">glob.glob('./[0-9].*')<br># ['./1.gif', './2.txt']<br>glob.glob('*.gif')<br># ['1.gif', 'card.gif']<br>glob.glob('?.gif')<br># ['1.gif']</pre>
                            </p>
                        </div>
                    </div>
                    <h2 id="13">13. Регулярные выражения:</h2>
                    <div class="card">
                        <h3><b>13.1 Библиотека Re.</b></h3>
                        <div class="text-in-card">
                            <p>
                                <b class="red">Регулярное выражение</b> — это последовательность символов, 
                                используемая для поиска и замены текста в строке или файле.
                                <br>Регулярные выражения используют два типа символов:
                                <ul>
                                    <li>
                                        Специальные символы: как следует из названия, у этих символов есть 
                                        специальные значения. Аналогично символу *, который как правило означает 
                                        «любой символ» (но в регулярных выражениях работает немного иначе, 
                                        о чем поговорим ниже);
                                    </li>
                                    <li>
                                        Литералы (например: a, b, 1, 2 и т. д.);
                                    </li>
                                </ul>
                            </p>
                            <p>
                                В Python для работы с регулярными выражениями есть модуль <b class="red">re</b>.
                                <br><span class="code">import re</span>
                                <ul>
                                    <li>
                                        <span class="code">re.match(pattern, string)</span> - 
                                        Этот метод ищет по заданному шаблону в начале строки. 
                                        Например, если мы вызовем метод match() на строке «AV Analytics AV» с шаблоном 
                                        «AV», то он завершится успешно. Однако если мы будем искать «Analytics», 
                                        то результат будет отрицательный. 
                                        Чтобы вывести ее содержимое, используем метод <b class="red">group()</b>. 
                                        (Мы используем «r» перед строкой шаблона, чтобы показать, что это «сырая» строка в Python).
                                        <br>Пример:
                                        <pre class="code">result = re.match(r'AV', 'AV Analytics Vidhya AV')<br>print result #<_sre.SRE_Match object at 0x0000000009BE4370><br><br>print result.group(0) #AV<br><br>result = re.match(r'Analytics', 'AV Analytics Vidhya AV')<br>print result #None</pre>
                                        <p>
                                            Также есть методы <b class="red">start()</b> и <b class="red">end()</b> для того, 
                                            чтобы узнать начальную и конечную позицию найденной строки.
                                        </p>
                                        <pre class="code">result = re.match(r'AV', 'AV Analytics Vidhya AV')<br>print result.start() #0<br>print result.end() #2</pre>
                                    </li>
                                    <li>
                                        <span class="code">re.search(pattern, string)</span> -
                                        Метод search() ищет по всей строке, но возвращает только первое найденное совпадение.
                                    </li>
                                    <li>
                                        <span class="code">re.findall(pattern, string)</span> - 
                                        Этот метод возвращает список всех найденных совпадений. 
                                        У метода findall() нет ограничений на поиск в начале или конце строки.
                                        <br>Пример:
                                        <pre class="code">result = re.findall(r'AV', 'AV Analytics Vidhya AV')<br>print result #['AV', 'AV']</pre>
                                    </li>
                                    <li>
                                        <span class="code">re.split(pattern, string, [maxsplit=0])</span> -
                                        Этот метод разделяет строку по заданному шаблону.
                                        <br>Пример:
                                        <pre class="code">result = re.split(r'y', 'Analytics')<br>print result #['Anal', 'tics']</pre>
                                        <p>
                                            Метод split() принимает также аргумент maxsplit со значением по умолчанию, 
                                            равным 0. В данном случае он разделит строку столько раз, сколько возможно, 
                                            но если указать этот аргумент, то разделение будет произведено не более 
                                            указанного количества раз.
                                        </p>
                                    </li>
                                    <li>
                                        <span class="code">re.sub(pattern, repl, string)</span> -
                                        Этот метод ищет шаблон в строке и заменяет его на указанную подстроку. 
                                        Если шаблон не найден, строка остается неизменной.
                                        <br>Пример:
                                        <pre class="code">result = re.sub(r'India', 'the World', <br>   'AV is largest Analytics community of India')<br>print result #'AV is largest Analytics community of the World'</pre>
                                    </li>
                                    <li>
                                        <span class="code">re.compile(pattern, repl, string)</span> -
                                        Мы можем собрать регулярное выражение в отдельный объект, который может быть 
                                        использован для поиска. Это также избавляет от переписывания одного и того 
                                        же выражения.
                                        <br>Пример:
                                        <pre class="code">pattern = re.compile('AV')<br>result = pattern.findall('AV Analytics Vidhya AV')<br>print result #['AV', 'AV']<br>result2 = pattern.findall('AV is largest analytics community of India')<br>print result2 #['AV']</pre>
                                    </li>
                                </ul>
                                <p><b>Специальные символы:</b></p>
                                <ul>
                                    <li>
                                        <b class="red">.</b> - Один любой символ, кроме новой строки \n.
                                    </li>
                                    <li>
                                        <b class="red">?</b> - 0 или 1 вхождение шаблона слева.
                                    </li>
                                    <li>
                                        <b class="red">+</b> - 1 и более вхождений шаблона слева.
                                    </li>
                                    <li>
                                        <b class="red">*</b> - 0 и более вхождений шаблона слева.
                                    </li>
                                    <li>
                                        <b class="red">\w</b> - Любая цифра или буква (\W — все, кроме буквы или цифры).
                                    </li>
                                    <li>
                                        <b class="red">\d</b> - Любая цифра [0-9] (\D — все, кроме цифры).
                                    </li>
                                    <li>
                                        <b class="red">\s</b> - Любой пробельный символ (\S — любой непробельный символ).
                                    </li>
                                    <li>
                                        <b class="red">\b</b> - Граница слова.
                                    </li>
                                    <li>
                                        <b class="red">[..]</b> - Один из символов в скобках ([^..] — любой символ, кроме тех, что в скобках).
                                    </li>
                                    <li>
                                        <b class="red">\</b> - Экранирование специальных символов (\. означает точку или \+ — знак «плюс»).
                                    </li>
                                    <li>
                                        <b class="red">^</b> и <b class="red">$</b> - Начало и конец строки соответственно.
                                    </li>
                                    <li>
                                        <b class="red">{n,m}</b> - От n до m вхождений ({,m} — от 0 до m).
                                    </li>
                                    <li>
                                        <b class="red">a|b</b> - Соответствует a или b.
                                    </li>
                                    <li>
                                        <b class="red">()</b> - Группирует выражение и возвращает найденный текст.
                                    </li>
                                    <li>
                                        <b class="red">\t,\n,\r</b> - Символ табуляции, новой строки и возврата каретки соответственно.
                                    </li>
                                </ul>
                            </p>
                        </div>
                    </div>
                </div>

                <div class="col-6">
                    <h2 id="2">2. Типы данных:</h2>
                    <div class="card">
                        <h3>
                            <b>2.1 Числа (включая booleans):</b> 
                            <span class="code">int, bool, float, complex</span>
                        </h3>
                        <div class="text-in-card">
                            <p>
                                В Python есть 3 числовых типа:
                                <ul>
                                    <li><b class="red">int</b> - Integer, целые числа.
                                        <ul>
                                            <li>
                                                <b class="red">bool</b> - Boolean, логический тип данных, 
                                                принимает значения True или False, которые можно заменить на 1 и 0.
                                            </li>
                                        </ul>
                                    </li>
                                    <li><b class="red">float</b> - числа с плавающей точкой, аналог вещественных чисел.</li>
                                    <li><b class="red">complex</b> - комплексные числа.</li>
                                </ul>
                            </p>
                            <p>
                                Примеры:
                                <pre class="code">a=-177463 #int<br>q = True #bool<br>b=-35.59 #float<br>c=35e3 #== 35000 float<br>w_1=5+6j #complex<br>w_2=3-2j #complex<br>w_1*w_2==27+8j</pre>
                            </p>
                        </div>
                        <h3>
                            <b>2.2 Строки и их методы:</b> 
                            <span class="code">'...', "..."</span>
                        </h3>
                        <div class="text-in-card">
                            <p>
                                Помимо чисел, Python может манипулировать строками, 
                                которые могут быть определены несколькими способами. 
                                Они могут быть заключены в одинарные кавычки (<b class="red">'...'</b>) 
                                <span class="code">name_1 = 'John'</span>
                                или двойные кавычки (<b class="red">"..."</b>) 
                                <span class="code">name_2 = "John"</span>, разницы в этих 2-х определениях нет.
                            </p>
                            <p>
                                Символ <b class="red">\</b> экранирует кавычки, чтобы они тоже 
                                отображались в строке <span class="code">string_eg = 'doesn\'t'</span>. 
                                А символ <span class="code">\n</span> переносит строку на новую строчку.
                            </p>
                            <p>
                                Строки могут быть проиндексированы, причем первый символ имеет индекс 0.
                               Нет отдельного типа символов; символ - это просто строка.
                               Можно индексировать строку и с конца, но тогда начать нужно с -1. 
                               В дополнение к индексации, поддерживаются срезы, позволяющие получить набор символов из начальной строки.
                               <br>Примеры:
                               <pre class="code">word = 'Python'<br>word[0] == 'P'<br>word[5] == 'n'<br>word[-1] == 'n'<br>word[-2] == 'o'<br>word[0:2] == 'Py' # это срез.</pre>
                            </p>
                            <p>
                                Строки так же можно складывать <span class="code">'J'+'ython' == 'Jython'</span> или умножать <span class="code">3 * 'J' == 'JJJ'</span>.
                            </p>
                            <p>
                                Методы для работы со строками:
                                <ul>
                                    <li>
                                        Метод <b class="red">strip()</b> удаляет все пробелы в начале и в конце строки.
                                        <br><span class="code">strip(" Python ") == "Python"</span>
                                    </li>
                                    <li>
                                        <b class="red">len()</b> возвращает длину строки.
                                        <br><span class="code">len("Python") == 6</span>
                                    </li>
                                    <li>
                                        Метод <b class="red">lower()</b> возвращает строку в нижнем регистре.
                                        <br><span class="code">"PyThon".lower() == 'python'</span>
                                    </li>
                                    <li>
                                        Метод <b class="red">upper()</b> возвращает строку в верхнем регистре.
                                        <br><span class="code">"PyThon".upper() == 'PYTHON'</span>
                                    </li>
                                    <li>
                                        Метод <b class="red">replace()</b> заменяет строку другой строкой.
                                        <br><span class="code">"Python".replace('P', 'J') == 'Jython'</span>
                                    </li>
                                    <li>
                                        Метод <b class="red">split()</b> разбивает строку на подстроки, 
                                        если он находит экземпляры разделителя. Если разделитель не указан, 
                                        то разбивает по символам.
                                        <br><span class="code">"Hello, World".split(',') == ['Hello', ' World!']</span>
                                        <br><span class="code">"Python".split() == ['P', 'y', 't', 'h', 'o', 'n']</span>
                                    </li>
                                    <li>
                                        Метод <b class="red">capitalize()</b> преобразует первый символ в верхний регистр.
                                        <br><span class="code">'low letter at the beginning'.capitalize() == 'Low letter at the beginning'</span>
                                    </li>
                                    <li>
                                        Метод <b class="red">count()</b> возвращает количество раз, когда указанная строка встречается в начальной строке.
                                        <br><span class="code">'low letter at the beginning'.count('t') == 4</span>
                                    </li>
                                    <li>
                                        Метод <b class="red">find()</b> ищет в строке указанную подстроку и возвращает позицию, где она была найдена.
                                        <br><span class="code">'Hello, welcome to my world'.find('welcome') == 7</span>
                                    </li>
                                    <li>
                                        Метод <b class="red">title()</b> преобразует первый символ каждого слова 
                                        (наборы символов разделённые пробелом) в верхний регистр.
                                        <br><span class="code">'Welcome to my world'.title() == 'Welcome To My World'</span>
                                    </li>
                                    <li>
                                        Метод <b class="red">join()</b> объединяет элементы кортежа (передаваемого аргументом), 
                                        разделяя их строкой к которой мы этот метот и применяем.
                                        <br><span class="code">my_tuple = ('John', 'Peter', 'Vicky')</span>
                                        <br><span class="code">', '.join(my_tuple) == 'John, Peter, Vicky'</span>
                                    </li>
                                    <li>
                                        Метод <b class="red">isalpha()</b> возвращает True если все символы в строке являются буквами.
                                        <br><span class="code">'CompanyX'.isalpha() == True</span>
                                        <br><span class="code">'Company33X'.isalpha() == False</span>
                                    </li>
                                    <li>
                                        Метод <b class="red">isdecimal()</b> возвращает True если все символы в строке являются цифрами.
                                        <br><span class="code">'1234'.isdecimal() == True</span>
                                        <br><span class="code">'12fff34'.isdecimal() == False</span>
                                    </li>
                                </ul>
                            </p>
                            <p>
                                В строки можно вставлять аргументы если перед строкой поставить f :
                                <pre class="code">year = 2018<br>event = 'conference'<br>f'Results of the {year} {event}' == 'Results of the 2018 conference'</pre>
                            </p>
                            <p>
                                С помощью метода <b class="red">str()</b> в струку можно преобразовывать другие типы данных: 
                                <span class="code">str(5) == '5'</span>
                                А метод repr() делает строки так как они записаны: 
                                <pre class="code">a = 10 * 3.25<br>b = 200 * 200<br>repr((a, b, ('spam', 'eggs'))) == "(32.5, 40000, ('spam', 'eggs'))"</pre>
                            </p>
                        </div>
                        <h3>
                            <b>2.3 Списки и их методы:</b> 
                            <span class="code">[...]</span>
                        </h3>
                        <div class="text-in-card">
                            <p>
                                Python знает несколько составных типов данных, 
                                используемых для группировки. Наиболее универсальным является 
                                список, который определяется как набор элементов, разделенных запятыми, 
                                в квадратных скобках <span class="code">squares = [1, 4, 9, 16, 25]</span>. 
                                Список может содержать элементы разных типов, 
                                но обычно все эти элементы имеют один и тот же тип данных.
                            </p>
                            <p>
                                Списки так же как и строки индексируются и срезаются:
                                <pre class="code">squares = [1, 4, 9, 16, 25]<br>squares[0] == 1<br>squares[-3:] == [9, 16, 25]</pre>
                            </p>
                            <p>
                                Списки также поддерживают такие операции, как конкатенация (сложение, склейка) 
                                <br><span class="code">[1, 4, 9] + [36, 49, 64] == [1, 4, 9, 36, 49, 64]</span>
                            </p>
                            <p>
                                Списки в отличии от строк являются изменяемыми:
                                <pre class="code">cubes = [1, 8, 27, 65, 125]<br>cubes[3] = 64 #== [1, 8, 27, 64, 125] <br>cubes[1:2] = [1, 2] #== [1, 1, 1, 64, 125]</pre>
                            </p>
                            <p>
                                С помощью метода append() можно добавить элемент в конец списка 
                                <span class="code">[1, 8, 27, 64, 125].append(7 ** 3) == [1, 8, 27, 64, 125, 343]</span>.
                                Можно создавать вложенные (многомерные списки) <span class="code">mixed_list == [['a', 'b', 'c'], [1, 2, 3]]</span>.
                                Так же можно очистить список с помощью среза 
                                <pre class="code">letters = ['a', 'b', 'f', 'g']<br> letters[:] = [] # == []</pre> 
                            </p>
                            <p>
                                Методы для работы со списками:
                                <ul>
                                    <li>
                                        Функция <b class="red">len()</b> возвращает длину списка:
                                        <br><span class="code">len(['a', 'b', 'c', 'd']) == 4</span>
                                    </li>
                                    <li>
                                        Метод <b class="red">remove(x)</b> удаляет первый элемент со значением x:
                                        <br><span class="code">['orange', 'apple', 'pear'].remove('apple') == ['orange', 'pear']</span>
                                    </li>
                                    <li>
                                        Метод <b class="red">insert(i, x)</b> вставляет элемент x на позицию i:
                                        <br><span class="code">['apple, 'orange'].insert(0, 'grape') == ['grape', 'apple, 'orange']</span>
                                    </li>
                                    <li>
                                        Метод <b class="red">index(x, start, end)</b> возвращает позицию первого 
                                        вхождения элемента x начиная со start до end (не обязательные аргументы)
                                        <pre class="code">[1,3,8,3,7].index(3, 2) == 3 <br>[1,3,8,3,7].index(3) == 1</pre>
                                    </li>
                                    <li>
                                        Метод <b class="red">count(x)</b> возвращает количество вхождений элемента x:
                                        <br><span class="code">[3,5,7,2,4,3].count(3) == 2</span>
                                    </li>
                                    <li>
                                        Метод <b class="red">copy()</b> возвращает копию списка:
                                        <br><span class="code">a = [3,6,3,3].copy() #a == [3,6,3,3]</span>
                                    </li>
                                    <li>
                                        Метод <b class="red">reverse()</b> возвращает "перевёрнутый" список:
                                        <br><span class="code">[1,2,4,5].reverse() == [5,4,2,1]</span>
                                    </li>
                                    <li>
                                        Метод <b class="red">sort(key=None, reverse=False)</b> сортирует список 
                                        (если нужно сортировать не цифры, то лучше прочитать подробнее)
                                        <br><span class="code">[2,4,73,1,4,3].sort() == [1,2,3,4,4,73]</span>
                                    </li>
                                    <li>
                                        Метод <b class="red">pop()</b> удаляет последний элемент списка и возвращает его
                                        <pre class="code">fruits == ['banana', 'kiwi', 'apple', 'banana']<br>fruits.pop() == 'banana'<br>fruits == ['banana', 'kiwi', 'apple']</pre>
                                    </li>
                                    <li>
                                        Метод <b class="red">clear()</b> удаляет список:
                                        <br><span class="code">fruits.clear() == []</span>
                                    </li>
                                    <li>
                                        Приписка <b class="red">del</b> позволяет удалить элемент по его индексу:
                                        <pre class="code">numbers = [-1, 1, 66.25, 333, 333, 1234.5]<br>del numbers[0]<br>numbers == [1, 66.25, 333, 333, 1234.5]</pre>
                                    </li>
                                </ul>
                            </p>
                            <p>
                                Можно автоматизировать создание списков, например с помощью цикла:
                                <pre class="code">squares = []<br>for number in range(10):<br>squares.append(number ** 2)<br><br>assert squares == [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</pre>
                            </p>
                            <p>
                                С помощью лямбда функции: 
                                <br><span class="code">squares = list(map(lambda x: x ** 2, range(10)))</span>
                                <br>Или с помощью конструктора списков: 
                                <br><span class="code">combinations = [(x, y) for x in [1, 2, 3] for y in [3, 1, 4] if x != y]</span>
                                <br>Так же можно применять функции в элементам списка: 
                                <br><span class="code">abs_vector = [abs(x) for x in vector] #Применяем модуль ко всем элементам списка vector</span>
                            </p>
                        </div>
                        <h3>
                            <b>2.4 Кортежи:</b> 
                            <span class="code">(...)</span>
                        </h3>
                        <div class="text-in-card">
                            <p>
                                Кортеж - это коллекция, которая упорядочена и неизменна. 
                                В Python кортежи пишутся с круглые скобки.
                            </p>
                            <p>
                                Кортежи индексируются:
                                <pre class="code">fruits_tuple = ("apple", "banana", "cherry")<br>fruits_tuple[1] == "banana"</pre>
                            </p>
                            <p>
                                Кортежи могут быть вложенными или пустыми: 
                                <br><span class="code">nested_tuple == ((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))</span>
                                <br><span class="code">tuple == ()</span>
                            </p>
                            <p>
                                Фунция <b class="red">len()</b> возвращает длинну массива: <br><span class="code">len(("apple")) == 1</span>
                            </p>
                        </div>
                        <h3>
                            <b>2.5 Наборы и их методы:</b> 
                            <span class="code">{...}</span>
                        </h3>
                        <div class="text-in-card">
                            <p>
                                Набор - это неупорядоченная и неиндексированная коллекция (Аналог множеств). 
                                В Python наборы пишутся с помощью фигурных скобок. Наборы также поддерживают 
                                математические операции, такие как объединение, пересечение, разность и 
                                симметричная разница.
                                <br><span class="code">fruits_set = {"apple", "banana", "cherry"}</span>
                            </p>
                            <p>
                                Методы для работы с наборами:
                                <ul>
                                    <li>
                                        С помощью конструкции <b class="red">in</b> можно узнать есть ли указанный элемент в наборе:
                                        <br><span class="code">"apple" in {"apple", "banana", "cherry"} == True</span>
                                    </li>
                                    <li>
                                        С помощью функции <b class="red">len()</b> можно узнать длинну набора:
                                        <br><span class="code">len({"apple", "banana", "cherry"}) == 3</span>
                                    </li>
                                    <li>
                                        С помощью метода <b class="red">add()</b> можно добавить элемент в конец набора:
                                        <br><span class="code">{"apple", "banana", "cherry"}.add("pineapple") == {"apple", "banana", "cherry", "pineapple"}</span>
                                    </li>
                                    <li>
                                        Метод <b class="red">remove(x)</b> позволяет удали элемент x:
                                        <br><span class="code">{"apple", "banana", "cherry"}.remove("apple") == {"banana", "cherry"}</span>
                                    </li>
                                    <li>
                                        С помощью метода <b class="red">set()</b> мы можем разбить другой объект в набор, 
                                        заметим что элементы в наборе не повторяются:
                                        <br><span class="code">set('abracadabra') == {'a', 'r', 'b', 'c', 'd'}</span>
                                    </li>
                                    <li>
                                        Мы можем найти разность наборов (удаляет повторяющиеся элементы):
                                        <br><span class="code">{'a', 'r', 'b', 'c', 'd'} - {'a', 'l', 'c', 'z', 'm'} == {'r', 'b', 'd'}</span>
                                    </li>
                                    <li>
                                        Операция объединения (<b class="red">|</b>):
                                        <br><span class="code">{'a', 'r', 'b', 'c', 'd'} | {'a', 'l', 'c', 'z', 'm'} == {'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}</span>
                                    </li>
                                    <li>
                                        Операция пересечения (<b class="red">&</b>):
                                        <br><span class="code">{'a', 'r', 'b', 'c', 'd'} & {'a', 'l', 'c', 'z', 'm'} == {'a', 'c'}</span>
                                    </li>
                                    <li>
                                        Операция симметричной разности (<b class="red">^</b>):
                                        <br><span class="code">{'a', 'r', 'b', 'c', 'd'} ^ {'a', 'l', 'c', 'z', 'm'} == {'r', 'd', 'b', 'm', 'z', 'l'}</span>
                                    </li>
                                </ul>
                            </p>
                        </div>
                        <h3>
                            <b>2.6 Словари:</b> 
                            <span class="code">{ key:values }</span>
                        </h3>
                        <div class="text-in-card">
                            <p>
                                Словарь - это неупорядоченная, изменяемая и 
                                индексируемая коллекция. В Python словари есть написано в 
                                фигурных скобках, и они имеют ключи и значения.
                                <pre class="code">fruits_dictionary = {<br>    'cherry': 'red',<br>    'apple': 'green',<br>    'banana': 'yellow',<br>}</pre>
                            </p>
                            <p>
                                Что можно делать со словарями?
                                <ul>
                                    <li>
                                        Можно искать значение по ключу:
                                        <br><span class="code">fruits_dictionary['apple'] == 'green'</span>
                                    </li>
                                    <li>
                                        Чтобы проверить, есть ли один ключ в словаре, 
                                        используйте ключевое слово <b class="red">in</b>.
                                        <br><span class="code">'apple' in fruits_dictionary == True</span>
                                    </li>
                                    <li>
                                        Можно изменить значение в ключе:
                                        <br><span class="code">fruits_dictionary['apple'] = 'red'</span>
                                    </li>
                                    <li>
                                        Можно добавить новый ключ со значением:
                                        <br><span class="code">fruits_dictionary['pineapple'] = 'yellow'</span>
                                    </li>
                                    <li>
                                        Функция <b class="red">list()</b> возвращает множество ключей словаря:
                                        <br><span class="code">list(fruits_dictionary) == ['cherry', 'apple', 'banana', 'pineapple']</span>
                                    </li>
                                    <li>
                                        Функция <b class="red">sorted()</b> возвращает отсортированное множество ключей:
                                        <br><span class="code">sorted(fruits_dictionary) == ['apple', 'banana', 'cherry', 'pineapple']</span>
                                    </li>
                                    <li>
                                        С помощью конструкции <b class="red">del</b> можно удалить пару ключ-значение (удаляется по ключу):
                                        <br><span class="code">del fruits_dictionary['pineapple']</span>
                                    </li>
                                    <li>
                                        Можно составить словарь с помощью конструктора словарей:
                                        <br><span class="code">dictionary_via_expression = {x: x**2 for x in (2, 4, 6)}</span>
                                    </li>
                                </ul>
                            </p>
                        </div>
                        <h3>
                            <b>2.7 Приведение типов:</b> 
                            <span class="code">int(), float(), str()</span>
                        </h3>
                        <div class="text-in-card">
                            <p>
                                Python является объектно-ориентированным языком, 
                                и поэтому он использует классы для определения типов данных, включая его примитивные типы.
                                Поэтому приведение в python выполняется с помощью функций конструктора:
                                <ul>
                                    <li>
                                        <b class="red">int()</b> - создает целое число из целочисленного типа, 
                                        типа float (округляя к предыдущему целому числу) или строкового типа 
                                        (при условии, что строка представляет собой целое число). Примеры:
                                        <pre class="code">int(1) == 1<br>int(2.8) == 2<br>int('3') == 3</pre>
                                    </li>
                                    <li>
                                        <b class="red">float()</b> - создает число с плавающей точкой из целочисленного типа, 
                                        типа float или строкового типа данных 
                                        (При условии что строка это число с плавающей точкой или целое число). Примеры:
                                        <pre class="code">float(1) == 1.0<br>float(2.8) == 2.8<br>float("3") == 3.0<br>float("4.2") == 4.2</pre>
                                    </li>
                                    <li>
                                        <b class="red">str()</b> - создает строку из множетсва типов данных, 
                                        включая строки, целые числа и числа с плавающей точкой. Примеры:
                                        <pre class="code">str("s1") == 's1'<br>str(2) == '2'<br>str(3.0) == '3.0'</pre>
                                    </li>
                                </ul>
                            </p>
                        </div>
                    </div>
                    <h2 id="5">5. Классы:</h2>
                    <div class="card">
                        <h3><b>5.1 Инициализация класса: <span class="code">class</span>.</b></h3>
                        <div class="text-in-card">
                            <p>
                                Python - это объектно-ориентированный язык программирования. 
                                Все в Python является объектом, со своими свойствами и методами. 
                                Класс это на конструктор объектов или «план» для создания объектов.
                            </p>
                            <p>
                                Создание класса в Python начинается с инструкции <b class="red">class</b>. 
                                Вот так будет выглядеть минимальный класс:
                                <pre class="code">class C:<br>    pass</pre>
                            </p>
                            <p>
                                Класс состоит из объявления (инструкция class), 
                                имени класса (нашем случае это имя C) и тела класса, которое 
                                содержит атрибуты и методы (в нашем минимальном классе есть только одна инструкция pass).
                            </p>
                            <p>
                                Для того чтобы создать объект класса необходимо воспользоваться следующим синтаксисом:
                                <br><span class="code">имя_объекта = имя_класса()</span>
                            </p>
                            <p>
                                Класс может содержать атрибуты и методы. Ниже представлен класс, 
                                содержащий атрибуты color (цвет), width (ширина), height (высота).
                                <pre class="code">class Rectangle:<br>    color = “green”<br>    width = 100<br>    height = 100</pre>
                            </p>
                            <p>
                                Доступ к атрибуту класса можно получить следующим образом:
                                <br><pre class="code">rect1 = Rectangle()<br>print(rect1.color)</pre>
                            </p>
                            <p>
                                <b class="red">Метод</b> – это функция находящаяся внутри класса, выполняющая определенную работу, 
                                которая, чаще всего, предполагает доступ к атрибутам созданного объекта. 
                                Слово <b class="red">self</b> указывает методу, с каким объектом он работает, это позволяет работать 
                                со свойствами этого объекта.
                                <pre class="code">class Rectangle:<br>    width = 100<br>    height = 100<br>    def square(self):<br>        return self.width * self.height</pre>
                            </p>
                        </div>
                        <h3><b>5.2 Конструктор класса: <span class="code">__init__(self)</span>.</b></h3>
                        <div class="text-in-card">
                            <p>
                                Конструктор класса позволяет задать определенные параметры объекта при его создании. 
                                Таким образом появляется возможность создавать объекты с уже заранее заданными атрибутами. 
                                Конструктором класса является метод: <b class="red">__init__(self)</b>
                                <pre class="code">class Rectangle:<br>def __init__(self, color="green", width=100, height=100):<br>    self.color = color<br>    self.width = width<br>    self.height = height<br><br>def square(self):<br>    return self.width * self.height</pre>
                            </p>
                        </div>
                        <h3><b>5.3 Наследование.</b></h3>
                        <div class="text-in-card">
                            <p>
                                В организации наследования участвуют как минимум два класса: 
                                класс родитель и класс потомок. При этом возможно множественное наследование, 
                                в этом случае у класса потомка есть несколько родителей.
                                <br>Синтаксически создание класса с указанием его родителя/ей выглядит так:
                                <br><b class="red">class имя_класса(имя_родителя1, [имя_родителя2,…, имя_родителя_n])</b>
                                <pre class="code">class Figure:<br>    def __init__(self, color):<br>        self.color = color<br><br>    def get_color(self):<br>        return self.color<br><br>class Rectangle(Figure):<br>    def __init__(self, color, width=100, height=100):<br>        super().__init__(color)<br>        self.width = width<br>        self.height = height<br><br>    def square(self):<br>        return self.width*self.height<br><br>rect1 = Rectangle("blue")<br>print(rect1.get_color())<br>print(rect1.square())<br>rect2 = Rectangle("red", 25, 70)<br>print(rect2.get_color())<br>print(rect2.square())</pre>
                            </p>
                        </div>
                        <h3><b>5.4 Полиморфизм.</b></h3>
                        <div class="text-in-card">
                            <p>
                                <b class="red">Полиморфизм</b> - переопределение методов базового класса в классе наследнике. 
                                Добавим в базовый класс метод info(), который печатает сводную информацию по 
                                объекту класса Figure и переопределим этот 
                                метод в классе Rectangle, где добавим дополнительные данные и вывод.
                                <pre class="code">class Figure:<br>    def __init__(self, color):<br>        self.color = color<br><br>    def get_color(self):<br>        return self.color<br><br>    def info(self):<br>        print("Figure")<br>        print("Color: " + self.color)<br><br>class Rectangle(Figure):<br>    def __init__(self, color, width=100, height=100):<br>        super().__init__(color)<br>        self.width = width<br>        self.height = height<br><br>    def square(self):<br>        return self.width * self.height<br><br>    def info(self):<br>        print("Rectangle")<br>        print("Color: " + self.color)<br>        print("Width: " + str(self.width))<br>        print("Height: " + str(self.height))<br>        print("Square: " + str(self.square()))<br><br>fig1 = Figure("green")<br>print(fig1.info())<br>rect1 = Rectangle("red", 24, 45)<br>print(rect1.info())</pre>
                            </p>
                        </div>
                    </div>
                    <h2 id="6">6. Модули:</h2>
                    <div class="card">
                        <div class="text-in-card">
                            <p>
                                Модулем в Python называется любой файл с программой.
                                Подключить модуль можно с помощью инструкции <b class="red">import</b>. 
                                К примеру, подключим модуль os для получения текущей директории:
                                <br><span class="code">import os</span>
                                <br>Стоит отметить, что если указанный атрибут модуля не будет найден, 
                                возбудится исключение <b class="red">AtributeError</b>. А если не удастся найти модуль для 
                                импортирования, то <b class="red">ImportError</b>.
                            </p>
                            <p>
                                Если название модуля слишком длинное, или оно вам не нравится 
                                по каким-то другим причинам, то для него можно создать псевдоним, 
                                с помощью ключевого слова <b class="red">as</b>.
                                <br><span class="code">import math as m</span>
                                <br>Теперь доступ ко всем атрибутам модуля math осуществляется только 
                                с помощью переменной m, а переменной math в этой программе уже не будет 
                                (если, конечно, вы после этого не напишете import math, тогда модуль 
                                будет доступен как под именем m, так и под именем math).
                            </p>
                            <p>
                                Подключить определенные атрибуты модуля можно с помощью инструкции <b class="red">from</b>. 
                                Она имеет несколько форматов:
                                <pre class="code">from <Название модуля> import <Атрибут 1> [ as <Псевдоним 1> ], <br>    [<Атрибут 2> [ as <Псевдоним 2> ] ...]<br>from <Название модуля> import *</pre>
                            </p>
                            <p>
                                Первый формат позволяет подключить из модуля только указанные вами атрибуты. 
                                Для длинных имен также можно назначить псевдоним, 
                                указав его после ключевого слова <b class="red">as</b>.
                                <br><span class="code">from math import e, ceil as c</span>
                                <br>Второй формат инструкции from позволяет 
                                подключить все (точнее, почти все) переменные из модуля.
                            </p>
                            <p>
                                Чтобы импортировать свой модуль, 
                                нужно указать название файла-модуля, который находится в той же папке.
                                Пути поиска модулей указаны в переменной sys.path.
                                В него включены текущая директория (то есть модуль можно оставить в папке с основной программой), 
                                а также директории, в которых установлен python. Кроме того, переменную sys.path можно изменять вручную, 
                                что позволяет положить модуль в любое удобное для вас место 
                                (главное, не забыть в главной программе модифицировать sys.path).
                            </p>
                        </div>
                    </div>
                    <h2 id="8">8. Файлы:</h2>
                    <div class="card">
                        <h3><b>8.1 Открытие, закрытие файла: <span class="code">open(), close()</span></b></h3>
                        <div class="text-in-card">
                            <p>
                                Перед тем как прочесть и записать что-либо в файл, его следует открыть. 
                                Чтобы открыть файл в Python используется встроенная функция 
                                <b class="red">open()</b>. При вызове, эта функция создает объект типа файл, 
                                с которым в дальнейшем можно работать.
                                <br>Синтаксис функции open() в Python.
                                <br><b class="red">my_file = open(имя_файла [, режим_доступа][, буферизация])</b>
                                <br>имя_файла: строка, содержащая имя файла с расширением. Например, "my_file.txt":
                                <ul>
                                    <li>
                                        <b class="red">имя_файла</b>: строка, содержащая имя файла с расширением. Например, "my_file.txt".
                                    </li>
                                    <li>
                                        <b class="red">режим_доступа</b>: строка, которой мы указываем для чего открывается файл: 
                                        для чтения, записи, добавления информации, и т.д. Например, "w". 
                                        По умолчанию файл открывается для чтения - "r".
                                    </li>
                                    <li>
                                        <b class="red">буферизация</b>: Целое число. Если значение аргумента указано 
                                        0 - файл открывается без буферизации, 1 с построчной буферизацией, 
                                        больше одного процесс буферизации выполняется с указанным размером буфера. 
                                        Отрицательное число - разер буфера будет равен системному.
                                    </li>
                                </ul>
                            </p>
                            <p>
                                Список режимов доступа к файлу в Python:
                                <ul>
                                    <li>
                                        <b class="red">r</b> - Открывает файл только для чтения. Указатель стоит в начале файла.
                                    </li>
                                    <li>
                                        <b class="red">rb</b> - Открывает файл для чтения в двоичном формате. Указатель стоит в начале файла.
                                    </li>
                                    <li>
                                        <b class="red">r+</b> - Открывает файл для чтения и записи. Указатель стоит в начале файла.
                                    </li>
                                    <li>
                                       <b class="red">rb+</b> - Открывает файл для чтения и записи в двоичном формате. Указатель стоит в начале файла.
                                    </li>
                                    <li>
                                        <b class="red">w</b> - Открывает файл только для записи. Указатель стоит в начале файла. 
                                        Создает файл с именем имя_файла, если такового не существует.
                                    </li>
                                    <li>
                                        <b class="red">wb</b> - Открывает файл для записи в двоичном формате. Указатель стоит в начале файла. 
                                        Создает файл с именем имя_файла, если такового не существует.
                                    </li>
                                    <li>
                                        <b class="red">w+</b> - Открывает файл для чтения и записи. Указатель стоит в начале файла. 
                                        Создает файл с именем имя_файла, если такового не существует.
                                    </li>
                                    <li>
                                        <b class="red">wb+</b> - Открывает файл для чтения и записи в двоичном формате. 
                                        Указатель стоит в начале файла. Создает файл с именем имя_файла, 
                                        если такового не существует.
                                    </li>
                                    <li>
                                        <b class="red">a</b> - Открывает файл для добавления информации в файл. 
                                        Указатель стоит в конце файла. Создает файл с именем имя_файла, если такового не существует.
                                    </li>
                                    <li>
                                        <b class="red">ab</b> - Открывает файл для добавления в двоичном формате. 
                                        Указатель стоит в конце файла. Создает файл с именем имя_файла, 
                                        если такового не существует.
                                    </li>
                                    <li>
                                        <b class="red">a+</b> - Открывает файл для добавления и чтения. Указатель стоит в конце файла. 
                                        Создает файл с именем имя_файла, если такового не существует.
                                    </li>
                                    <li>
                                        <b class="red">ab+</b> - Открывает файл для добавления и чтения в двоичном формате. 
                                        Указатель стоит в конце файла. Создает файл с именем имя_файла, 
                                        если такового не существует.
                                    </li>
                                </ul>
                            </p>
                            <p>
                                <b>Атрибуты файлового объекта в Python.</b> 
                                Как только файл был открыт и у вас появился файловый объект, 
                                вы можете получить следующую информацию о нем:
                                <ul>
                                    <li>
                                        <b class="red">file.closed</b> - Возвращает True если файл был закрыт.
                                    </li>
                                    <li>
                                        <b class="red">file.mode</b> - Возвращает режим доступа, с которым был открыт файл.
                                    </li>
                                    <li>
                                        <b class="red">file.name</b> - Возвращает имя файла.
                                    </li>
                                    <li>
                                        <b class="red">file.softspace</b> - Возвращает False если при выводе содержимого файла 
                                        следует отдельно добавлять пробел.
                                    </li>
                                </ul>
                            </p>
                            <p>
                                Метод файлового объекта <b class="red">close()</b> автоматически закрывает файл, 
                                при этом теряется любая несохраненная информация. 
                                Работать с файлом (читать, записывать) после этого нельзя.
                                Python автоматически закрывает файл если файловый объект к которому он привязан 
                                присваивается другому файлу. Однако, хорошей практикой будет 
                                вручную закрывать файл командой close().
                                <br>Пример:
                                <pre class="code">my_file = open("some.txt")<br>print("Имя файла: ", my_file.name)<br>print("Файл закрыт: ", my_file.closed)<br>my_file.close()<br>print("А теперь закрыт: ", my_file.closed)</pre>
                            </p>
                        </div>
                        <h3><b>8.2 Чтение и запись файлов: <span class="code">write(), read()</span></b></h3>
                        <div class="text-in-card">
                            <p>
                                Метод <b class="red">write()</b> записывает любую строку в открытый файл. 
                                Важно помнить, что строки в Python могут содержать двоичные данные, 
                                а не только текст.
                                Метод write() не добавляет символ переноса строки ('\n') в конец файла.
                                <br>Пример:
                                <pre class="code"> my_file = open("some.txt", "w")<br>my_file.write("Мне нравится Python!\nЭто классный язык!")<br>my_file.close()</pre>
                            </p>
                            <p>
                                Метод <b class="red">read()</b> читает строку из открытого файла 
                                <span class="code">my_file.read([count])</span>.
                                <br>Необязательный параметр <b class="red">count</b> - это количество байт, которые следует 
                                прочитать из открытого файла. Этот метод читает информацию с начала файла и, 
                                если параметр count не указан, до конца файла.
                                <br>Например:
                                <pre class="code">my_file = open("some.txt")<br>my_string = my_file.read()<br>print("Было прочитано:")<br>print(my_string)<br>my_file.close()</pre>
                            </p>
                            <p>
                                После того как вы вызвали метод read() на файловом объекте, 
                                если вы повторно вызовете read(), то увидите лишь пустую строку. 
                                Это происходит потому, что после первого прочтения указатель находится в конце файла. 
                                Для того чтобы узнать позицию указателя можно использовать метод <b class="red">tell()</b>.
                                <pre class="code">my_file = open("some.txt")<br>my_file.read(10)<br>print ("Я на позиции:", my_file.tell())<br>my_file.close()</pre>
                            </p>
                            <p>
                                Чтобы перейти на нужную нам позицию, следует использовать другой метод - <b class="red">seek()</b>.
                                <br><span class="code">my_file.seek(0)</span>
                            </p>
                        </div>
                    </div>
                    <h2 id="11">11. Дата и время:</h2>
                    <div class="card">
                        <h3><b><a href="https://docs.python.org/3/library/datetime.html" target="_blank">11.1 Библиотека datetime.</a></b></h3>
                        <div class="text-in-card">
                            <p>
                                Модуль <b class="red">datetime</b> предоставляет классы для обработки времени и даты разными способами. 
                                Поддерживается и стандартный способ представления времени, однако больший упор 
                                сделан на простоту манипулирования датой, временем и их частями.
                                <br><span class="code">import datetime</span>
                                <br><b>Модуль экспортирует следующие константы:</b>
                                <ul>
                                    <li>
                                        <span class="code">datetime.MINYEAR</span> - Наименьшее число года, допустимое в объекте date или datetime.
                                    </li>
                                    <li>
                                        <span class="code">datetime.MAXYEAR</span> - Наибольший номер года, допустимый в dateили datetimeобъекте.
                                    </li>
                                </ul>
                            </p>
                            <p>
                                <b>
                                    Модуль <span class="red">datetime</span> включает в себя несколько разных классов, каждый из которых обладает собственными 
                                    методами и свойствами, а также служит для определенных целей.
                                </b>
                                <ul>
                                    <li>
                                        <b class="red">date</b> - Представляет собой дату, полностью исключая данные о времени, на основе Григорианского календаря
                                        <br><span class="code">from datetime import data</span>
                                        <ul>
                                            <li>
                                                <span class="code">.today()</span> - Вернуть текущую местную дату. Это эквивалентно date.fromtimestamp(time.time()).
                                                <br><span class="code">date.today() # datetime.date(2017, 5, 3)</span>
                                            </li>
                                            <li>
                                                <span class="code">.yaer</span> - Возвращает год.
                                                <br><span class="code">date.today().yaer #2017</span>
                                            </li>
                                            <li>
                                                <span class="code">.month</span> - Возвращает месяц.
                                                <br><span class="code">date.today().month #5</span>
                                            </li>
                                            <li>
                                                <span class="code">.day</span> - Возвращает день.
                                                <br><span class="code">date.today().day #3</span>
                                            </li>
                                            <li>
                                                <span class="code">.fromordinal(<Количество дней с 1 года>)</span> - Возвращает дату date, 
                                                соответствующую количеству дней, прошедших с 1 года:
                                                <br><pre class="code">datetime.date.max.toordinal() # 3652059<br>datetime.date.fromordinal(3652059) # datetime.date(9999, 12, 31)<br>datetime.date.fromordinal(1) # datetime.date(1, 1, 1)</pre>
                                            </li>
                                            <li>
                                                <span class="code">.fromtimestamp(<Количество секунд>)</span> - Возвращает дату date, 
                                                соответствующую количеству секунд, прошедших с начала эпохи:
                                                <br><pre class="code">datetime.date.fromtimestamp(time.time()) <br># datetime.date(2014, 8, 24)<br>datetime.date.fromtimestamp(1233368623.0) <br># datetime.date(2009, 1, 31)</pre>
                                            </li>
                                            <li>
                                                <span class="code">.isoformat(date)</span> - Возвращает строку, дату в исо формате:
                                                <br><pre class="code">datetime.date.isoformat(datetime.date.today())<br># '2017-03-05'</pre>
                                            </li>
                                            <li>
                                                <span class="code">.ctime()</span> - Возвращает строку специального формата:
                                                <br><pre class="code">datetime.date().ctime()<br># 'Sun Jun 5 00:00:00 2011'</pre>
                                            </li>
                                            <li>
                                                <span class="code">.isocalendar()</span> - Возвращает кортеж из 3х элементов 
                                                (год, номер недели и порядковый номер дня в неделе).
                                            </li>
                                            <li>
                                                <span class="code">.isoformat()</span> - Возвращает дату в формате ГГГГ-ДД-ММ.
                                            </li>
                                            <li>
                                                <span class="code">.isoweekday()</span>- Возвращает порядковый номер дня недели 
                                                (начинается с 1).
                                            </li>
                                            <li>
                                                <span class="code">.replace([year][, month][ , day])</span> - 
                                                Возвращает дату с обновленными значемниями.
                                            </li>
                                            <li>
                                                <span class="code">.strftime(<Строка формата>)</span> - 
                                                Возвращает отформатированную строку.
                                            </li>
                                            <li>
                                                <span class="code">.timetuple()</span> - 
                                                Возвращает time.struct_time с датой и временем.
                                            </li>
                                            <li>
                                                <span class="code">.toordinal()</span> - 
                                                Возвращает количесвто дней, прошедших с 1 года.
                                            </li>
                                            <li>
                                                <span class="code">.weekday()</span> - 
                                                возвращает порядковый номер дня в недели (начинается с 0).
                                            </li>
                                        </ul>
                                    </li>
                                    <li>
                                        <b class="red">datetime</b> - Содержит информацию о времени и дате, основываясь на данных из Григорианского календаря
                                        <br><span class="code">from datetime import datetime</span>
                                        <ul>
                                            <li>
                                                <span class="code">.year</span> - Год.
                                            </li>
                                            <li>
                                                <span class="code">.month</span> - Месяц.
                                            </li>
                                            <li>
                                                <span class="code">.day</span> - День.
                                            </li>
                                            <li>
                                                <span class="code">.hour</span> - Часы.
                                            </li>
                                            <li>
                                                <span class="code">.minute</span> - Минуты.
                                            </li>
                                            <li>
                                                <span class="code">.second</span> - Секунды.
                                            </li>
                                            <li>
                                                <span class="code">.microsecond</span> - Микросекунды.
                                            </li>
                                            <li>
                                                <span class="code">.tzinfo</span> - Временная зона.
                                            </li>
                                            <li>
                                                <span class="code">.combine(&lt;date&gt;, &lt;time&gt;)</span> - 
                                                Создает экземпляр класса в соответствии со значениями экземпляров класса date и time.
                                            </li>
                                            <li>
                                                <span class="code">.fromordinal(<Количесвто дней с 1 года>)</span> -
                                                Возвращает дату, соответсвующую количесвту дней, прошедших с 1 года.
                                            </li>
                                            <li>
                                                <span class="code">.fromtimestamp(<Количество секунд>[, <Зона>])</span> -
                                                возвращает дату, соотвествующую количесвтоу секунд с начала эпохи.
                                            </li>
                                            <li>
                                                <span class="code">.now([<Зона>])</span> - 
                                                Возвращает текущую дату и время.
                                            </li>
                                            <li>
                                                <span class="code">.strptime(<стркоа с датой>, <Строка формата>)</span>
                                                 - Разбирает строку с датой в соответсвии со строкой формата.
                                            </li>
                                            <li>
                                                <span class="code">.today()</span> - Возвращает текущую дату и время.
                                            </li>
                                            <li>
                                                <span class="code">.utcfromtimestamp(<Количество секунд>)</span> - 
                                                Возвращает дату, соответствующую количесвту секунд, прошедших с начала эпохи в универсальном времени (UTC).
                                            </li>
                                            <li>
                                                <span class="code">.utcnow()</span> - 
                                                Возвращает текущее универсальное время (UTC)
                                            </li>
                                            <li>
                                                <span class="code">.ctime()</span> -
                                                Возвращает строку специального формата
                                            </li>  
                                            <li>      
                                                <span class="code">.date()</span> -
                                                Возврашает дату в формате date.
                                            </li>
                                            <li>       
                                                <span class="code">.isocalendar()</span> -
                                                Возвращает кортеж из трех элементов 
                                                (год, номер недели в году и порядковый номер дня в неделе).
                                            </li> 
                                            <li>        
                                                <span class="code">.isoformat([<Разделитель>='T'])</span> -
                                                Возвращает дату в формате ISO 8601.
                                            </li>
                                            <li>        
                                                <span class="code">.isoweekday()</span> - 
                                                Возвращает порядковый номер дня недели (начинается с 1).
                                            </li> 
                                            <li>       
                                                <span class="code">.replace([year][ , month][ , day][ , hour]
                                                <br>    [, minute][, second][, microsecond][, tzinfo])</span> - 
                                                Возвращает дату с обновленными значениями.
                                            </li>
                                            <li>       
                                                <span class="code">.strftime(<строка формата>)</span> -
                                                Возвращает отформатированную строку.
                                            </li>
                                            <li>         
                                                <span class="code">.time()</span> -
                                                Возвращает время в формате time.
                                            </li>
                                            <li>        
                                                <span class="code">.timetuple()</span> - 
                                                Возвращает дату и время в формате struct_time.
                                            </li>
                                            <li>        
                                                <span class="code">.timetz()</span> -
                                                Возвращает время в формате time с учетом временной зоны
                                            </li>
                                            <li>        
                                                <span class="code">.toordinal()</span> - 
                                                Возвращает количесвто дней с 1 года.
                                            </li>
                                            <li>        
                                                <span class="code">.utctimetuple()</span> - 
                                                Возвращает дату и время в формате struct_time 
                                                в универсальном времене.
                                            </li>
                                            <li>        
                                                <span class="code">.weekday()</span> - 
                                                Возвращает порядковый номер дня в недели (начинается с 0).
                                            </li>
                                        </ul>
                                    </li>
                                    <li>
                                        <b class="red">timedelta</b> - Описывает определенный период во времени, который находится между двумя различными моментами
                                        <br><span class="code">from datetime import timedelta</span>
                                        <ul class="m-t-m">
                                            <br><b class="">Арифметические операции:</b>
                                            <pre class="code">d1 = datetime.timedelta(days=2)<br>d2 = datetime.timedelta(days=7)<br><br>d1 + d2, d2 - d1<br># datetime.timedelta(9), datetime.timedelta(5)<br><br>d2 / d1<br># 3.5<br><br>d1 / 2, d2 / 2.5<br># datetime.timedelta(1), datetime.timedelta(2, 69120)<br><br>d2 // d1<br># 3<br><br>d1 // 2, d2 // 2<br># datetime.timedelta(1), datetime.timedelta(3, 43200)<br><br>d2 % d1<br># datetime.timedelta(1)<br><br>d1 * 2, d2 * 2<br># datetime.timedelta(4), datetime.timedelta(14)<br><br>2 * d1, 2 * d2<br># datetime.timedelta(4), datetime.timedelta(14)<br><br>d3 = -d1<br>d3, abs(d3)<br># (datetime.timedelta(-2), datetime.timedelta(2)</pre>
                                            <b class="m-t-m">Логические операции:</b>
                                            <pre class="code">d1 = datetime.timedelta(days=2)<br>d2 = datetime.timedelta(days=7)<br>d3 = datetime.timedelta(weeks=1)<br><br>d1 == d2, d2 == d3<br># (False, True)<br><br>d1 != d2, d2 != d3<br># (True, False)<br><br>d1 < d2, d2 <= d3<br># (True, True)<br><br>d1 > d2, d2 >= d3<br># (False, True)</pre>
                                            <b>Так же доступны следующие методы:</b>
                                            <li>
                                                <span class="code">.days</span> - Количество дней.
                                            </li>
                                            <li>
                                                <span class="code">.microseconds</span> -
                                                Количество микросекунд.
                                            </li>
                                            <li>
                                                <span class="code">.seconds</span> -
                                                Количесвто секунд.
                                            </li>
                                            <li>
                                                <span class="code">.total_seconds()</span> - 
                                                Возвращает результат в секундах.
                                            </li>
                                        </ul>
                                    </li>
                                    <li>
                                        <b class="red">time</b> - Включает данные о времени, полностью игнорируя сведения о дате
                                        <br><span class="code">from datetime import timed</span>
                                        <ul>
                                            <li>
                                                <span class="code">.hour</span> - Часы.
                                            </li>
                                            <li>
                                                <span class="code">.minute</span> - Минуты.
                                            </li>
                                            <li>
                                                <span class="code">.second</span> - Секунды.
                                            </li>
                                            <li>
                                                <span class="code">.microsecond</span> - Микросекунды.
                                            </li>
                                            <li>
                                                <span class="code">.tzinfo</span> - Информаиця о временной зоне.
                                            </li>
                                            <li>
                                                <span class="code">.isoformat()</span> - 
                                                Возвращает время в формате ISO 8601:
                                                <pre class="code">datetime.time(23, 12, 38, 375000).isoformat()<br># '23:12:38.375000'</pre>
                                            </li>
                                            <li>
                                                <span class="code">.replace([hour][ , minute][ , second][ , microsecond][ , tzinfo])</span> -
                                                Возвращает время с обновленными значениями.
                                            </li>
                                            <li>
                                                <span class="code">.strftime(<Строка формата>)</span> - Возвращает отформатированную строку.
                                            </li>
                                        </ul>
                                    </li>
                                    <li>
                                        <b class="red">tzinfo</b> - Представляет различные сведения о часовом поясе
                                    </li>
                                    <li>
                                        <b class="red">timezone</b> - Описывает время, руководствуясь стандартом UTC
                                    </li>
                                </ul>
                            </p>
                        </div>
                    </div>
                    <h2 id="14">14. Виртуальное окружение:</h2>
                    <div class="card">
                        <div class="text-in-card">
                            <p>
                                При разработке Python-приложений или использовании решений на Python, 
                                созданных другими разработчиками, может возникнуть ряд проблем, связанных с 
                                использованием библиотек различных версий.
                                <ul>
                                    <li>
                                        <b>Во-первых:</b> различные приложения могут использовать одну и 
                                        туже библиотеку, но при этом требуемые версии могут отличаться.
                                    </li>
                                    <li>
                                        <b>Во-вторых:</b> может возникнуть необходимость в том, чтобы запретить вносить 
                                        изменения в приложение на уровне библиотек, т.е. вы установили приложение и хотите, 
                                        чтобы оно работало независимо от того обновляются у вас библиотеки или нет. 
                                        Как вы понимаете, если оно будет использовать библиотеки из глобального хранилища 
                                        (/usr/lib/pythonXX/site-packages), то, со временем, могут возникнуть проблемы.
                                    </li>
                                    <li>
                                        <b>В-третьих:</b> у вас просто может не быть доступа к каталогу /usr/lib/pythonXX/site-packages.
                                    </li>
                                </ul>
                            </p>
                            <p>
                                Для решения данных вопросов используется подход, основанный на построении 
                                виртуальных окружений – своего рода песочниц, в рамках которых запускается 
                                приложение со своими библиотеками, обновление и изменение которых не затронет 
                                другие приложение, использующие те же библиотеки.
                            </p>
                        </div>
                        <h3><b>12.1 virtualenv.</b></h3>
                        <div class="text-in-card">
                            <p>
                                Будем рассматривать работу с virtualenv в рамках операционной системы Linux. 
                                Для Windows все будет очень похоже, за исключением моментов, связанных со спецификой 
                                этой ОС: названия и расположение каталогов, запуск скриптов оболочки и т.п.
                                <br>Virtualenv можно установить с использованием менеджера pip:
                                <span class="code">pip install virtualenv</span>
                            </p>
                            <p>
                                Виртуальное окружение создается следующей командой:
                                <br><span class="code">virtualenv PRG1</span>
                                <br>PRG1 в данном случае – это имя окружения. После выполнения данной команды, 
                                в текущем каталоге будет создан новый каталог с именем PRG1. 
                                <br>Содержимое:
                                <ul>
                                    <li>
                                        <b class="red">RPG1/bin/</b> – содержит скрипты для активации/деактивации окружения, 
                                        интерпретатор Python, используемый в рамках данного окружения, 
                                        менеджер pip и ещё несколько инструментов, обеспечивающих работу с пакетами Python. 
                                        В Windows, это каталог PRG1\Scripts
                                    </li>
                                    <li>
                                        <b class="red">PRG1/include/</b> и <b class="red">PRG1/lib/</b> – каталоги, 
                                        содержащие библиотечные файлы окружения. 
                                        Новые пакеты будут установлены в каталог PRG1/lib/pythonX.X/site-packages/.
                                    </li>
                                </ul>
                            </p>
                            <p>
                                Для активации виртуального окружения воспользуйтесь командой (для <b class="red">Linux</b>)
                                Команда <b class="red">source</b> выполняет bash-скрипт без запуска второго bash-процесса.:
                                <br><span class="code">source PRG1/bin/activate</span>
                                <br>для <b class="red">Windows</b> команда будет выглядеть так:
                                <br><span class="code">PRG1\Scripts\activate.bat</span>
                                <br>Для деактивации виртуального окружения (выхода из него), 
                                введите команду <b class="red">deactivate</b> для Linux или <b class="red">deactivate.bat</b>, 
                                если вы работаете в Windows:
                                <br><span class="code">deactivate</span>
                            </p>
                        </div>
                        <h3><b>12.2 venv.</b></h3>
                        <div class="text-in-card">
                            <p>
                                Устанавливать venv не нужно, т.к. он входит в стандартную библиотеку Python. 
                                Т.е. если вы установили себе Python, то venv у вас уже есть.
                                <br>Для создания виртуального окружения с именем PRG2 с помощью venv выполните 
                                следующую команду:
                                <br><span class="code">python -m venv PRG2</span>
                                <br>В результате будет создан каталог PRG2 со структурой похожей на ту, 
                                что была описана для virtualenv. Функциональное назначение каталогов тоже самое.
                                <br>Активация виртуального окружения в <b class="red">Linux</b> выполняется командой:
                                <br><span class="code">source PRG2/bin/activate</span>
                                <br>в <b class="red">Windows</b>:
                                <br><span class="code">PRG2\Scripts\activate.bat</span>
                                <br>Деактивация выполняется командой <b class="red">deactivate</b> (работает как в Windows, так и в Linux)
                                <br><span class="code">deactivate</span>
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        </div>
        <script src="http://code.jquery.com/jquery-1.8.3.js"></script>
        <script>
            $('.menu-btn').on('click', function(e) {
                e.preventDefault();
                $('.menu').toggleClass('menu_active');
            })
            $(".main").click(function() {
                if ($(".menu").hasClass("menu_active"))
                    $('.menu').toggleClass('menu_active');
            }) 
             
        </script>
        <script>
            var items = document.getElementsByTagName('h2');
            items = Array.prototype.slice.call(items);

            function compareAge(personA, personB) {
                return personA.id - personB.id;
            }

            items.sort(compareAge);

            console.log(items);
            for(var i = 0; i < items.length; i++) {
                var newLi = document.createElement('li');
                newLi.innerHTML = '<a href="#'+ items[i].id + '"' + '>' + items[i].innerHTML + '</a>';
              
                list.appendChild(newLi);
            }

            //Плавная прокрутка до якоря.
            $("body").on('click', '[href*="#"]', function(e){
                var fixed_offset = 100;
                $('html,body').stop().animate({ scrollTop: $(this.hash).offset().top - fixed_offset }, 1000);
                e.preventDefault();
                $('.menu').toggleClass('menu_active');
            });
        </script>
    </body>
</html>