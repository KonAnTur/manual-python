<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <title>Python</title>
        <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
        <link href="css/grid.css" rel="stylesheet">
        <link href="css/font.css" rel="stylesheet">
        <link href="css/style.css" rel="stylesheet">
    </head>

    <body>
        <div class="menu">
            <a href="#" class="menu-btn"></a>
            <nav class="menu-list">
                <ol id="list">
                </ol>                      
            </nav>
        </div>
        <div class="main">          
        <div class="container">
            <div class="row">
                <div class="col-6">
                    <div class="header-h1 header-h1-left">
                        <h1>Методичка по Python</h1>
                    </div>
                    <h2 id="1">1. Операторы:</h2>
                    <div class="card">
                        <h3 id="1.1">1.1 Арифметические операторы: <span class="code">+, -, *, /, //, %, **</span></h3>
                        <div class="text-in-card">
                            <p>В пояснении нужнаются пожалуй только операторы <b class="red">//</b> и <b class="red">%</b></p>
                            <p>
                                Целочисленное деление <b class="red">//</b> - Деление в котором 
                                возвращается только целая часть результата.
                            </p>
                            <p>
                                Примеры: 
                                <br><span class="code">12 // 5 в результате будет 2</span>
                                <br><span class="code">4 // 3 в результате будет 1</span>
                            </p>
                            <p>
                                Деление по модулю <b class="red">%</b> - Делит левый операнд на правый и возвращает остаток.
                            </p>
                            <p>
                                Примеры: 
                                <br><span class="code">7 % 2 в результате будет 1</span>
                                <br><span class="code">13.2 % 5 в результате 3.2</span>
                            </p>
                        </div>
                        <h3 id="1.2">1.2 Битовые операторы: <span class="code">&, |, ^, >>, <<, ~</span></h3> 
                        <div class="text-in-card">
                            <p>
                                Переменные типа int хранятся в двоичной системе счисления в виде 
                                последовательности бит. Биты нумеруются от 0, биты будем записывать 
                                справа налево (то есть бит с номером 0 будет записан самым правым, 
                                а самый старший бит — самым левым).
                            </p>
                            <p>
                                Для двух переменных одинакового скалярного типа определены битовые операции:
                                <br><b class="red">& битовое И (AND)</b>
                                <br><b class="red">| битовое ИЛИ (OR)</b>
                                <br><b class="red">^ битовое ИСКЛЮЧАЮЩЕЕ ИЛИ (XOR)</b>
                                <br><b class="red">~ битовое ОТРИЦАНИЕ (NOT) — унарная операция.</b>
                            </p>
                            <p>
                                Битовые операторы работают следующим образом. 
                                Берутся два операнда, и к каждой паре соответствующих бит для левого 
                                и правого операнда применяется данная операция, результатом 
                                будет переменная того же типа, каждый бит которой есть результат 
                                применения соответствующей логической операции к соответствующим 
                                битам двух операндов. 
                            </p>
                            <p>
                                Рассмотрим примеры:
                                <br><span class="code">a = 5     #0b101</span>
                                <br><span class="code">b = 6     #0b110</span>
                                <br><span class="code">c = a & b #0b100 == 4</span>
                                <br><span class="code">d = a | b #0b111 == 7</span>
                                <br><span class="code">e = a ^ b #0b11 == 3</span>
                                <br><span class="code">f =  ~ a  #0b1...11111010 == -6</span>
                            </p>
                            <p>
                                Есть еще две операции, работающие с битами: это битовые сдвиги. 
                                Их два: сдвиг влево и вправо. Оператор a >> n возвращает число, 
                                которое получается из a сдвигом всех бит на n позиций вправо, 
                                при этом самые правые n бит отбрасываются. 
                            </p>
                            <p>
                                Например:
                                <br><span class="code">a = 43      #0b101011</span>
                                <br><span class="code">b = a >> 1  #0b10101 == 21</span>
                                <br><span class="code">c = a >> 2  #0b1010 == 10</span>
                            </p>
                        </div>
                        <h3 id="1.3">
                            1.3 Операторы присваивания:
                            <br><span class="code">=, +=, -=, *=, /=, %=, //=, **=, &=, |=, ^=, >>=, <<=</span>
                        </h3>
                        <h3 id="1.4">
                            1.4 Операторы сравнения: 
                            <span class="code">==, !=, >, <, >=, <=</span>
                        </h3>
                        <div class="text-in-card">
                            <p>
                                Результатом выполнения операторов сравнения являются значения: True и False.
                            </p>
                        </div>
                        <h3 id="1.5">
                            1.5 Логические операторы: 
                            <span class="code">and, or, not</span>
                        </h3>
                        <div class="text-in-card">
                            <p>
                                Логические операторы используются для объединения операторов сравнения,
                                в операциях с логическим типом данных и в операторах ветвления.
                            </p>
                            <p>
                                <b class="red">and</b> - Логический оператор "И". Условие будет истинным если оба операнда истина.
                                <br><span class="code">first_number > 0 and second_number < 20 #True если оба True</span>
                            </p>
                            <p>Примеры:
                                <br><b class="red">True and True равно True.</b>
                                <br><b class="red">True and False равно False.</b>
                                <br><b class="red">False and True равно False.</b>
                                <br><b class="red">False and False равно False.</b>
                            </p>
                            <p>
                                <b class="red">or</b> - Логический оператор "ИЛИ". Если хотя бы один из операндов истинный, то и все выражение будет истинным.
                                <br><span class="code">first_number > 5 or second_number < 20 #True если хотябы один True</span>
                            </p>
                            <p>Примеры:
                                <br><b class="red">True or True равно True.</b>
                                <br><b class="red">True or False равно True.</b>
                                <br><b class="red">False or True равно True.</b>
                                <br><b class="red">False or False равно False.</b>
                            </p>
                            <p>
                                <b class="red">not</b> - Логический оператор "НЕ". Изменяет логическое значение операнда на противоположное.
                                <br><span class="code">not first_number == second_number #True если было False</span>
                            </p>
                            <p>Примеры:
                                <br><b class="red">not True равно False.</b>
                                <br><b class="red">not False равно True.</b>
                            </p>
                        </div>
                        <h3 id="1.6">
                            1.6 Операторы идентификации:
                            <span class="code">is, is not</span>
                        </h3>
                        <div class="text-in-card">
                            <p>Операторы идентификации сравнивают ячейки памяти двух объектов.</p>
                            <p>
                                <b class="red">is</b> - Возвращает истину, если переменные по обе стороны от точки 
                                оператора указывают на тот же объект и ложь в противном случае.
                            </p>
                            <p>
                                <b class="red">is not</b> - Возвращает ложным, если 
                                переменные по обе стороны от точки оператора указывают на тот же объект и 
                                верно в противном случае.
                            </p>
                            <p>
                                Примеры:
                                <pre class="code">a = ["apple", "banana"]<br>b = ["apple", "banana"]<br>c = a<br>a is c # Вернёт True т.к. это один и тот же объект<br>a is b # Вернёт True т.к. это разные объекты<br>a == b # Вернёт True т.к. контект объектов одинаков</pre>
                            </p>
                            <p>Последний пример показывает разницу между <span class="code">is</span> и <span class="code">==</span></p>
                        </div>
                        <h3 id="1.7">
                            1.7 Операторы членства: 
                            <span class="code">in, not in</span>
                        </h3>
                        <div class="text-in-card">
                            <p>Операторы идентификации сравнивают ячейки памяти двух объектов.</p>
                            <p>
                                <b class="red">in</b> - Истина, если он находит переменную в указанной 
                                последовательности и ложь в противном случае.
                            </p>
                            <p>
                                <b class="red">not in</b> - Истина, если он не находит переменную в указанной 
                                последовательности и ложь в противном случае.
                            </p>
                            <p>
                                Примеры:
                                <pre class="code">a = ["apple", "banana"]<br>"banana" in a #Выдаст True<br>"pineapple" not a #Выдаст True</pre>
                            </p>
                        </div>
                    </div>
                    <h2 id="3">3. Логические операторы:</h2>
                    <div class="card">
                        <h3 id="3.1"><b>3.1 Оператор ветвления:</b> <span class="code">if</span></h3>
                        <div class="text-in-card">
                            <p>
                                Оператор условного выбора ветви Python-программы. 
                                Его можно использовать для направления выполнения программы по двум различным ветвям.
                                Чтобы написать несколько условий ветвления нужно использовать конструкцию 
                                <b class="red">elif</b>, слово <b class="red">else</b> используется если условие не подходит. Синтаксис:
                                <pre class="code">number = 15<br>conclusion = ''<br><br>if number < 0:<br>    conclusion = 'Number is less than zero'<br>elif number == 0:<br>    conclusion = 'Number equals to zero'<br> elif number < 1:<br>    conclusion = 'Number is greater than zero but less than one'<br>else:<br>    conclusion = 'Number bigger than or equal to one'</pre>
                            </p>
                        </div>
                        <h3 id="3.2"><b>3.2 Цикл for (и функция range()):</b> <span class="code">for, range()</span></h3>
                        <div class="text-in-card">
                            <p>
                                Оператор Python for перебирает элементы любой последовательности 
                                (списка или строки) в том порядке, что они появляются в последовательности. 
                                А функция, <b class="red">range(x,y,z)</b> создаёт массив из чисел от x до y c шагом z 
                                (если аргумент только 1 то от 0 до этого аргумента).
                                <br>Например:
                                <pre class="code">for number in range(5):<br>    iterated_numbers.append(number)<br><br>assert iterated_numbers == [0, 1, 2, 3, 4]</pre>
                            </p>
                        </div>
                        <h3 id="3.3"><b>3.3 Цикл while:</b> <span class="code">while</span></h3>
                        <div class="text-in-card">
                            <p>
                                Цикл <b class="red">while</b> выполняется до тех пор, пока условие остается верным. 
                                <br>Например:
                                <pre class="code">number = 2<br>power = 5<br><br>result = 1<br><br>while power > 0:<br>    result *= number<br>    power -= 1</pre>
                            </p>
                        </div>
                        <h3 id="3.4"><b>3.4 Инструкция break:</b> <span class="code">break</span></h3>
                        <div class="text-in-card">
                            <p>
                                Оператор <b class="red">break</b>, выходит из внутреннего цикла «for» или «while».
                                <br>Пример:
                                <pre class="code">number_to_be_found = 42<br>number_of_iterations = 0<br><br>for number in range(100):<br>    if number == number_to_be_found:<br>        # Выходим из цикла.<br>        break<br>    else:<br>        number_of_iterations += 1
                                </pre>
                            </p>
                        </div>
                        <h3 id="3.5"><b>3.5 Оператор continue:</b> <span class="code">continue</span></h3>
                        <div class="text-in-card">
                            <p>
                                Оператор <b class="red">continue</b>, прерывает настоящую итерацию 
                                цикла и продолжает цикл со следующей итерации.
                                <br>Пример:
                                <pre class="code">for number in range(0, 10):<br>if number % 2 == 0:<br>    even_numbers.append(number)<br>    # Итерация препрывается и начинается новая<br>    continue<br>rest_of_the_numbers.append(number)</pre>
                            </p>
                        </div>
                    </div>
                    <h2 id="4">4. Функции:</h2>
                    <div class="card">
                        <h3 id="4.1"><b>4.1 Инициализация функции: <span class="code">def</span></b></h3>
                        <div class="text-in-card">
                            <p>
                                Ключевое слово <b class="red">def</b> вводит определение функции. 
                                За ним должно следовать имя функции и заключенный в скобки список формальных параметров. 
                                Операторы, которые формируют тело функции, начинаются с следующей строки 
                                и должны быть с отступом. Слово <b class="red">return</b> указывает на вывод.
                                <pre class="code">def greet(name):<br>    return 'Hello, ' + name</pre>
                            </p>
                            <p>
                                Можно вкладывать функции друг в друга:
                                <pre class="code">def greet_again(name):<br>    def get_message():<br>        return 'Hello, '<br><br>    result = get_message() + name<br>    return result</pre>
                            </p>
                            <p>
                                Вызвать функцию можно по её имени:
                                <br><span class="code">greet_again('John') == 'Hello, John'</span>
                            </p>
                        </div>
                        <h3 id="4.2"><b>4.2 Область видимости переменных: <span class="code">global, nonlocal</span></b></h3>
                        <div class="text-in-card">
                            <p>
                                У переменных в Python есть область видимости. 
                                В зависимости от места в коде, где переменная была определена, 
                                определяется и область видимости, то есть, где переменная будет доступна.
                                <br>При использовании имен переменных в программе, Python каждый раз ищет, 
                                создает или изменяет эти имена в соответствующем пространстве имен. 
                                Пространство имен, которое доступно в каждый момент, зависит от области, в которой находится код.
                            </p>
                            <p>
                                У Python есть правило <b class="red">LEGB</b>, которым он пользуется при поиске переменных.
                                <ul>
                                    <li>
                                        <b class="red">L (local)</b> - в локальной (внутри функции).
                                    </li>
                                    <li>
                                        <b class="red">E (enclosing)</b> - в локальной области объемлющих функций 
                                        (это те функции, внутри которых находится наша функция).
                                    </li>
                                    <li>
                                        <b class="red">G (global)</b> - в глобальной (в скрипте).
                                    </li>
                                    <li>
                                        <b class="red">B (built-in)</b> - в встроенной (зарезервированные значения Python).
                                    </li>
                                </ul>
                            </p>
                            <p>
                                Оператор <b class="red">global</b> объявляет переменную доступной для блока кода, следующим за оператором.
                                Её можно применять к переменным внутри функции.
                                <br><pre class="code">def my_func(a, b):<br>    global x<br>    print(x)<br>    x = 5<br>    print(x) <br> <br>x = 10<br>my_func(1, 2)<br>print(x) #10 5 5</pre>
                            </p>
                            <p>
                                С помощью <b class="red">nonlocal</b> мы можем добавлять переопределение области во внутреннюю область. 
                                <pre class="code">def counter():<br>    num = 0<br>    def incrementer():<br>        nonlocal num<br>        num += 1<br>        return num<br>    return incrementer</pre>
                            </p>
                        </div>
                        <h3 id="4.3"><b>4.3 Аргументы функции.</b></h3>
                        <div class="text-in-card">
                            <p>
                                Можно указать значение аргументов функции по умолчанию. 
                                Тогда функцию можно вызывать с меньшим количеством аргументов.
                                <br>Пример:
                                <pre class="code">def power_of(number, power=2):<br>    return number ** power<br><br>power_of(3) == 9</pre>
                            </p>
                            <p>
                                <b class="red">Аргументы</b> - ключевые слова используются при вызове функции. 
                                Благодаря ключевым аргументам, вы можете задавать произвольный 
                                (то есть не такой каким он описан, при создании функции) порядок аргументов.
                                <pre class="code">def person(name, age):<br>    print name, "is", age, "years old"<br><br> # Мы можем вызвать функцию вот так<br><br>person(age = 23, name = "John")</pre>
                            </p>
                            <p>
                                Функция также может принимать переменное количество позиционных аргументов, 
                                тогда перед именем ставится *:
                                <pre class="code">def func(*args):<br>    return args<br><br>func(1, 2, 3, 'abc') == (1, 2, 3, 'abc')</pre>
                            </p>
                            <p>
                                Как видно из примера, <b class="red">*args</b> - это кортеж из всех переданных 
                                аргументов функции, и с переменной можно работать также, как и с кортежем.
                            </p>
                            <p>
                                Функция может принимать и произвольное число именованных аргументов, 
                                тогда перед именем ставится <b class="red">**</b>:
                                <pre class="code">def func(**kwargs):<br>    return kwargs<br><br>func(a=1, b=2, c=3) == {'a': 1, 'c': 3, 'b': 2}<br>func() == {}<br>func(a='python') == {'a': 'python'}</pre>
                            </p>
                            <p>
                                В переменной <b class="red">**kwargs</b> у нас хранится словарь, с которым мы, опять-таки, 
                                можем делать все, что нам заблагорассудится.
                            </p>
                        </div>
                        <h3 id="4.4"><b>4.4 Анонимные (Лямбда) функции: <span class="code">lambda</span></b></h3>
                        <div class="text-in-card">
                            <p>
                                Анонимные функции могут содержать лишь одно выражение, 
                                но и выполняются они быстрее. Анонимные функции создаются с помощью инструкции 
                                <b class="red">lambda</b>. 
                                Кроме этого, их не обязательно присваивать переменной, 
                                как делали мы инструкцией def func():
                                <pre class="code">func = lambda x, y: x + y<br>func(1, 2) == 3<br>func('a', 'b') == 'ab'<br>(lambda x, y: x + y)(1, 2) == 3<br>(lambda x, y: x + y)('a', 'b') == 'ab'</pre>
                            </p>
                            <p>
                                lambda функции, в отличие от обычной, не требуется инструкция return, 
                                а в остальном, ведет себя точно так же:
                                <pre class="code">func = lambda *args: args<br>func(1, 2, 3, 4) == (1, 2, 3, 4)</pre>
                            </p>
                        </div>
                        <h3 id="4.5"><b>4.5 Документация функций: <span class="code">"""..."""</span></b></h3>
                        <div class="text-in-card">
                            <p>
                                Документирование кода в python - достаточно важный аспект, 
                                ведь от нее порой зависит читаемость и быстрота понимания вашего кода, 
                                как другими людьми, так и вами через полгода. Чтобы задокументировать объект 
                                нужно перед кодом этого объекта записать <b class="red">""" doc """</b>. Тогда его можно получить с
                                помощью метода <b class="red">__doc__</b>. 
                                <br>Например:
                                <pre class="code">def do_nothing():<br>    """Do nothing, but document it.<br>    No, really, it doesn't do anything.<br>    """<br>    pass<br>do_nothing.__doc__ <br>#"""Do nothing, but document it. No, really, it doesn't do anything."""</pre>
                            </p>
                        </div>
                        <h3 id="4.6"><b>4.6 Декораторы.</b></h3>
                        <div class="text-in-card">
                            <p>
                                <b class="red">Декоратор</b> — это функция, которая позволяет обернуть другую функцию для расширения 
                                её функциональности без непосредственного изменения её кода. 
                                Вот почему декораторы можно рассматривать как практику метапрограммирования, 
                                когда программы могут работать с другими программами как со своими данными. 
                            </p>
                            <p>
                                Тот факт, что всё является объектами, открывает перед нами множество возможностей. 
                                Мы можем сохранять функции в переменные, передавать их в качестве аргументов и 
                                возвращать из других функций. Можно даже определить одну функцию внутри другой. 
                                Иными словами, функции — это объекты первого класса. Мы знаем и о функциях высших порядков
                                в математике это, например, производная d/dx, которая принимает в себя функцию и 
                                возвращает функцию.
                            </p>
                            <p>
                                Посмотрим на пример декоратора:
                                <pre class="code">def decorator_function(func):<br>    def wrapper():<br>        print('Функция-обёртка!')<br>        print('Оборачиваемая функция: {}'.format(func))<br>        print('Выполняем обёрнутую функцию...')<br>        func()<br>        print('Выходим из обёртки')<br>    return wrapper</pre>
                            </p>
                            <p>
                                Теперь посмотрим на декоратор в действии:
                                <pre class="code">@decorator_function<br>def hello_world():<br>    print('Hello world!')<br><br>hello_world()<br>#Оборачиваемая функция: <function hello_world at 0x032B26A8><br>#Выполняем обёрнутую функцию...<br>#Hello world!<br>#Выходим из обёртки</pre>
                            </p>
                            <p>
                                Просто добавив <span class="code">@decorator_function</span> перед определением 
                                функции <span class="code">hello_world()</span>, мы модифицировали её поведение. 
                                Выражение с <b class="red">@</b> является всего лишь синтаксическим сахаром для 
                                <span class="code">hello_world = decorator_function(hello_world)</span>.
                                <br>Иными словами, выражение <span class="code">@decorator_function</span> вызывает 
                                <span class="code">decorator_function()</span> с <span class="code">hello_world</span> 
                                в качестве аргумента и присваивает имени <span class="code">hello_world</span> 
                                возвращаемую функцию.
                            </p>
                            <p>
                                Ещё примеры:
                                <pre class="code">def benchmark(func):<br>    import time<br>    <br>    def wrapper():<br>        start = time.time()<br>        func()<br>        end = time.time()<br>        print('[*] Время выполнения: {} секунд.'.format(end-start))<br>    return wrapper<br><br>@benchmark<br>def fetch_webpage():<br>    import requests<br>    webpage = requests.get('https://google.com')<br><br>fetch_webpage()</pre>
                            </p>
                            <p>
                                Здесь мы создаём декоратор, замеряющий время выполнения функции. 
                                Далее мы используем его на функции, которая делает GET-запрос 
                                к главной странице Google. Чтобы измерить скорость, мы сначала 
                                сохраняем время перед выполнением обёрнутой функции, выполняем её, 
                                снова сохраняем текущее время и вычитаем из него начальное.
                            </p>
                        </div>
                        <h3 id="4.7"><b>4.7 Оператор "пропуск": <span class="code">pass</span></b></h3>
                        <div class="text-in-card">
                            <p>
                                Оператор <b class="red">pass</b> ничего не делает. 
                                Он может использоваться, когда оператор 
                                требуется синтаксически, но программа не требует никаких действий 
                                (Аналог return, только ничего не делает).
                            </p>
                        </div>
                        <h3 id="4.8"><b>4.8 Генераторы: <span class="code">yield</span></b></h3>
                        <div class="text-in-card">
                            <p>
                                <b class="red">Генератор</b> - это функция, возвращающая подвид итератора, 
                                генерирующий значения.
                                <b class="red">Итератор генератора</b> — это объект, порождаемый функцией-генератором.
                                <br>Выглядят функции-генераторы также как и обычные, но содержат 
                                выражения с ключевым словом <b class="red">yield</b> для последовательного 
                                генерирования значений, 
                                которые могут быть использованы в циклах for in, либо их получения при помощи 
                                функции <b class="red">next()</b>.
                            </p>
                            <p>
                                На каждой <b class="red">yield</b> работа функции временно приостанавливается, при этом 
                                сохраняется состояние исполнения, включая локальные переменные, 
                                указатель на текущую инструкцию, внутренний стек и состояние обработки исключения. 
                                При последующем обращении к итератору генератора (при вызовах его методов) функция 
                                продолжает своё исполнение с места, на котором была приостановлена. 
                                Этим функции-генераторы отличаются от обычных функций, при вызове которых 
                                исполнение всякий раз начинается с начала.
                                <br>Если функция достигает инструкции return, либо конца 
                                (без указания упомянутой инструкции), возбуждается исключение 
                                <b class="red">StopIteration</b> и 
                                итератор исчерпывает себя.
                                <pre class="code">def my_animal_generator():<br><br>    yield 'корова'<br><br>    for animal in ['кот', 'собака', 'медведь']:<br>       yield animal<br><br>    yield 'кит'<br><br>for animal in my_animal_generator():<br>    print(animal)<br># корова кот собака медведь кит</pre>
                            </p>
                        </div>
                    </div>
                    <h2 id="7">7. Ошибки и исключения:</h2>
                    <div class="card">
                        <h3 id="7.1"><b>7.1 Оператор try: <span class="code">try, except, else, finally</span></b></h3>
                        <div class="text-in-card">
                        <p>
                            Оператор <b class="red">try</b> используется для обработки исключений. 
                            Когда возникает ошибка или исключение, как мы ее называем, 
                            Python обычно останавливается и генерирует сообщение-ошибку. 
                            Эти исключения могут быть обработаны с помощью оператора try.
                            <br>Блок <b class="red">try</b> позволяет проверить блок кода на наличие ошибок. 
                            <br>Блок <b class="red">except</b> позволяет вам обработать ошибку. 
                            <br>Блок <b class="red">else</b> позволяет выполнить код, если ошибок не было. 
                            <br>Блок <b class="red">finally</b> позволяет выполнять код независимо от результата блоков try и except.
                            <br>Например:
                            <pre class="code">message = ''<br>try:<br>    print(not_existing_variable)  # noqa: F821<br>except NameError:<br>    message += 'Something went wrong.'<br>finally:<br>    message += 'The "try except" is finished.'</pre>
                        </p>
                        </div>
                        <h3 id="7.2"><b>7.2 Создание исключений: <span class="code">raise</span></b></h3>
                        <div class="text-in-card">
                            <p>
                                Оператор <b class="red">raise</b> позволяет программисту принудительно вызвать указанное исключение.
                                Например, мы можем вызвать исключение NameError и отловить его в try:
                                <pre class="code">try:<br>    raise NameError('HiThere') <br>except NameError:<br>    exception_is_caught = True<br><br>assert exception_is_caught</pre>
                            </p>
                            <p>
                                Мы можем создавать собственные исключения с помощью классов:
                                <pre class="code">class MyCustomError(Exception):<br>"""Example of MyCustomError exception."""<br>def __init__(self, message):<br>    super().__init__(message)<br>    self.message = message<br><br>custom_exception_is_caught = False<br><br>try:<br>    raise MyCustomError('My custom message')<br>except MyCustomError:<br>    custom_exception_is_caught = True</pre>
                            </p>
                        </div>
                    </div>
                    <h2 id="9">9. Стандартные библиотеки для работы с математикой:</h2>
                    <div class="card">
                        <h3 id="9.1"><b>9.1 Библиотека Math.</b></h3>
                        <div class="text-in-card">
                            <p>
                                Модуль <b class="red">math</b> – один из наиважнейших в Python. 
                                Этот модуль предоставляет обширный функционал для работы с числами.
                                <br><span class="code">import math</span>
                                <ul>
                                    <li>
                                        <span class="code">math.ceil(X)</span> – округление до ближайшего большего числа.
                                    </li>
                                    <li>
                                        <span class="code">math.copysign(X, Y)</span> - возвращает число, имеющее модуль такой же, как и у числа X, а знак - как у числа Y.
                                    </li>
                                    <li>
                                        <span class="code">math.fabs(X)</span> - модуль X.
                                    </li>
                                    <li>
                                        <span class="code">math.factorial(X)</span> - факториал числа X.
                                    </li>
                                    <li>
                                        <span class="code">math.floor(X)</span> - округление вниз.
                                    </li>
                                    <li>
                                        <span class="code">math.fmod(X, Y)</span> - остаток от деления X на Y.
                                    </li>
                                    <li>
                                        <span class="code">math.frexp(X)</span> - возвращает мантиссу и экспоненту числа.
                                    </li>
                                    <li>
                                        <span class="code">math.ldexp(X, i)</span> - X * 2<sup>i</sup>. 
                                        Функция, обратная функции math.frexp().
                                    </li>
                                    <li>
                                        <span class="code">math.fsum(последовательность)</span> - сумма всех членов последовательности. 
                                        Эквивалент встроенной функции sum(), но math.fsum() более точна для чисел с плавающей точкой.
                                    </li>
                                    <li>
                                        <span class="code">math.isfinite(X)</span> - является ли X числом.
                                    </li>
                                    <li>
                                        <span class="code">math.isinf(X)</span> - является ли X бесконечностью.
                                    </li>
                                    <li>
                                        <span class="code">math.isnan(X)</span> - является ли X NaN (Not a Number - не число).
                                    </li>
                                    <li>
                                        <span class="code">math.modf(X)</span> - возвращает дробную и целую часть числа X. Оба числа имеют тот же знак, что и X.
                                    </li>
                                    <li>
                                        <span class="code">math.trunc(X)</span> - усекает значение X до целого.
                                    </li>
                                    <li>
                                        <span class="code">math.exp(X)</span> - e<sup>X</sup>.
                                    </li>
                                    <li>
                                        <span class="code">math.expm1(X)</span> - e<sup>X</sup> - 1. При X → 0 точнее, чем math.exp(X)-1.
                                    </li>
                                    <li>
                                        <span class="code">math.log(X, [base])</span> - логарифм X по основанию base. Если base не указан, вычисляется натуральный логарифм.
                                    </li>
                                    <li>
                                        <span class="code">math.log1p(X)</span> - натуральный логарифм (1 + X). При X → 0 точнее, чем math.log(1+X)
                                    </li>
                                    <li>
                                        <span class="code">math.log10(X)</span> - логарифм X по основанию 10.
                                    </li>
                                    <li>
                                        <span class="code">math.log2(X)</span> - логарифм X по основанию 2.
                                    </li>
                                    <li>
                                        <span class="code">math.pow(X, Y)</span> - X<sup>Y</sup>.
                                    </li>
                                    <li>
                                        <span class="code">math.sqrt(X)</span> - квадратный корень из X.
                                    </li>
                                    <li>
                                        <span class="code">math.acos(X)</span> - арккосинус X. В радианах.
                                    </li>
                                    <li>
                                        <span class="code">math.asin(X)</span> - арксинус X. В радианах.
                                    </li>
                                    <li>
                                        <span class="code">math.atan(X)</span> - арктангенс X. В радианах.
                                    </li>
                                    <li>
                                        <span class="code">math.atan2(Y, X)</span> - арктангенс Y/X. В радианах. 
                                        С учетом четверти, в которой находится точка (X, Y).
                                    </li>
                                    <li>
                                        <span class="code">math.cos(X)</span> - косинус X (X указывается в радианах).
                                    </li>
                                    <li>
                                        <span class="code">math.sin(X)</span> - синус X (X указывается в радианах).
                                    </li>
                                    <li>
                                        <span class="code">math.tan(X)</span> - тангенс X (X указывается в радианах).
                                    </li>
                                    <li>
                                        <span class="code">math.hypot(X, Y)</span> - вычисляет гипотенузу треугольника 
                                        с катетами X и Y (math.sqrt(x * x + y * y))
                                    </li>
                                    <li>
                                        <span class="code">math.degrees(X)</span> - конвертирует радианы в градусы.
                                    </li>
                                    <li>
                                        <span class="code">math.radians(X)</span> - конвертирует градусы в радианы.
                                    </li>
                                    <li>
                                        <span class="code">math.cosh(X)</span> - вычисляет гиперболический косинус.
                                    </li>
                                    <li>
                                        <span class="code">math.sinh(X)</span> - вычисляет гиперболический синус.
                                    </li>
                                    <li>
                                        <span class="code">math.tanh(X)</span> - вычисляет гиперболический тангенс.
                                    </li>
                                    <li>
                                        <span class="code">math.acosh(X)</span> - вычисляет обратный гиперболический косинус.
                                    </li>
                                    <li>
                                        <span class="code">math.asinh(X)</span> - вычисляет обратный гиперболический синус.
                                    </li>
                                    <li>
                                        <span class="code">math.atanh(X)</span> - вычисляет обратный гиперболический тангенс.
                                    </li>
                                    <li>
                                        <span class="code">math.erf(X)</span> - функция ошибок.
                                    </li>
                                    <li>
                                        <span class="code">math.erfc(X)</span> - дополнительная функция ошибок (1 - math.erf(X)).
                                    </li>
                                    <li>
                                        <span class="code">math.gamma(X)</span> - гамма-функция X.
                                    </li>
                                    <li>
                                        <span class="code">math.lgamma(X)</span> - натуральный логарифм гамма-функции X.
                                    </li>
                                    <li>
                                        <span class="code">math.pi</span> - pi = 3,1415926...
                                    </li>
                                    <li>
                                        <span class="code">math.e</span> - e = 2,718281...
                                    </li>
                                </ul>
                            </p>
                        </div>
                        <h3 id="9.2"><b>9.2 Библиотека random.</b></h3>
                        <div class="text-in-card">
                            <p>
                                Модуль <b class="red">random</b> позволяет генерировать случайные числа.
                                Python порождает случайные числа на основе формулы, так что они не на самом деле случайные, 
                                а, как говорят, псевдослучайные. Этот способ удобен для большинства приложений 
                                (кроме онлайновых казино).
                                <br><span class="code">import random</span>
                                <ul>
                                    <li>
                                        <span class="code">random.random()</span> — 
                                        возвращает псевдослучайное число от 0.0 до 1.0
                                    </li>
                                    <li>
                                        <span class="code">random.seed(<Параметр>)</span> — настраивает генератор 
                                        случайных чисел на новую последовательность. 
                                        По умолчанию используется системное время. 
                                        Если значение параметра будет одиноким, то генерируется одинокое число:
                                        <pre class="code">random.seed(20)<br>random.random()<br>0.9056396761745207<br><br>random.random()<br>0.6862541570267026<br><br>random.seed(20)<br>random.random()<br>0.9056396761745207<br><br>random.random()<br>0.7665092563626442</pre>
                                    </li>
                                    <li>
                                        <span class="code">random.uniform(<Начало>, <Конец>)</span> — возвращает 
                                        псевдослучайное вещественное число в диапазоне от <Начало> до <Конец>.
                                    </li>
                                    <li>
                                        <span class="code">random.randint(<Начало>, <Конец>)</span> — возвращает псевдослучайное целое 
                                        число в диапазоне от <Начало> до <Конец>.
                                    </li>
                                    <li>
                                        <span class="code">random.choince(<Последовательность>)</span> — возвращает 
                                        случайный элемент из любой последовательности (строки, списка, кортежа):
                                        <pre class="code">random.choice('Chewbacca') #'h'<br>random.choice([1,2,'a','b']) #2</pre>
                                    </li>
                                    <li>
                                        <span class="code">random.randrange(<Начало>, <Конец>, <Шаг>)</span> — 
                                        возвращает случайно выбранное число из последовательности.
                                    </li>
                                    <li>
                                        <span class="code">random.shuffle(<Список>)</span> — перемешивает 
                                        последовательность (изменяется сама последовательность). 
                                        Поэтому функция не работает для неизменяемых объектов.
                                    </li>
                                </ul>
                            </p>
                            <p>
                                <b>Вероятностные распределения</b>
                                <ul>
                                    <li>
                                        <span class="code">random.triangular(low, high, mode)</span> — случайное число с плавающей точкой, low ≤ N ≤ high. Mode - распределение.
                                    </li>
                                    <li>
                                        <span class="code">random.betavariate(alpha, beta)</span> — бета-распределение. alpha>0, beta>0. Возвращает от 0 до 1.
                                    </li>
                                    <li>
                                        <span class="code">random.expovariate(lambd)</span> — экспоненциальное распределение. 
                                        lambd равен 1/среднее желаемое. Lambd должен быть отличным от нуля. 
                                        Возвращаемые значения от 0 до плюс бесконечности, если lambd положительно, 
                                        и от минус бесконечности до 0, если lambd отрицательный.
                                    </li>
                                    <li>
                                        <span class="code">random.gammavariate(alpha, beta)</span> — гамма-распределение. 
                                        Условия на параметры alpha>0 и beta>0.
                                    </li>
                                    <li>
                                        <span class="code">random.gauss(значение, стандартное отклонение)</span>
                                         — распределение Гаусса.
                                    </li>
                                    <li>
                                        <span class="code">random.lognormvariate(mu, sigma)</span> — логарифм нормального распределения. 
                                        Если взять натуральный логарифм этого распределения, 
                                        то вы получите нормальное распределение со средним mu и стандартным отклонением sigma. 
                                        mu может иметь любое значение, и sigma должна быть больше нуля.
                                    </li>
                                    <li>
                                        <span class="code">random.normalvariate(mu, sigma)</span> — нормальное распределение. 
                                        mu — среднее значение, sigma — стандартное отклонение.
                                    </li>
                                    <li>
                                        <span class="code">random.vonmisesvariate(mu, kappa)</span> — mu — средний угол, выраженный в 
                                        радианах от 0 до 2π, и kappa — параметр концентрации, который должен быть 
                                        больше или равен нулю. Если каппа равна нулю, 
                                        это распределение сводится к случайному углу в диапазоне от 0 до 2π.
                                    </li>
                                    <li>
                                        <span class="code">random.paretovariate(alpha)</span> — распределение Парето.
                                    </li>
                                    <li>
                                        <span class="code">random.weibullvariate(alpha, beta)</span> — распределение Вейбулла.
                                    </li>
                                </ul>
                            </p>
                        </div>
                        <h3 id="9.2">
                            <b>
                                <a href="https://docs.python.org/3/library/statistics.html" target="_blank">
                                    9.3 Модуль statistics.
                                </a>
                            </b>
                        </h3>
                        <div class="text-in-card">
                            <p>
                                Этот модуль предоставляет функции для расчета математической статистики числовых данных.
                                <br><span class="code">import statistics</span>
                                <ul>
                                    <b>Средние показатели:</b>
                                    <br>Эти функции рассчитывают среднее или типичное значение из совокупности или выборки.
                                    <li>
                                        <span class="code">statistics.mean()</span> - Среднее арифметическое.
                                    </li>
                                    <li>
                                        <span class="code">statistics.harmonic_mean()</span> - Гармоническое среднее.
                                        <img class="formula" src="img/Harmo.svg" alt="Формула кармонического среднего."> 
                                    </li>
                                    <li>
                                        <span class="code">statistics.median()</span> - Медиана.
                                    </li>
                                    <li>
                                        <span class="code">statistics.median_low()</span> - Нижняя медиана.
                                    </li>
                                    <li>
                                        <span class="code">statistics.median_high()</span> - Верхняя медиана.
                                    </li>
                                    <li>
                                        <span class="code">statistics.mode()</span> - Наиболее распространенное значение дискретных данных.
                                    </li>
                                </ul>
                            </p>
                            <p>
                                <b>Меры распространения</b>
                                <br>Эти функции вычисляют меру того, насколько популяция или выборка имеют тенденцию 
                                отклоняться от типичных или средних значений.
                                <ul>
                                    <li>
                                        <span class="code">statistics.pstdev()</span> - Популяционное стандартное отклонение данных.
                                    </li>
                                    <li>
                                        <span class="code">statistics.pvariance()</span> - Популяционная дисперсия данных.
                                    </li>
                                    <li>
                                        <span class="code">statistics.stdev()</span> - Стандартное отклонение выборки (квадратный корень дисперсии выборки).
                                    </li>
                                    <li>
                                        <span class="code">statistics.variance()</span> - Дисперсии данных.
                                    </li>
                                </ul>
                            </p>
                        </div>
                    </div>
                    <h2 id="11">11. Библиотека glob:</h2>
                    <div class="card">
                        <div class="text-in-card">
                            <p>
                                Модуль <b class="red">glob</b> предоставляет функцию для создания списков файлов из 
                                поиска по шаблону в каталоге. glob находит все пути, совпадающие с заданным 
                                шаблоном в соответствии с правилами, используемыми оболочкой Unix. 
                                Обрабатываются символы "*" (произвольное количество символов), "?" (один символ), 
                                и диапазоны символов с помощью []. Для использования тильды "~" 
                                и переменных окружения необходимо использовать os.path.expanduser() и os.path.expandvars().
                                <br>Для поиска спецсимволов, заключайте их в квадратные скобки. 
                                Например, [?] соответствует символу "?".
                                <br><span class="code">import glob</span>
                                <ul>
                                    <li>
                                        <span class="code">glob.glob(pathname)</span> - возвращает список (возможно, пустой) путей, 
                                        соответствующих шаблону pathname. Путь может быть как абсолютным 
                                        (например, /usr/src/Python-1.5/Makefile) или относительный (как ../../Tools/*/*.gif).
                                    </li>
                                    <li>
                                        <span class="code">glob.iglob(pathname)</span> - возвращает итератор, 
                                        дающий те же значения, что и glob.glob.
                                    </li>
                                    <li>
                                        <span class="code">glob.escape(pathname)</span> - экранирует все специальные символы 
                                        для glob ("?", "*" и "["). Специальные символы в имени диска не экранируются 
                                        (так как они там не учитываются), то есть в Windows escape("//?/c:/Quo vadis?.txt") 
                                        возвращает "//?/c:/Quo vadis[?].txt".
                                    </li>
                                </ul>
                                <p>
                                    Примеры:
                                </p>
                                <pre class="code">glob.glob('./[0-9].*')<br># ['./1.gif', './2.txt']<br>glob.glob('*.gif')<br># ['1.gif', 'card.gif']<br>glob.glob('?.gif')<br># ['1.gif']</pre>
                            </p>
                        </div>
                    </div>
                    <h2 id="12">12. Регулярные выражения:</h2>
                    <div class="card">
                        <h3 id="12.1"><b>12.1 Библиотека Re.</b></h3>
                        <div class="text-in-card">
                            <p>
                                <b class="red">Регулярное выражение</b> — это последовательность символов, 
                                используемая для поиска и замены текста в строке или файле.
                                <br>Регулярные выражения используют два типа символов:
                                <ul>
                                    <li>
                                        Специальные символы: как следует из названия, у этих символов есть 
                                        специальные значения. Аналогично символу *, который как правило означает 
                                        «любой символ» (но в регулярных выражениях работает немного иначе, 
                                        о чем поговорим ниже);
                                    </li>
                                    <li>
                                        Литералы (например: a, b, 1, 2 и т. д.);
                                    </li>
                                </ul>
                            </p>
                            <p>
                                В Python для работы с регулярными выражениями есть модуль <b class="red">re</b>.
                                <br><span class="code">import re</span>
                                <ul>
                                    <li>
                                        <span class="code">re.match(pattern, string)</span> - 
                                        Этот метод ищет по заданному шаблону в начале строки. 
                                        Например, если мы вызовем метод match() на строке «AV Analytics AV» с шаблоном 
                                        «AV», то он завершится успешно. Однако если мы будем искать «Analytics», 
                                        то результат будет отрицательный. 
                                        Чтобы вывести ее содержимое, используем метод <b class="red">group()</b>. 
                                        (Мы используем «r» перед строкой шаблона, чтобы показать, что это «сырая» строка в Python).
                                        <br>Пример:
                                        <pre class="code">result = re.match(r'AV', 'AV Analytics Vidhya AV')<br>print result #<_sre.SRE_Match object at 0x0000000009BE4370><br><br>print result.group(0) #AV<br><br>result = re.match(r'Analytics', 'AV Analytics Vidhya AV')<br>print result #None</pre>
                                        <p>
                                            Также есть методы <b class="red">start()</b> и <b class="red">end()</b> для того, 
                                            чтобы узнать начальную и конечную позицию найденной строки.
                                        </p>
                                        <pre class="code">result = re.match(r'AV', 'AV Analytics Vidhya AV')<br>print result.start() #0<br>print result.end() #2</pre>
                                    </li>
                                    <li>
                                        <span class="code">re.search(pattern, string)</span> -
                                        Метод search() ищет по всей строке, но возвращает только первое найденное совпадение.
                                    </li>
                                    <li>
                                        <span class="code">re.findall(pattern, string)</span> - 
                                        Этот метод возвращает список всех найденных совпадений. 
                                        У метода findall() нет ограничений на поиск в начале или конце строки.
                                        <br>Пример:
                                        <pre class="code">result = re.findall(r'AV', 'AV Analytics Vidhya AV')<br>print result #['AV', 'AV']</pre>
                                    </li>
                                    <li>
                                        <span class="code">re.split(pattern, string, [maxsplit=0])</span> -
                                        Этот метод разделяет строку по заданному шаблону.
                                        <br>Пример:
                                        <pre class="code">result = re.split(r'y', 'Analytics')<br>print result #['Anal', 'tics']</pre>
                                        <p>
                                            Метод split() принимает также аргумент maxsplit со значением по умолчанию, 
                                            равным 0. В данном случае он разделит строку столько раз, сколько возможно, 
                                            но если указать этот аргумент, то разделение будет произведено не более 
                                            указанного количества раз.
                                        </p>
                                    </li>
                                    <li>
                                        <span class="code">re.sub(pattern, repl, string)</span> -
                                        Этот метод ищет шаблон в строке и заменяет его на указанную подстроку. 
                                        Если шаблон не найден, строка остается неизменной.
                                        <br>Пример:
                                        <pre class="code">result = re.sub(r'India', 'the World', <br>   'AV is largest Analytics community of India')<br>print result #'AV is largest Analytics community of the World'</pre>
                                    </li>
                                    <li>
                                        <span class="code">re.compile(pattern, repl, string)</span> -
                                        Мы можем собрать регулярное выражение в отдельный объект, который может быть 
                                        использован для поиска. Это также избавляет от переписывания одного и того 
                                        же выражения.
                                        <br>Пример:
                                        <pre class="code">pattern = re.compile('AV')<br>result = pattern.findall('AV Analytics Vidhya AV')<br>print result #['AV', 'AV']<br>result2 = pattern.findall('AV is largest analytics community of India')<br>print result2 #['AV']</pre>
                                    </li>
                                </ul>
                                <p><b>Специальные символы:</b></p>
                                <ul>
                                    <li>
                                        <b class="red">.</b> - Один любой символ, кроме новой строки \n.
                                    </li>
                                    <li>
                                        <b class="red">?</b> - 0 или 1 вхождение шаблона слева.
                                    </li>
                                    <li>
                                        <b class="red">+</b> - 1 и более вхождений шаблона слева.
                                    </li>
                                    <li>
                                        <b class="red">*</b> - 0 и более вхождений шаблона слева.
                                    </li>
                                    <li>
                                        <b class="red">\w</b> - Любая цифра или буква (\W — все, кроме буквы или цифры).
                                    </li>
                                    <li>
                                        <b class="red">\d</b> - Любая цифра [0-9] (\D — все, кроме цифры).
                                    </li>
                                    <li>
                                        <b class="red">\s</b> - Любой пробельный символ (\S — любой непробельный символ).
                                    </li>
                                    <li>
                                        <b class="red">\b</b> - Граница слова.
                                    </li>
                                    <li>
                                        <b class="red">[..]</b> - Один из символов в скобках ([^..] — любой символ, кроме тех, что в скобках).
                                    </li>
                                    <li>
                                        <b class="red">\</b> - Экранирование специальных символов (\. означает точку или \+ — знак «плюс»).
                                    </li>
                                    <li>
                                        <b class="red">^</b> и <b class="red">$</b> - Начало и конец строки соответственно.
                                    </li>
                                    <li>
                                        <b class="red">{n,m}</b> - От n до m вхождений ({,m} — от 0 до m).
                                    </li>
                                    <li>
                                        <b class="red">a|b</b> - Соответствует a или b.
                                    </li>
                                    <li>
                                        <b class="red">()</b> - Группирует выражение и возвращает найденный текст.
                                    </li>
                                    <li>
                                        <b class="red">\t,\n,\r</b> - Символ табуляции, новой строки и возврата каретки соответственно.
                                    </li>
                                </ul>
                            </p>
                        </div>
                    </div>
                    <h2 id="14">14. NumPy:</h2>
                    <div class="card">
                        <div class="text-in-card">
                            <p>
                                <b class="red">NumPy</b> — это библиотека языка Python, добавляющая поддержку больших многомерных массивов и матриц, 
                                вместе с большой библиотекой высокоуровневых (и очень быстрых) математических функций для операций 
                                с этими массивами.
                                <br><span class="code">import numpy as np</span>
                            </p>
                        </div>
                        <h3>14.1 Массивы и работа с ними:<span class="code">array</span>.</h3>
                        <div class="text-in-card">
                            <p>
                                Главной особенностью numpy является объект <b class="red">array</b>. Массивы схожи со списками в python, 
                                исключая тот факт, что элементы массива должны иметь одинаковый тип данных, как float и int.
                                <br><b class="red">Создание массива из списка</b>:
                                <br><span class="code">a = np.array([1, 4, 5, 8], float)</span>
                            </p>
                            <p>
                                <b class="red">Массивы могут быть и многомерными</b>:
                                <br><span class="code">a = np.array([[1, 2, 3], [4, 5, 6]], float)</span>
                            </p>
                            <p>
                                Ко всем элементам можно <b class="red">получить доступ и манипулировать</b> ими также, 
                                как вы бы это делали с обычными списками:
                                <pre class="code">a = np.array([1, 4, 5, 8], float)<br>a[:2] #array([ 1.,  4.])<br>a[3] #8.0<br>a[0] = 5 #array([ 5.,  4.,  5.,  8.])</pre>
                            </p>
                            <p>
                                <b class="red">Array slicing</b> работает с многомерными массивами аналогично, как и с одномерными, 
                                применяя каждый срез, как фильтр для установленного измерения. Используйте <b class="red">":"</b> в 
                                измерении для указывания использования всех элементов этого измерения:
                                <pre class="code">a = np.array([[1, 2, 3], [4, 5, 6]], float)<br>a[1,:] #array([ 4.,  5.,  6.])<br>a[:,2] #array([ 3.,  6.])<br>a[-1:, -2:] #array([[ 5.,  6.]])</pre>
                            </p>
                            <p>
                                <ul>
                                    <li>
                                        Метод <b class="red">.shape</b> возвращает количество строк и столбцов в матрице:
                                        <br><span class="code">[[1,2,3],[4,5,6]].shape #(2,3)</span>
                                    </li>
                                    <li>
                                        Метод <b class="red">.dtype</b> возвращает тип переменных, хранящихся в массиве:
                                        <br><span class="code">[[1,2,3],[4,5,6]].dtype #dtype('int32')</span>
                                    </li>
                                    <li>
                                        Функция <b class="red">len()</b> возвращает длину первого измерения (оси):
                                        <br><span class="code">len(np.array([[1, 2, 3], [4, 5, 6]], float)) #2</span>
                                    </li>
                                    <li>
                                        Конструкция <b class="red">in</b> используется для проверки на наличие элемента в массиве:
                                        <br><span class="code">2 in np.array([[1, 2, 3], [4, 5, 6]], float) #True</span>
                                    </li>
                                    <li>
                                        Метод <b class="red">.reshape()</b> переформировывает массив в новую размерность.
                                        метод reshape создает новый массив, а не модифицирует оригинальный:
                                        <pre class="code">a = np.array(range(10), float)<br>a = a.reshape((5, 2))<br>array([[ 0.,  1.],<br>        [ 2.,  3.],<br>        [ 4.,  5.],<br>        [ 6.,  7.],<br>        [ 8.,  9.]])</pre>
                                    </li>
                                    <li>
                                        Метод <b class="red">.copy()</b> используется для создания копии существующего массива 
                                        в памяти:
                                        <pre class="code">a = np.array([1, 2, 3], float)<br>c =  a.copy() #array([1., 2., 3.])</pre>
                                    </li>
                                    <li>
                                        С помощью метода <b class="red">.tolist()</b> списки можно тоже создавать с массивов:
                                        <pre class="code">a = np.array([1, 2, 3], float)<br>a.tolist()</pre>
                                    </li>
                                    <li>
                                        Метод <b class="red">.tostring()</b> переконвертирует массив в бинарную строку, а метод 
                                        <b class="red">np.fromstring()</b> преобразует бинарную строку обратно в массив:
                                        <pre class="code">a = array([1, 2, 3], float)<br>s = a.tostring()<br>#'\x00\x00\x00\x00\x00\x00\xf0?\x00\x00\x00\x00<br>#    \x00\x00\x00@\x00\x00\x00\x00\x00\x00\x08@'<br>np.fromstring(s) #array([ 1.,  2.,  3.])</pre>
                                    </li>
                                    <li>
                                        С помощью метода <b class="red">.fill()</b> можно заполнить массив конкретными значемниями:
                                        <pre class="code">a = array([1, 2, 3], float)<br>a.fill(0) #array([ 0.,  0.,  0.])</pre>
                                    </li>
                                    <li>
                                        Транспонирование массивов производится методом <b class="red">.transpose()</b>, при этом 
                                        создается новый массив:
                                        <pre class="code">a = np.array(range(6), float).reshape((2, 3))<br>#array([[ 0.,  1.,  2.],<br>#        [ 3.,  4.,  5.]])<br>a.transpose()<br>#array([[ 0.,  3.],<br>#        [ 1.,  4.],<br>#        [ 2.,  5.]])</pre>
                                    </li>
                                    <li>
                                        Многомерный массив можно переконвертировать в одномерный при помощи метода <b class="red">.flatten()</b>:
                                        <pre class="code">a = np.array([[1, 2, 3], [4, 5, 6]], float)<br>a.flatten() #array([ 1.,  2.,  3.,  4.,  5.,  6.])</pre>
                                    </li>
                                    <li>
                                        Два или больше массивов можно сконкатенировать при помощи метода <b class="red">.concatenate()</b>:
                                        <pre class="code">a = np.array([1,2], float)<br>b = np.array([3,4,5,6], float)<br>c = np.array([7,8,9], float)<br>np.concatenate((a, b, c))<br>#array([1., 2., 3., 4., 5., 6., 7., 8., 9.])</pre>
                                        Если массив не одномерный, можно задать ось, по которой будет происходить 
                                        соединение. По умолчанию (не задавая значения оси), соединение будет 
                                        происходить по первому измерению:
                                        <pre class="code">a = np.array([[1, 2], [3, 4]], float)<br>b = np.array([[5, 6], [7,8]], float)<br>np.concatenate((a,b))<br>#array([[ 1.,  2.],<br>#        [ 3.,  4.],<br>#        [ 5.,  6.],<br>#        [ 7.,  8.]])<br>np.concatenate((a,b), axis=0)<br>#array([[ 1.,  2.],<br>#        [ 3.,  4.],<br>#        [ 5.,  6.],<br>#        [ 7.,  8.]])<br>np.concatenate((a,b), axis=1)<br>#array([[ 1.,  2.,  5.,  6.],<br>#        [ 3.,  4.,  7.,  8.]])</pre>
                                    </li>
                                    <li>
                                        Размерность массива может быть увеличена при использовании константы <b class="red">np.newaxis</b> в квадратных скобках:
                                        <pre class="code">a = np.array([1, 2, 3], float)<br>a[:,np.newaxis]<br>#array([[ 1.],<br>#        [ 2.],<br>#        [ 3.]])<br>a[np.newaxis,:]<br>#array([[ 1.,  2.,  3.]])</pre>
                                    </li>
                                </ul>
                            </p>
                        </div>
                        <h3>14.2 Другие пути создания массивов.</h3>
                        <div class="text-in-card">
                            <p>
                                <ul>
                                    <li>
                                        Функция <b class="red">np.arange()</b> аналогична функции range, но возвращает массив:
                                        <br><span class="code">np.arange(1, 6, 2, dtype=int) #array([1, 3, 5])</span>
                                    </li>
                                    <li>
                                        Функции <b class="red">np.zeros()</b> и <b class="red">np.ones()</b> 
                                        создают новые массивы с 
                                        установленной размерностью, заполненные нулями и единицами:
                                        <pre class="code">np.ones((2,3), dtype=float)<br>#array([[ 1.,  1.,  1.],<br>#        [ 1.,  1.,  1.]])<br>np.zeros(7, dtype=int)<br>#array([0, 0, 0, 0, 0, 0, 0])</pre>
                                    </li>
                                    <li>
                                        Функции <b class="red">np.zeros_like()</b> и <b class="red">np.ones_like()</b> 
                                        могут преобразовать уже созданный массив, 
                                        заполнив его нулями и единицами соответственно:
                                        <pre class="code">a = np.array([[1, 2, 3], [4, 5, 6]], float)<br>np.zeros_like(a)<br>#array([[ 0.,  0.,  0.],<br>#       [ 0.,  0.,  0.]])<br>np.ones_like(a)<br>#array([[ 1.,  1.,  1.],<br>#       [ 1.,  1.,  1.]])</pre>
                                    </li>
                                    <li>
                                        Для создания квадратной матрицы с главной диагональю, 
                                        которая заполненная единицами, воспользуемся методом 
                                        <b class="red">np.identity()</b>:
                                        <pre class="code">np.identity(4, dtype=float)<br>#array([[ 1.,  0.,  0.,  0.],<br>#       [ 0.,  1.,  0.,  0.],<br>#       [ 0.,  0.,  1.,  0.],<br>#       [ 0.,  0.,  0.,  1.]])</pre>
                                    </li>
                                    <li>
                                        Функция <b class="red">np.eye()</b> возвращает матрицу с единичками 
                                        на к-атой диагонали:
                                        <pre class="code">np.eye(4, k=1, dtype=float)<br>#array([[ 0.,  1.,  0.,  0.],<br>#       [ 0.,  0.,  1.,  0.],<br>#       [ 0.,  0.,  0.,  1.],<br>#       [ 0.,  0.,  0.,  0.]])</pre>
                                    </li>
                                </ul>
                            </p>
                        </div>
                        <h3>14.3 Математические операции над массивами:</h3>
                        <div class="text-in-card">
                            <p>
                                Когда для массивов мы используем стандартные математические операции, 
                                должен соблюдаться принцип: элемент-элемент. Это означает, что массивы должны 
                                быть одинакового размера во время сложения, вычитания и тому подобных операций:
                                <pre class="code">a = np.array([1,2,3], float)<br>b = np.array([5,2,6], float)<br>a + b #array([6., 4., 9.])<br>a – b #array([-4., 0., -3.])<br>a * b #array([5., 4., 18.])<br>b / a #array([5., 1., 2.])<br>a % b #array([1., 0., 3.])<br>b**a #array([5., 4., 216.])</pre>
                            </p>
                            <p>    
                                Если размерность массивов не совпадает, они будут преобразованы для 
                                выполнения математических операций. Это зачастую означает, что меньший 
                                массив будет использован несколько раз для завершения операций:
                                <pre class="code">a = np.array([[1, 2], [3, 4], [5, 6]], float)<br>b = np.array([-1, 3], float)<br>a + b<br>#array([[ 0.,  5.],<br>#       [ 2.,  7.],<br>#       [ 4.,  9.]])</pre>
                            </p>
                            <p>
                                Тут, одномерный массив b был преобразован в двухмерный, который 
                                соответствует размеру массива a. По существу, b был повторен 
                                несколько раз, для каждой «строки» a.
                            </p>
                        </div>
                        <h3>
                            14.4 Стандартные математические функции, которые могут быть применены поэлементно к массивам.
                        </h3>
                        <div class="text-in-card">
                            <p>
                                <ul>
                                    <li>
                                        <b class="red">np.abs()</b> - Функция модуля применяемый поэлементно к массиву.  
                                    </li>
                                    <li>
                                        <b class="red">np.sign()</b> - Возвращающает знак каждого элемента массива.
                                    </li>
                                    <li>
                                        <b class="red">np.sqrt()</b> - Возвращает квадратный корень каждого элемента массива.
                                    </li>
                                    <li>
                                        <b class="red">np.log()</b> - Возвращает натуральный логарифм каждого элемента массива.
                                    </li>
                                    <li>
                                        <b class="red">np.log10()</b> - Возвращает десятичный логарифм каждого элемента массива.
                                    </li>
                                    <li>
                                        <b class="red">np.exp()</b> - Возвращает экспоненту в степени каждого элемента массива.
                                    </li>
                                    <li>
                                        <b class="red">np.sin()</b> - Возвращает синус каждого элемента массива.
                                    </li>
                                    <li>
                                        <b class="red">np.cos()</b> - Возвращает косинус каждого элемента массива.
                                    </li>
                                    <li>
                                        <b class="red">np.tan()</b> - возвращает тангенс каждого элемента массива.
                                    </li>
                                    <li>
                                        <b class="red">np.arcsin()</b> - Возвращает арксинус каждого элемента.
                                    </li>
                                    <li>
                                        <b class="red">np.arccos()</b> - Возвращает арккосинус каждого элемента.
                                    </li>
                                    <li>
                                        <b class="red">np.arctan()</b> - Возвращает арктангенс каждого элемента.
                                    </li>
                                    <li>
                                        <b class="red">np.sinh()</b> - Возвращает гиперболический синус каждого элемента.
                                    </li>
                                    <li>
                                        <b class="red">np.cosh()</b> - Возвращает гиперболический косинус каждого элемента.
                                    </li>
                                    <li>
                                        <b class="red">np.tanh()</b> - Возвращает гиперболический тангенс каждого элемента.
                                    </li>
                                    <li>
                                        <b class="red">np.arcsinh()</b> - Возвращает гиперболический арксинус каждого элемента.
                                    </li>
                                    <li>
                                        <b class="red">np.arccosh()</b> - Возвращает гиперболический арккосинус каждого элемента.
                                    </li>
                                    <li>
                                        <b class="red">np.arctanh()</b> - Возвращает гиперболический арктангенс каждого элемента
                                    </li>
                                    <li>
                                        Функции <b class="red">np.floor()</b>, <b class="red">np.ceil()</b>
                                         и <b class="red">np.rint()</b> возвращают нижние, 
                                        верхние или ближайшие (округлённое) значение:
                                        <pre class="code">a = np.array([1.1, 1.5, 1.9], float)<br>np.floor(a) #array([ 1.,  1.,  1.])<br>np.ceil(a) #array([ 2.,  2.,  2.])<br>np.rint(a) #array([ 1.,  2.,  2.])</pre>
                                    </li>
                                    <li>
                                        <b class="red">np.pi</b> и <b class="red">np.e</b> - числа Пи и Эйлера.
                                    </li>
                                </ul>
                                <pre class="code">a = np.array([1, 4, 9], float)<br>np.sqrt(a) #array([ 1.,  2.,  3.])</pre>
                            </p>
                        </div>
                        <h3>14.5 Перебор элементов массива.</h3>
                        <div class="text-in-card">
                            <p>
                               Для многомерных массивов итерация будет проводиться 
                               по первой оси, так, что каждый проход цикла будет возвращать «строку» массива:
                               <pre class="code">a = np.array([[1, 2], [3, 4], [5, 6]], float)<br>for x in a:<br>    print x<br>#[ 1.  2.]<br>#[ 3.  4.]<br>#[ 5.  6.]</pre>
                            </p>
                            <p>
                                Множественное присваивание также доступно при итерации:
                                <pre class="code">a = np.array([[1, 2], [3, 4], [5, 6]], float)<br>for (x, y) in a:<br>    print x * y<br>#2.0<br>#12.0<br>#30.0</pre>
                            </p>
                        </div>
                        <h3>14.6 Базовые операции над массивами.</h3>
                        <div class="text-in-card">
                            <p>
                                <ul>
                                    <li>
                                        <b class="red">sorted()</b> и <b class="red">.sort()</b> - сортировка массивов:
                                        <pre class="code">a = np.array([6, 2, 5, -1, 0], float)<br>sorted(a) #[-1.0, 0.0, 2.0, 5.0, 6.0]<br>a.sort() #array([-1.,  0.,  2.,  5.,  6.])</pre>
                                    </li>
                                    <li>
                                        <b class="red">.clip()</b> - "сокращает" значения в массиве, чтобы они 
                                        попадали в заданный диапазон:
                                        <pre class="code">a = np.array([6, 2, 5, -1, 0], float)<br>a.clip(0, 5) #array([ 5.,  2.,  5.,  0.,  0.])</pre>
                                    </li>
                                    <li>
                                        <b class="red">np.unique()</b> - Извлекает уникальные элементы:
                                        <pre class="code">a = np.array([1, 1, 4, 5, 5, 5, 7], float)<br>np.unique(a) #array([ 1.,  4.,  5.,  7.])</pre>
                                    </li>
                                    <li>
                                        <b class="red">.diagonal()</b> - диагональ для двухмерных массивов:
                                        <pre class="code">a = np.array([[1, 2], [3, 4]], float)<br>a.diagonal() #array([ 1.,  4.])</pre>
                                    </li>
                                </ul>
                            </p>
                        </div>
                        <h3>14.7 Операторы сравнения и тестирование значений.</h3>
                        <div class="text-in-card">
                            <p>
                                Булево сравнение может быть использовано для поэлементного 
                                сравнения массивов одинаковых длин. Возвращаемое значение это 
                                массив булевых True/False значений:
                                <pre class="code">a = np.array([1, 3, 0], float)<br>b = np.array([0, 3, 2], float)<br>a > b #array([ True, False, False], dtype=bool)<br>a == b #array([False,  True, False], dtype=bool)<br>a <= b #array([False,  True,  True], dtype=bool)</pre>
                            </p>
                            <p>
                                Результат сравнения может быть сохранен в массиве:
                                <span class="code">c = a > b</span>
                                <br>Массивы могут быть сравнены с одиночным значением:
                                <br><span class="code">np.array([1, 3, 0], float) > 2</span>
                                <ul>
                                    <li>
                                        Операторы any и all могут быть использованы для определения 
                                        истинны ли хотя бы один или все элементы соответственно:
                                        <pre class="code">c = np.array([ True, False, False], bool)<br>any(c) #True<br>all(c) #False</pre>
                                    </li>
                                    <li>
                                        Комбинированные булевы выражения могут быть применены к 
                                        массивам по принципу элемент — элемент используя специальные функции 
                                        <b class="red">np.logical_and()</b>, <b class="red">np.logical_or()</b> 
                                        и <b class="red">np.logical_not()</b>:
                                        <pre class="code">a = np.array([1, 3, 0], float)<br>np.logical_and(a > 0, a < 3)<br>#array([ True, False, False], dtype=bool)<br><br>b = np.array([True, False, True], bool)<br>np.logical_not(b) #array([False,  True, False], dtype=bool)<br>c = np.array([False, True, False], bool)<br>np.logical_or(b, c) #array([ True,  True,  False], dtype=bool)</pre>
                                    </li>
                                    <li>
                                        Функция <b class="red">where()</b> создает новый массив из двух других массивов одинаковых 
                                        длин используя булев фильтр для выбора межу двумя элементами. 
                                        Базовый синтаксис: 
                                        <br><span class="code">where(boolarray, truearray, falsearray)</span>:
                                        <pre class="code">a = np.array([1, 3, 0], float)<br>np.where(a != 0, 1 / a, a)<br>#array([1., 0.33333333, 0.])</pre>
                                    </li>
                                    <li>
                                        Функция <b class="red">.nonzero()</b> возвращает кортеж индексов ненулевых значений:
                                        <pre class="code">a = np.array([[0, 1], [3, 0]], float)<br>a.nonzero() #(array([0, 1]), array([1, 0]))</pre>
                                    </li>
                                    <li>
                                        Также можно проверить значения на конечность <b class="red">np.isfinite()</b> 
                                        и NaN(not a number) <b class="red">np.isnan()</b>:
                                        <pre class="code">a = np.array([1, np.NaN, np.Inf], float)<br>np.isnan(a) #array([False,  True, False], dtype=bool)<br>np.isfinite(a) #array([ True, False, False], dtype=bool)</pre>
                                    </li>
                                </ul>
                            </p>
                        </div>
                        <h3>14.8 Выбор элементов массива и манипуляция с ними.</h3>
                        <div class="text-in-card">
                            <p>
                                Мы уже видели, как и у списков, элементы массива можно получить 
                                используя операцию доступа по индексу. Однако, в отличии от списков, 
                                массивы также позволяют делать выбор элементов используя другие массивы. 
                                Это значит, что мы можем <b class="red">использовать массив для фильтрации</b> 
                                специфических подмножеств элементов других массивов. 
                                <pre class="code">a = np.array([[6, 4], [5, 9]], float)<br>a >= 6<br>#array([[ True, False],<br>#       [False,  True]], dtype=bool)<br>a[a >= 6] #array([ 6.,  9.])</pre>
                            </p>
                            <p>
                                Также мы можем записать <b class="red">массив для фильтрации в переменную</b>:
                                <pre class="code">sel = (a >= 6)<br>a[sel] #array([ 6.,  9.])</pre>
                            </p>
                            <p>
                                <b class="red">Фильтрация может быть достигнута использованием булевых выражений</b>:
                                <br><span class="code">a[np.logical_and(a > 5, a < 9)] #array([ 6.])</span>
                            </p>
                            <p>
                                <b class="red">Можно использовать целочисленные массивы.</b> В этом случае, целочисленный 
                                массив хранит индексы элементов, которые будут взяты из массива:
                                <pre class="code">a = np.array([2, 4, 6, 8], float)<br>b = np.array([0, 0, 1, 3, 2, 1], int)<br>a[b] #array([ 2.,  2.,  4.,  8.,  6.,  4.])</pre>
                            </p>
                            <p>
                                <b class="red">Для многомерных массивов, нам необходимо передать несколько одномерных 
                                целочисленных массивов в оператор доступа индексу для каждой оси</b>. 
                                Потом каждый из массивов проходит такую последовательность: 
                                первый элемент соответствует индексу строки, который является первым элементом массива b, 
                                второй элемент соответствует индексу столбца, который является 
                                первым элементом массива c и так далее.
                                <pre class="code">a = np.array([[1, 4], [9, 16]], float)<br>b = np.array([0, 0, 1, 1, 0], int)<br>c = np.array([0, 1, 1, 1, 1], int)<br>a[b,c] #array([  1.,   4.,  16.,  16.,   4.])</pre>
                            </p>
                            <p>
                                <ul>
                                    <li>
                                        Специальная функция <b class="red">.take()</b> доступна для выполнения выборки с 
                                        целочисленными массивами. Это работает также как и использования 
                                        оператора взятия по индексу:
                                        <pre class="code">a = np.array([2, 4, 6, 8], float)<br>b = np.array([0, 0, 1, 3, 2, 1], int)<br>a.take(b) #array([ 2.,  2.,  4.,  8.,  6.,  4.])</pre>
                                        <p>
                                            Функция take также предоставляет аргумент <b class="red">axis</b> (ось) 
                                            для взятия подсекции многомерного массива вдоль какой-либо оси. 
                                            <pre class="code">a = np.array([[0, 1], [2, 3]], float)<br>b = np.array([0, 0, 1], int)<br>a.take(b, axis=0)<br>#array([[ 0.,  1.],<br>#       [ 0.,  1.],<br>#       [ 2.,  3.]])<br>a.take(b, axis=1)<br>#array([[ 0.,  0.,  1.],<br>#       [ 2.,  2.,  3.]])</pre>                                           
                                        </p>
                                    </li>
                                    <li>
                                        Функция <b class="red">.put()</b>, будет брать значения из исходного массива и 
                                        записывать их на специфические индексы в другом put-массиве:
                                        <pre class="code">a = np.array([0, 1, 2, 3, 4, 5], float)<br>b = np.array([9, 8, 7], float)<br>a.put([0, 3], b) #array([ 9.,  1.,  2.,  8.,  4.,  5.])</pre>
                                    </li>
                                </ul>
                            </p>
                        </div>
                        <h3>14.9 Векторная и матричная математика.</h3>
                        <div class="text-in-card">
                            <p>
                                <ul>
                                    <li>
                                        Функция <b class="red">np.dot() возвращает скалярное произведение векторов</b>:
                                        <pre class="code">a = np.array([1, 2, 3], float)<br>b = np.array([0, 1, 1], float)<br>np.dot(a, b) #5.0</pre>
                                        <p>
                                            Функция <b class="red">np.dot() также может умножать матрицы</b>:
                                            <pre class="code">a = np.array([[0, 1], [2, 3]], float)<br>b = np.array([2, 3], float)<br>c = np.array([[1, 1], [4, 0]], float)<br>np.dot(b, a) #array([  6.,  11.])<br>np.dot(a, b) #array([  3.,  13.])<br>np.dot(a, c)<br>#array([[  4.,   0.],<br>#       [ 14.,   2.]])<br>np.dot(c, a)<br>#array([[ 2.,  4.],<br>#       [ 0.,  4.]])</pre>
                                        </p>
                                    </li>
                                    <li>
                                        <b class="red">np.outer()</b> - внешнее произведение векторов, 
                                        <b class="red">np.inner()</b> - внутренее произведение векторов,
                                        <b class="red">np.cross()</b> - перекрёстное произведение векторов.
                                        <pre class="code">a = np.array([1, 4, 0], float)<br>b = np.array([2, 2, 1], float)<br>np.outer(a, b)<br>#array([[ 2.,  2.,  1.],<br>#       [ 8.,  8.,  4.],<br>#       [ 0.,  0.,  0.]])<br>np.inner(a, b) #10.0<br>np.cross(a, b) #array([ 4., -1., -6.])</pre>
                                    </li>
                                </ul>
                            </p>
                            <p>
                                NumPy также предоставляет набор встроенных функций и методов для работы 
                                с линейной алгеброй. Это всё можно найти в под-модуле linalg.
                                <ul>
                                    <li>
                                        <b class="red">np.linalg.matrix_power(M, n)</b> - возводит матрицу M в степень n.
                                    </li>
                                    <li>
                                        <b class="red">np.linalg.cholesky(a)</b> - разложение Холецкого.
                                    </li>
                                    <li>
                                        <b class="red">np.linalg.qr(a[, mode])</b> - QR разложение.
                                    </li>
                                    <li>
                                        <b class="red">np.linalg.svd(a[, full_matrices, compute_uv])</b> - сингулярное разложение.
                                        <pre class="code">a = np.array([[1, 3,4], [5, 2, 3]], float)<br>U, s, Vh = np.linalg.svd(a)<br>U<br>#array([[-0.6113829 , -0.79133492],<br>#       [-0.79133492,  0.6113829 ]])<br>s<br>#array([ 7.46791327,  2.86884495])<br>Vh<br>#array([[-0.61169129, -0.45753324, -0.64536587],<br>#       [ 0.78971838, -0.40129005, -0.46401635],<br>#       [-0.046676 , -0.79349205,  0.60678804]])</pre>
                                    </li>
                                    <li>
                                        <b class="red">np.linalg.eig(a)</b> - собственные значения и собственные векторы.
                                        <pre class="code">vals, vecs = np.linalg.eig(a)<br>vals<br>#array([ 9.        ,  2.44948974, -2.44948974])<br>vecs<br>#array([[-0.3538921 , -0.56786837,  0.27843404],<br>#       [-0.88473024,  0.44024287, -0.89787873],<br>#       [-0.30333608,  0.69549388,  0.34101066]])</pre>
                                    </li>
                                    <li>
                                        <b class="red">np.linalg.norm(x[, ord, axis])</b> - норма вектора или оператора.
                                    </li>
                                    <li>
                                        <b class="red">np.linalg.cond(x[, p])</b> - число обусловленности.
                                    </li>
                                    <li>
                                        <b class="red">np.linalg.det(a)</b> - определитель
                                        <pre class="code">a = np.array([[4, 2, 0], [9, 3, 7], [1, 2, 1]], float)<br>#array([[ 4.,  2.,  0.],<br>#       [ 9.,  3.,  7.],<br>#       [ 1.,  2.,  1.]])<br>np.linalg.det(a) #-53.99...</pre>
                                    </li>
                                    <li>
                                        <b class="red">np.linalg.slogdet(a)</b> - знак и логарифм определителя 
                                        (для избежания переполнения, если сам определитель очень маленький).
                                    </li>
                                    <li>
                                        <b class="red">np.linalg.solve(a, b)</b> - решает систему линейных уравнений 
                                        <br>Ax = b.
                                    </li>
                                    <li>
                                        <b class="red">np.linalg.tensorsolve(a, b[, axes])</b> - решает тензорную систему линейных уравнений 
                                        <br>Ax = b.
                                    </li>
                                    <li>
                                        <b class="red">np.linalg.lstsq(a, b[, rcond])</b> - метод наименьших квадратов.
                                    </li>
                                    <li>
                                        <b class="red">np.linalg.inv(a)</b> - обратная матрица.
                                        <pre class="code">b = np.linalg.inv(a)<br>b<br>#array([[ 0.14814815,  0.07407407, -0.25925926],<br>#       [ 0.2037037 , -0.14814815,  0.51851852],<br>#       [-0.27777778,  0.11111111,  0.11111111]])<br>np.dot(a, b)<br>#array([[  1.00000000e+00,   5.55111512e-17,   2.22044605e-16],<br>#       [  0.00000000e+00,   1.00000000e+00,   5.55111512e-16],<br>#       [  1.11022302e-16,   0.00000000e+00,   1.00000000e+00]])</pre>
                                    </li>
                                </ul>
                            </p>
                        </div>
                        <h3>14.10 Математика многочленов.</h3>
                        <div class="text-in-card">
                            <p>
                                NumPy предоставляет методы для работы с полиномами.
                                <ul>
                                    <li>
                                        <b class="red">np.poly()</b> - возвращает коэффициенты полинома, который подходит под
                                        список передаваемых корней:
                                        <br><span class="code">np.poly([-1, 1, 1, 10]) #array([ 1, -11,   9,  11, -10])</span>
                                        Здесь, массив возвращает коэффициенты соответствующие уравнению:
                                        <img src="img/poli_1.svg" alt="x^4 - 11x^3 + 9x^2 + 11x - 10">
                                    </li>
                                    <li>
                                        Функция <b class="red">np.root()</b> вернет все корни многочлена 
                                        соответсвующего переданным коэффициентам:
                                        <pre class="code">np.roots([1, 4, -2, 3])<br>#array([-4.57974010+0.j,  0.28987005+0.75566815j,<br>        0.28987005-0.75566815j])</pre>
                                    </li>
                                    <li>
                                        <b class="red">np.polyint()</b> - возвращает коэффициенты 
                                        проинтегрированного полинома с передаваемыми коэффициентами.
                                        <br> Например проинтегрированный полином
                                        <img src="img/poli_2.svg" alt="x^3 + x^2 + x + 1">
                                        имеет вид <img src="img/poli_2_integr.svg" alt="x^4/4 + x^3/3 + x^2/2 + x + C">,
                                        где <img src="img/С.svg" alt="C"> обычно равно нулю.
                                        <pre class="code">np.polyint([1, 1, 1, 1])<br>#array([ 0.25, 0.33333333, 0.5, 1., 0. ])</pre>
                                    </li>
                                    <li>
                                        <b class="red">np.polyder()</b> - производная аналогичная интегрированию:
                                        <pre class="code">np.polyder([1./4., 1./3., 1./2., 1., 0.])<br>#array([ 1.,  1.,  1.,  1.])</pre>
                                    </li>
                                    <li>
                                        <b class="red">np.polyadd()</b>, <b class="red">np.polysub()</b>, 
                                        <b class="red">np.polymul()</b> и <b class="red">np.polydiv()</b> - суммирование, 
                                        вычитание, умножение и деление коэффициентов многочлена.
                                    </li>
                                    <li>
                                        <b class="red">np.polyval()</b> подставляет в многочлен заданное значение.
                                        <pre class="code">np.polyval([1, -2, 0, 2], 4) #34</pre>
                                    </li>
                                    <li>
                                        <b class="red">np.polyfit()</b> может быть использована для подбора (интерполяции) многочлена заданного 
                                        порядка к набору значений:
                                        <pre class="code">x = [1, 2, 3, 4, 5, 6, 7, 8]<br>y = [0, 2, 1, 3, 7, 10, 11, 19]<br>np.polyfit(x, y, 2) #array([ 0.375, -0.88690476, 1.05357143])</pre>
                                        Возвращаемый массив это список коэффициентов многочлена.
                                    </li>
                                </ul>
                            </p>
                        </div>
                        <h3>14.11 Статистика.</h3>
                        <div class="text-in-card">
                            <p>
                                <ul>
                                    <li>
                                        Функции <b class="red">np.sum()</b>, <b class="red">a.sum()</b> и 
                                        <b class="red">np.prod()</b>, <b class="red">a.prod()</b> суммируют 
                                        и перемножают элементы:
                                        <pre class="code">a = np.array([2, 4, 3], float)<br>a.sum() #9.0<br>a.prod() #24.0<br>np.sum(a) #9.0<br>np.prod(a) #24.0</pre>
                                    </li>
                                    <li>
                                        <b class="red">.mean()</b> - среднее арифметическое, <b class="red">.var()</b>
                                         - вариация и <b class="red">.std()</b> - девиация:
                                        <pre class="code">a = np.array([2, 1, 9], float)<br>a.mean() #4.0<br>a.var() #12.666666666666666<br>a.std() #3.5590260840104371</pre>
                                    </li>
                                    <li>
                                        <b class="red">.min()</b> - минимум и <b class="red">.max()</b>
                                         - максимум в массиве:
                                        <pre class="code">a = np.array([2, 1, 9], float)<br>a.min() #1.0<br>a.max() #9.0</pre>
                                    </li>
                                    <li>
                                        Функции <b class="red">.argmin()</b> 
                                        и <b class="red">.argmax()</b> возвращают индекс минимального 
                                        или максимального элемента:
                                        <pre class="code">a = np.array([2, 1, 9], float)<br>a.argmin() #1<br>a.argmax() #2</pre>
                                    </li>
                                </ul>
                            </p>
                            <p>
                                Для многомерных массивов каждая из функций может 
                                принять дополнительный аргумент <b class="red">axis</b> и в зависимости от 
                                его значения выполнять функции по определенной оси, помещая 
                                результаты исполнения в массив:
                                <pre class="code">a = np.array([[0, 2], [3, -1], [3, 5]], float)<br>a.mean(axis=0) #array([ 2.,  2.])<br>a.mean(axis=1) #array([ 1.,  1.,  4.])<br>a.min(axis=1) #array([ 0., -1.,  3.])<br>a.max(axis=0) #array([ 3.,  5.])</pre>
                            </p>
                            <p>
                                <ul>
                                    <li>
                                        <b class="red">np.median()</b> - медиана.
                                        <pre class="code">a = np.array([1, 4, 3, 8, 9, 2, 3], float)<br>np.median(a) #3.0</pre>
                                    </li>
                                    <li>
                                        Коэффициент корреляции для некоторых переменных, 
                                        наблюдается несколько раз и может быть найден с помощью функции
                                        <b class="red">np.corrcoef()</b> из массивов вида: 
                                        <br>[[x1, x2, ...], [y1, y2, ...], [z1, z2, ...], ...], где x, y, z это разные 
                                        квантовые наблюдаемые и номера указывают количество «наблюдений»:
                                        <pre class="code">a = np.array([[1, 2, 1, 3], [5, 3, 1, 8]], float)<br>c = np.corrcoef(a)<br>#array([[ 1., 0.72870505],<br>#        [ 0.72, 1. ]])</pre>
                                        Имеем возвращаемый массив c[i, j] 
                                        который хранит корреляционный коэффициент для i-тых и j-тых 
                                        квантовых наблюдаемых.
                                    </li>
                                    <li>
                                        <b class="red">np.cov()</b> - ковариационный момент может быть найден:
                                        <pre class="code">np.cov(a)<br>#array([[ 0.91666667,  2.08333333],<br>#        [ 2.08333333,  8.91666667]])</pre>
                                    </li>
                                </ul>
                            </p>
                        </div>
                        <h3>14.12 Случайные числа.</h3>
                        <div class="text-in-card">
                            <p>
                                Важная часть каждой симуляции это способность генерировать случайные числа. 
                                Для этого мы используем встроенный в NumPy генератор псевдослучайных 
                                чисел в под-модуле random. Числа являются псевдо случайными, в том 
                                плане что, они сгенерированы детерминистически из порождающего элемента 
                                (seed number), но рассредоточены в статистическом сходстве 
                                с случайным образом.
                                <br><b class="red">Задать порождающий элемент последовательности случайных чисел можно так:</b> 
                                <br><span class="code">np.random.seed(293423)</span>
                                <br>Seed это целое число. Каждая программа которая запускается с 
                                одинаковым seed`ом будет генерировать одинаковую последовательность чисел каждый раз.
                                <ul>
                                    <li>
                                        <b class="red">np.random.rand()</b> - Массив случайных чисел из полуинтервала [0.0, 1.0):
                                        <pre class="code">np.random.rand(5)<br>#array([ 0.40783762, 0.7550402, 0.00919317,<br>        0.01713451, 0.95299583])<br>np.random.rand(2,3)<br>#array([[ 0.50431753,  0.48272463,  0.45811345],<br>#        [ 0.18209476,  0.48631022,  0.49590404]])<br>np.random.random() #0.70110</pre>
                                    </li>
                                    <li>
                                        <b class="red">np.random.randint(min, max)</b> - генерация случайного 
                                        целочисленного числа в диапазоне [min, max):
                                        <br><span class="code">np.random.randint(5, 10) #9</span>
                                    </li>
                                    <li>
                                        <b class="red">np.random.poisson(a)</b> - Генерация из дискретного распределения Пуассона при λ = a,
                                    </li>
                                    <li>
                                        <b class="red">np.random.normal(a, b)</b> - Генерация числа из нормального распределения 
                                        (Гаусса) при среднем значении μ = a и стандартной девиации σ = b.
                                        <br><span class="code">np.random.normal(1.5, 4.0) #0.836</span>
                                        <br>Для генерации нескольких значений используем аргумент size:
                                        <pre class="code">np.random.normal(size=3)<br>#array([-1.67215088,  0.65813053, -0.70150614])</pre>
                                    </li>
                                    <li>
                                        <b class="red">np.random.shuffle()</b> - случайное распределение значений в списке:
                                        <br><pre class="code">l = range(10)<br>#[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]<br>np.random.shuffle(l)<br>#[4, 9, 5, 0, 2, 7, 6, 8, 1, 3]</pre>
                                    </li>
                                </ul>
                            </p>
                        </div>
                    </div>
                </div>

                <div class="col-6">
                    <h2 id="2">2. Типы данных:</h2>
                    <div class="card">
                        <h3 id="2.1">
                            <b>2.1 Числа (включая booleans):</b> 
                            <span class="code">int, bool, float, complex</span>
                        </h3>
                        <div class="text-in-card">
                            <p>
                                В Python есть 3 числовых типа:
                                <ul>
                                    <li><b class="red">int</b> - Integer, целые числа.
                                        <ul>
                                            <li>
                                                <b class="red">bool</b> - Boolean, логический тип данных, 
                                                принимает значения True или False, которые можно заменить на 1 и 0.
                                            </li>
                                        </ul>
                                    </li>
                                    <li><b class="red">float</b> - числа с плавающей точкой, аналог вещественных чисел.</li>
                                    <li><b class="red">complex</b> - комплексные числа.</li>
                                </ul>
                            </p>
                            <p>
                                Примеры:
                                <pre class="code">a=-177463 #int<br>q = True #bool<br>b=-35.59 #float<br>c=35e3 #== 35000 float<br>w_1=5+6j #complex<br>w_2=3-2j #complex<br>w_1*w_2==27+8j</pre>
                            </p>
                        </div>
                        <h3 id="2.2">
                            <b>2.2 Строки и их методы:</b> 
                            <span class="code">'...', "..."</span>
                        </h3>
                        <div class="text-in-card">
                            <p>
                                Помимо чисел, Python может манипулировать строками, 
                                которые могут быть определены несколькими способами. 
                                Они могут быть заключены в одинарные кавычки (<b class="red">'...'</b>) 
                                <span class="code">name_1 = 'John'</span>
                                или двойные кавычки (<b class="red">"..."</b>) 
                                <span class="code">name_2 = "John"</span>, разницы в этих 2-х определениях нет.
                            </p>
                            <p>
                                Символ <b class="red">\</b> экранирует кавычки, чтобы они тоже 
                                отображались в строке <span class="code">string_eg = 'doesn\'t'</span>. 
                                А символ <span class="code">\n</span> переносит строку на новую строчку.
                            </p>
                            <p>
                                Строки могут быть проиндексированы, причем первый символ имеет индекс 0.
                               Нет отдельного типа символов; символ - это просто строка.
                               Можно индексировать строку и с конца, но тогда начать нужно с -1. 
                               В дополнение к индексации, поддерживаются срезы, позволяющие получить набор символов из начальной строки.
                               <br>Примеры:
                               <pre class="code">word = 'Python'<br>word[0] == 'P'<br>word[5] == 'n'<br>word[-1] == 'n'<br>word[-2] == 'o'<br>word[0:2] == 'Py' # это срез.</pre>
                            </p>
                            <p>
                                Строки так же можно складывать <span class="code">'J'+'ython' == 'Jython'</span> или умножать <span class="code">3 * 'J' == 'JJJ'</span>.
                            </p>
                            <p>
                                Методы для работы со строками:
                                <ul>
                                    <li>
                                        Метод <b class="red">strip()</b> удаляет все пробелы в начале и в конце строки.
                                        <br><span class="code">strip(" Python ") == "Python"</span>
                                    </li>
                                    <li>
                                        <b class="red">len()</b> возвращает длину строки.
                                        <br><span class="code">len("Python") == 6</span>
                                    </li>
                                    <li>
                                        Метод <b class="red">lower()</b> возвращает строку в нижнем регистре.
                                        <br><span class="code">"PyThon".lower() == 'python'</span>
                                    </li>
                                    <li>
                                        Метод <b class="red">upper()</b> возвращает строку в верхнем регистре.
                                        <br><span class="code">"PyThon".upper() == 'PYTHON'</span>
                                    </li>
                                    <li>
                                        Метод <b class="red">replace()</b> заменяет строку другой строкой.
                                        <br><span class="code">"Python".replace('P', 'J') == 'Jython'</span>
                                    </li>
                                    <li>
                                        Метод <b class="red">split()</b> разбивает строку на подстроки, 
                                        если он находит экземпляры разделителя. Если разделитель не указан, 
                                        то разбивает по символам.
                                        <br><span class="code">"Hello, World".split(',') == ['Hello', ' World!']</span>
                                        <br><span class="code">"Python".split() == ['P', 'y', 't', 'h', 'o', 'n']</span>
                                    </li>
                                    <li>
                                        Метод <b class="red">capitalize()</b> преобразует первый символ в верхний регистр.
                                        <br><span class="code">'low letter at the beginning'.capitalize() == 'Low letter at the beginning'</span>
                                    </li>
                                    <li>
                                        Метод <b class="red">count()</b> возвращает количество раз, когда указанная строка встречается в начальной строке.
                                        <br><span class="code">'low letter at the beginning'.count('t') == 4</span>
                                    </li>
                                    <li>
                                        Метод <b class="red">find()</b> ищет в строке указанную подстроку и возвращает позицию, где она была найдена.
                                        <br><span class="code">'Hello, welcome to my world'.find('welcome') == 7</span>
                                    </li>
                                    <li>
                                        Метод <b class="red">title()</b> преобразует первый символ каждого слова 
                                        (наборы символов разделённые пробелом) в верхний регистр.
                                        <br><span class="code">'Welcome to my world'.title() == 'Welcome To My World'</span>
                                    </li>
                                    <li>
                                        Метод <b class="red">join()</b> объединяет элементы кортежа (передаваемого аргументом), 
                                        разделяя их строкой к которой мы этот метот и применяем.
                                        <br><span class="code">my_tuple = ('John', 'Peter', 'Vicky')</span>
                                        <br><span class="code">', '.join(my_tuple) == 'John, Peter, Vicky'</span>
                                    </li>
                                    <li>
                                        Метод <b class="red">isalpha()</b> возвращает True если все символы в строке являются буквами.
                                        <br><span class="code">'CompanyX'.isalpha() == True</span>
                                        <br><span class="code">'Company33X'.isalpha() == False</span>
                                    </li>
                                    <li>
                                        Метод <b class="red">isdecimal()</b> возвращает True если все символы в строке являются цифрами.
                                        <br><span class="code">'1234'.isdecimal() == True</span>
                                        <br><span class="code">'12fff34'.isdecimal() == False</span>
                                    </li>
                                </ul>
                            </p>
                            <p>
                                В строки можно вставлять аргументы если перед строкой поставить f :
                                <pre class="code">year = 2018<br>event = 'conference'<br>f'Results of the {year} {event}' == 'Results of the 2018 conference'</pre>
                            </p>
                            <p>
                                С помощью метода <b class="red">str()</b> в струку можно преобразовывать другие типы данных: 
                                <span class="code">str(5) == '5'</span>
                                А метод repr() делает строки так как они записаны: 
                                <pre class="code">a = 10 * 3.25<br>b = 200 * 200<br>repr((a, b, ('spam', 'eggs'))) == "(32.5, 40000, ('spam', 'eggs'))"</pre>
                            </p>
                        </div>
                        <h3 id="2.3">
                            <b>2.3 Списки и их методы:</b> 
                            <span class="code">[...]</span>
                        </h3>
                        <div class="text-in-card">
                            <p>
                                Python знает несколько составных типов данных, 
                                используемых для группировки. Наиболее универсальным является 
                                список, который определяется как набор элементов, разделенных запятыми, 
                                в квадратных скобках <span class="code">squares = [1, 4, 9, 16, 25]</span>. 
                                Список может содержать элементы разных типов, 
                                но обычно все эти элементы имеют один и тот же тип данных.
                            </p>
                            <p>
                                Списки так же как и строки индексируются и срезаются:
                                <pre class="code">squares = [1, 4, 9, 16, 25]<br>squares[0] == 1<br>squares[-3:] == [9, 16, 25]</pre>
                            </p>
                            <p>
                                Списки также поддерживают такие операции, как конкатенация (сложение, склейка) 
                                <br><span class="code">[1, 4, 9] + [36, 49, 64] == [1, 4, 9, 36, 49, 64]</span>
                            </p>
                            <p>
                                Списки в отличии от строк являются изменяемыми:
                                <pre class="code">cubes = [1, 8, 27, 65, 125]<br>cubes[3] = 64 #== [1, 8, 27, 64, 125] <br>cubes[1:2] = [1, 2] #== [1, 1, 1, 64, 125]</pre>
                            </p>
                            <p>
                                С помощью метода append() можно добавить элемент в конец списка 
                                <span class="code">[1, 8, 27, 64, 125].append(7 ** 3) == [1, 8, 27, 64, 125, 343]</span>.
                                Можно создавать вложенные (многомерные списки) <span class="code">mixed_list == [['a', 'b', 'c'], [1, 2, 3]]</span>.
                                Так же можно очистить список с помощью среза 
                                <pre class="code">letters = ['a', 'b', 'f', 'g']<br> letters[:] = [] # == []</pre> 
                            </p>
                            <p>
                                Методы для работы со списками:
                                <ul>
                                    <li>
                                        Функция <b class="red">len()</b> возвращает длину списка:
                                        <br><span class="code">len(['a', 'b', 'c', 'd']) == 4</span>
                                    </li>
                                    <li>
                                        Метод <b class="red">remove(x)</b> удаляет первый элемент со значением x:
                                        <br><span class="code">['orange', 'apple', 'pear'].remove('apple') == ['orange', 'pear']</span>
                                    </li>
                                    <li>
                                        Метод <b class="red">insert(i, x)</b> вставляет элемент x на позицию i:
                                        <br><span class="code">['apple, 'orange'].insert(0, 'grape') == ['grape', 'apple, 'orange']</span>
                                    </li>
                                    <li>
                                        Метод <b class="red">index(x, start, end)</b> возвращает позицию первого 
                                        вхождения элемента x начиная со start до end (не обязательные аргументы)
                                        <pre class="code">[1,3,8,3,7].index(3, 2) == 3 <br>[1,3,8,3,7].index(3) == 1</pre>
                                    </li>
                                    <li>
                                        Метод <b class="red">count(x)</b> возвращает количество вхождений элемента x:
                                        <br><span class="code">[3,5,7,2,4,3].count(3) == 2</span>
                                    </li>
                                    <li>
                                        Метод <b class="red">copy()</b> возвращает копию списка:
                                        <br><span class="code">a = [3,6,3,3].copy() #a == [3,6,3,3]</span>
                                    </li>
                                    <li>
                                        Метод <b class="red">reverse()</b> возвращает "перевёрнутый" список:
                                        <br><span class="code">[1,2,4,5].reverse() == [5,4,2,1]</span>
                                    </li>
                                    <li>
                                        Метод <b class="red">sort(key=None, reverse=False)</b> сортирует список 
                                        (если нужно сортировать не цифры, то лучше прочитать подробнее)
                                        <br><span class="code">[2,4,73,1,4,3].sort() == [1,2,3,4,4,73]</span>
                                    </li>
                                    <li>
                                        Метод <b class="red">pop()</b> удаляет последний элемент списка и возвращает его
                                        <pre class="code">fruits == ['banana', 'kiwi', 'apple', 'banana']<br>fruits.pop() == 'banana'<br>fruits == ['banana', 'kiwi', 'apple']</pre>
                                    </li>
                                    <li>
                                        Метод <b class="red">clear()</b> удаляет список:
                                        <br><span class="code">fruits.clear() == []</span>
                                    </li>
                                    <li>
                                        Приписка <b class="red">del</b> позволяет удалить элемент по его индексу:
                                        <pre class="code">numbers = [-1, 1, 66.25, 333, 333, 1234.5]<br>del numbers[0]<br>numbers == [1, 66.25, 333, 333, 1234.5]</pre>
                                    </li>
                                </ul>
                            </p>
                            <p>
                                Можно автоматизировать создание списков, например с помощью цикла:
                                <pre class="code">squares = []<br>for number in range(10):<br>squares.append(number ** 2)<br><br>assert squares == [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</pre>
                            </p>
                            <p>
                                С помощью лямбда функции: 
                                <br><span class="code">squares = list(map(lambda x: x ** 2, range(10)))</span>
                                <br>Или с помощью конструктора списков: 
                                <br><span class="code">combinations = [(x, y) for x in [1, 2, 3] for y in [3, 1, 4] if x != y]</span>
                                <br>Так же можно применять функции в элементам списка: 
                                <br><span class="code">abs_vector = [abs(x) for x in vector] #Применяем модуль ко всем элементам списка vector</span>
                            </p>
                        </div>
                        <h3 id="2.4">
                            <b>2.4 Кортежи:</b> 
                            <span class="code">(...)</span>
                        </h3>
                        <div class="text-in-card">
                            <p>
                                Кортеж - это коллекция, которая упорядочена и неизменна. 
                                В Python кортежи пишутся с круглые скобки.
                            </p>
                            <p>
                                Кортежи индексируются:
                                <pre class="code">fruits_tuple = ("apple", "banana", "cherry")<br>fruits_tuple[1] == "banana"</pre>
                            </p>
                            <p>
                                Кортежи могут быть вложенными или пустыми: 
                                <br><span class="code">nested_tuple == ((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))</span>
                                <br><span class="code">tuple == ()</span>
                            </p>
                            <p>
                                Фунция <b class="red">len()</b> возвращает длинну массива: <br><span class="code">len(("apple")) == 1</span>
                            </p>
                        </div>
                        <h3 id="2.5">
                            <b>2.5 Наборы и их методы:</b> 
                            <span class="code">{...}</span>
                        </h3>
                        <div class="text-in-card">
                            <p>
                                Набор - это неупорядоченная и неиндексированная коллекция (Аналог множеств). 
                                В Python наборы пишутся с помощью фигурных скобок. Наборы также поддерживают 
                                математические операции, такие как объединение, пересечение, разность и 
                                симметричная разница.
                                <br><span class="code">fruits_set = {"apple", "banana", "cherry"}</span>
                            </p>
                            <p>
                                Методы для работы с наборами:
                                <ul>
                                    <li>
                                        С помощью конструкции <b class="red">in</b> можно узнать есть ли указанный элемент в наборе:
                                        <br><span class="code">"apple" in {"apple", "banana", "cherry"} == True</span>
                                    </li>
                                    <li>
                                        С помощью функции <b class="red">len()</b> можно узнать длинну набора:
                                        <br><span class="code">len({"apple", "banana", "cherry"}) == 3</span>
                                    </li>
                                    <li>
                                        С помощью метода <b class="red">add()</b> можно добавить элемент в конец набора:
                                        <br><span class="code">{"apple", "banana", "cherry"}.add("pineapple") == {"apple", "banana", "cherry", "pineapple"}</span>
                                    </li>
                                    <li>
                                        Метод <b class="red">remove(x)</b> позволяет удали элемент x:
                                        <br><span class="code">{"apple", "banana", "cherry"}.remove("apple") == {"banana", "cherry"}</span>
                                    </li>
                                    <li>
                                        С помощью метода <b class="red">set()</b> мы можем разбить другой объект в набор, 
                                        заметим что элементы в наборе не повторяются:
                                        <br><span class="code">set('abracadabra') == {'a', 'r', 'b', 'c', 'd'}</span>
                                    </li>
                                    <li>
                                        Мы можем найти разность наборов (удаляет повторяющиеся элементы):
                                        <br><span class="code">{'a', 'r', 'b', 'c', 'd'} - {'a', 'l', 'c', 'z', 'm'} == {'r', 'b', 'd'}</span>
                                    </li>
                                    <li>
                                        Операция объединения (<b class="red">|</b>):
                                        <br><span class="code">{'a', 'r', 'b', 'c', 'd'} | {'a', 'l', 'c', 'z', 'm'} == {'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}</span>
                                    </li>
                                    <li>
                                        Операция пересечения (<b class="red">&</b>):
                                        <br><span class="code">{'a', 'r', 'b', 'c', 'd'} & {'a', 'l', 'c', 'z', 'm'} == {'a', 'c'}</span>
                                    </li>
                                    <li>
                                        Операция симметричной разности (<b class="red">^</b>):
                                        <br><span class="code">{'a', 'r', 'b', 'c', 'd'} ^ {'a', 'l', 'c', 'z', 'm'} == {'r', 'd', 'b', 'm', 'z', 'l'}</span>
                                    </li>
                                </ul>
                            </p>
                        </div>
                        <h3 id="2.6">
                            <b>2.6 Словари:</b> 
                            <span class="code">{ key:values }</span>
                        </h3>
                        <div class="text-in-card">
                            <p>
                                Словарь - это неупорядоченная, изменяемая и 
                                индексируемая коллекция. В Python словари есть написано в 
                                фигурных скобках, и они имеют ключи и значения.
                                <pre class="code">fruits_dictionary = {<br>    'cherry': 'red',<br>    'apple': 'green',<br>    'banana': 'yellow',<br>}</pre>
                            </p>
                            <p>
                                Что можно делать со словарями?
                                <ul>
                                    <li>
                                        Можно искать значение по ключу:
                                        <br><span class="code">fruits_dictionary['apple'] == 'green'</span>
                                    </li>
                                    <li>
                                        Чтобы проверить, есть ли один ключ в словаре, 
                                        используйте ключевое слово <b class="red">in</b>.
                                        <br><span class="code">'apple' in fruits_dictionary == True</span>
                                    </li>
                                    <li>
                                        Можно изменить значение в ключе:
                                        <br><span class="code">fruits_dictionary['apple'] = 'red'</span>
                                    </li>
                                    <li>
                                        Можно добавить новый ключ со значением:
                                        <br><span class="code">fruits_dictionary['pineapple'] = 'yellow'</span>
                                    </li>
                                    <li>
                                        Функция <b class="red">list()</b> возвращает множество ключей словаря:
                                        <br><span class="code">list(fruits_dictionary) == ['cherry', 'apple', 'banana', 'pineapple']</span>
                                    </li>
                                    <li>
                                        Функция <b class="red">sorted()</b> возвращает отсортированное множество ключей:
                                        <br><span class="code">sorted(fruits_dictionary) == ['apple', 'banana', 'cherry', 'pineapple']</span>
                                    </li>
                                    <li>
                                        С помощью конструкции <b class="red">del</b> можно удалить пару ключ-значение (удаляется по ключу):
                                        <br><span class="code">del fruits_dictionary['pineapple']</span>
                                    </li>
                                    <li>
                                        Можно составить словарь с помощью конструктора словарей:
                                        <br><span class="code">dictionary_via_expression = {x: x**2 for x in (2, 4, 6)}</span>
                                    </li>
                                </ul>
                            </p>
                        </div>
                        <h3 id="2.7">
                            <b>2.7 Приведение типов:</b> 
                            <span class="code">int(), float(), str()</span>
                        </h3>
                        <div class="text-in-card">
                            <p>
                                Python является объектно-ориентированным языком, 
                                и поэтому он использует классы для определения типов данных, включая его примитивные типы.
                                Поэтому приведение в python выполняется с помощью функций конструктора:
                                <ul>
                                    <li>
                                        <b class="red">int()</b> - создает целое число из целочисленного типа, 
                                        типа float (округляя к предыдущему целому числу) или строкового типа 
                                        (при условии, что строка представляет собой целое число). Примеры:
                                        <pre class="code">int(1) == 1<br>int(2.8) == 2<br>int('3') == 3</pre>
                                    </li>
                                    <li>
                                        <b class="red">float()</b> - создает число с плавающей точкой из целочисленного типа, 
                                        типа float или строкового типа данных 
                                        (При условии что строка это число с плавающей точкой или целое число). Примеры:
                                        <pre class="code">float(1) == 1.0<br>float(2.8) == 2.8<br>float("3") == 3.0<br>float("4.2") == 4.2</pre>
                                    </li>
                                    <li>
                                        <b class="red">str()</b> - создает строку из множетсва типов данных, 
                                        включая строки, целые числа и числа с плавающей точкой. Примеры:
                                        <pre class="code">str("s1") == 's1'<br>str(2) == '2'<br>str(3.0) == '3.0'</pre>
                                    </li>
                                </ul>
                            </p>
                        </div>
                    </div>
                    <h2 id="5">5. Классы:</h2>
                    <div class="card">
                        <h3 id="5.1"><b>5.1 Инициализация класса: <span class="code">class</span>.</b></h3>
                        <div class="text-in-card">
                            <p>
                                Python - это объектно-ориентированный язык программирования. 
                                Все в Python является объектом, со своими свойствами и методами. 
                                Класс это на конструктор объектов или «план» для создания объектов.
                            </p>
                            <p>
                                Создание класса в Python начинается с инструкции <b class="red">class</b>. 
                                Вот так будет выглядеть минимальный класс:
                                <pre class="code">class C:<br>    pass</pre>
                            </p>
                            <p>
                                Класс состоит из объявления (инструкция class), 
                                имени класса (нашем случае это имя C) и тела класса, которое 
                                содержит атрибуты и методы (в нашем минимальном классе есть только одна инструкция pass).
                            </p>
                            <p>
                                Для того чтобы создать объект класса необходимо воспользоваться следующим синтаксисом:
                                <br><span class="code">имя_объекта = имя_класса()</span>
                            </p>
                            <p>
                                Класс может содержать атрибуты и методы. Ниже представлен класс, 
                                содержащий атрибуты color (цвет), width (ширина), height (высота).
                                <pre class="code">class Rectangle:<br>    color = “green”<br>    width = 100<br>    height = 100</pre>
                            </p>
                            <p>
                                Доступ к атрибуту класса можно получить следующим образом:
                                <br><pre class="code">rect1 = Rectangle()<br>print(rect1.color)</pre>
                            </p>
                            <p>
                                <b class="red">Метод</b> – это функция находящаяся внутри класса, выполняющая определенную работу, 
                                которая, чаще всего, предполагает доступ к атрибутам созданного объекта. 
                                Слово <b class="red">self</b> указывает методу, с каким объектом он работает, это позволяет работать 
                                со свойствами этого объекта.
                                <pre class="code">class Rectangle:<br>    width = 100<br>    height = 100<br>    def square(self):<br>        return self.width * self.height</pre>
                            </p>
                        </div>
                        <h3 id="5.2"><b>5.2 Конструктор класса: <span class="code">__init__(self)</span>.</b></h3>
                        <div class="text-in-card">
                            <p>
                                Конструктор класса позволяет задать определенные параметры объекта при его создании. 
                                Таким образом появляется возможность создавать объекты с уже заранее заданными атрибутами. 
                                Конструктором класса является метод: <b class="red">__init__(self)</b>
                                <pre class="code">class Rectangle:<br>def __init__(self, color="green", width=100, height=100):<br>    self.color = color<br>    self.width = width<br>    self.height = height<br><br>def square(self):<br>    return self.width * self.height</pre>
                            </p>
                        </div>
                        <h3 id="5.3"><b>5.3 Наследование.</b></h3>
                        <div class="text-in-card">
                            <p>
                                В организации наследования участвуют как минимум два класса: 
                                класс родитель и класс потомок. При этом возможно множественное наследование, 
                                в этом случае у класса потомка есть несколько родителей.
                                <br>Синтаксически создание класса с указанием его родителя/ей выглядит так:
                                <br><b class="red">class имя_класса(имя_родителя1, [имя_родителя2,…, имя_родителя_n])</b>
                                <pre class="code">class Figure:<br>    def __init__(self, color):<br>        self.color = color<br><br>    def get_color(self):<br>        return self.color<br><br>class Rectangle(Figure):<br>    def __init__(self, color, width=100, height=100):<br>        super().__init__(color)<br>        self.width = width<br>        self.height = height<br><br>    def square(self):<br>        return self.width*self.height<br><br>rect1 = Rectangle("blue")<br>print(rect1.get_color())<br>print(rect1.square())<br>rect2 = Rectangle("red", 25, 70)<br>print(rect2.get_color())<br>print(rect2.square())</pre>
                            </p>
                        </div>
                        <h3 id="5.4"><b>5.4 Полиморфизм.</b></h3>
                        <div class="text-in-card">
                            <p>
                                <b class="red">Полиморфизм</b> - переопределение методов базового класса в классе наследнике. 
                                Добавим в базовый класс метод info(), который печатает сводную информацию по 
                                объекту класса Figure и переопределим этот 
                                метод в классе Rectangle, где добавим дополнительные данные и вывод.
                                <pre class="code">class Figure:<br>    def __init__(self, color):<br>        self.color = color<br><br>    def get_color(self):<br>        return self.color<br><br>    def info(self):<br>        print("Figure")<br>        print("Color: " + self.color)<br><br>class Rectangle(Figure):<br>    def __init__(self, color, width=100, height=100):<br>        super().__init__(color)<br>        self.width = width<br>        self.height = height<br><br>    def square(self):<br>        return self.width * self.height<br><br>    def info(self):<br>        print("Rectangle")<br>        print("Color: " + self.color)<br>        print("Width: " + str(self.width))<br>        print("Height: " + str(self.height))<br>        print("Square: " + str(self.square()))<br><br>fig1 = Figure("green")<br>print(fig1.info())<br>rect1 = Rectangle("red", 24, 45)<br>print(rect1.info())</pre>
                            </p>
                        </div>
                    </div>
                    <h2 id="6">6. Модули:</h2>
                    <div class="card">
                        <div class="text-in-card">
                            <p>
                                Модулем в Python называется любой файл с программой.
                                Подключить модуль можно с помощью инструкции <b class="red">import</b>. 
                                К примеру, подключим модуль os для получения текущей директории:
                                <br><span class="code">import os</span>
                                <br>Стоит отметить, что если указанный атрибут модуля не будет найден, 
                                возбудится исключение <b class="red">AtributeError</b>. А если не удастся найти модуль для 
                                импортирования, то <b class="red">ImportError</b>.
                            </p>
                            <p>
                                Если название модуля слишком длинное, или оно вам не нравится 
                                по каким-то другим причинам, то для него можно создать псевдоним, 
                                с помощью ключевого слова <b class="red">as</b>.
                                <br><span class="code">import math as m</span>
                                <br>Теперь доступ ко всем атрибутам модуля math осуществляется только 
                                с помощью переменной m, а переменной math в этой программе уже не будет 
                                (если, конечно, вы после этого не напишете import math, тогда модуль 
                                будет доступен как под именем m, так и под именем math).
                            </p>
                            <p>
                                Подключить определенные атрибуты модуля можно с помощью инструкции <b class="red">from</b>. 
                                Она имеет несколько форматов:
                                <pre class="code">from <Название модуля> import <Атрибут 1> [ as <Псевдоним 1> ], <br>    [<Атрибут 2> [ as <Псевдоним 2> ] ...]<br>from <Название модуля> import *</pre>
                            </p>
                            <p>
                                Первый формат позволяет подключить из модуля только указанные вами атрибуты. 
                                Для длинных имен также можно назначить псевдоним, 
                                указав его после ключевого слова <b class="red">as</b>.
                                <br><span class="code">from math import e, ceil as c</span>
                                <br>Второй формат инструкции from позволяет 
                                подключить все (точнее, почти все) переменные из модуля.
                            </p>
                            <p>
                                Чтобы импортировать свой модуль, 
                                нужно указать название файла-модуля, который находится в той же папке.
                                Пути поиска модулей указаны в переменной sys.path.
                                В него включены текущая директория (то есть модуль можно оставить в папке с основной программой), 
                                а также директории, в которых установлен python. Кроме того, переменную sys.path можно изменять вручную, 
                                что позволяет положить модуль в любое удобное для вас место 
                                (главное, не забыть в главной программе модифицировать sys.path).
                            </p>
                        </div>
                    </div>
                    <h2 id="8">8. Файлы:</h2>
                    <div class="card">
                        <h3 id="8.1"><b>8.1 Открытие, закрытие файла: <span class="code">open(), close()</span></b></h3>
                        <div class="text-in-card">
                            <p>
                                Перед тем как прочесть и записать что-либо в файл, его следует открыть. 
                                Чтобы открыть файл в Python используется встроенная функция 
                                <b class="red">open()</b>. При вызове, эта функция создает объект типа файл, 
                                с которым в дальнейшем можно работать.
                                <br>Синтаксис функции open() в Python.
                                <br><b class="red">my_file = open(имя_файла [, режим_доступа][, буферизация])</b>
                                <br>имя_файла: строка, содержащая имя файла с расширением. Например, "my_file.txt":
                                <ul>
                                    <li>
                                        <b class="red">имя_файла</b>: строка, содержащая имя файла с расширением. Например, "my_file.txt".
                                    </li>
                                    <li>
                                        <b class="red">режим_доступа</b>: строка, которой мы указываем для чего открывается файл: 
                                        для чтения, записи, добавления информации, и т.д. Например, "w". 
                                        По умолчанию файл открывается для чтения - "r".
                                    </li>
                                    <li>
                                        <b class="red">буферизация</b>: Целое число. Если значение аргумента указано 
                                        0 - файл открывается без буферизации, 1 с построчной буферизацией, 
                                        больше одного процесс буферизации выполняется с указанным размером буфера. 
                                        Отрицательное число - разер буфера будет равен системному.
                                    </li>
                                </ul>
                            </p>
                            <p>
                                Список режимов доступа к файлу в Python:
                                <ul>
                                    <li>
                                        <b class="red">r</b> - Открывает файл только для чтения. Указатель стоит в начале файла.
                                    </li>
                                    <li>
                                        <b class="red">rb</b> - Открывает файл для чтения в двоичном формате. Указатель стоит в начале файла.
                                    </li>
                                    <li>
                                        <b class="red">r+</b> - Открывает файл для чтения и записи. Указатель стоит в начале файла.
                                    </li>
                                    <li>
                                       <b class="red">rb+</b> - Открывает файл для чтения и записи в двоичном формате. Указатель стоит в начале файла.
                                    </li>
                                    <li>
                                        <b class="red">w</b> - Открывает файл только для записи. Указатель стоит в начале файла. 
                                        Создает файл с именем имя_файла, если такового не существует.
                                    </li>
                                    <li>
                                        <b class="red">wb</b> - Открывает файл для записи в двоичном формате. Указатель стоит в начале файла. 
                                        Создает файл с именем имя_файла, если такового не существует.
                                    </li>
                                    <li>
                                        <b class="red">w+</b> - Открывает файл для чтения и записи. Указатель стоит в начале файла. 
                                        Создает файл с именем имя_файла, если такового не существует.
                                    </li>
                                    <li>
                                        <b class="red">wb+</b> - Открывает файл для чтения и записи в двоичном формате. 
                                        Указатель стоит в начале файла. Создает файл с именем имя_файла, 
                                        если такового не существует.
                                    </li>
                                    <li>
                                        <b class="red">a</b> - Открывает файл для добавления информации в файл. 
                                        Указатель стоит в конце файла. Создает файл с именем имя_файла, если такового не существует.
                                    </li>
                                    <li>
                                        <b class="red">ab</b> - Открывает файл для добавления в двоичном формате. 
                                        Указатель стоит в конце файла. Создает файл с именем имя_файла, 
                                        если такового не существует.
                                    </li>
                                    <li>
                                        <b class="red">a+</b> - Открывает файл для добавления и чтения. Указатель стоит в конце файла. 
                                        Создает файл с именем имя_файла, если такового не существует.
                                    </li>
                                    <li>
                                        <b class="red">ab+</b> - Открывает файл для добавления и чтения в двоичном формате. 
                                        Указатель стоит в конце файла. Создает файл с именем имя_файла, 
                                        если такового не существует.
                                    </li>
                                </ul>
                            </p>
                            <p>
                                <b>Атрибуты файлового объекта в Python.</b> 
                                Как только файл был открыт и у вас появился файловый объект, 
                                вы можете получить следующую информацию о нем:
                                <ul>
                                    <li>
                                        <b class="red">file.closed</b> - Возвращает True если файл был закрыт.
                                    </li>
                                    <li>
                                        <b class="red">file.mode</b> - Возвращает режим доступа, с которым был открыт файл.
                                    </li>
                                    <li>
                                        <b class="red">file.name</b> - Возвращает имя файла.
                                    </li>
                                    <li>
                                        <b class="red">file.softspace</b> - Возвращает False если при выводе содержимого файла 
                                        следует отдельно добавлять пробел.
                                    </li>
                                </ul>
                            </p>
                            <p>
                                Метод файлового объекта <b class="red">close()</b> автоматически закрывает файл, 
                                при этом теряется любая несохраненная информация. 
                                Работать с файлом (читать, записывать) после этого нельзя.
                                Python автоматически закрывает файл если файловый объект к которому он привязан 
                                присваивается другому файлу. Однако, хорошей практикой будет 
                                вручную закрывать файл командой close().
                                <br>Пример:
                                <pre class="code">my_file = open("some.txt")<br>print("Имя файла: ", my_file.name)<br>print("Файл закрыт: ", my_file.closed)<br>my_file.close()<br>print("А теперь закрыт: ", my_file.closed)</pre>
                            </p>
                        </div>
                        <h3 id="8.2"><b>8.2 Чтение и запись файлов: <span class="code">write(), read()</span></b></h3>
                        <div class="text-in-card">
                            <p>
                                Метод <b class="red">write()</b> записывает любую строку в открытый файл. 
                                Важно помнить, что строки в Python могут содержать двоичные данные, 
                                а не только текст.
                                Метод write() не добавляет символ переноса строки ('\n') в конец файла.
                                <br>Пример:
                                <pre class="code"> my_file = open("some.txt", "w")<br>my_file.write("Мне нравится Python!\nЭто классный язык!")<br>my_file.close()</pre>
                            </p>
                            <p>
                                Метод <b class="red">read()</b> читает строку из открытого файла 
                                <span class="code">my_file.read([count])</span>.
                                <br>Необязательный параметр <b class="red">count</b> - это количество байт, которые следует 
                                прочитать из открытого файла. Этот метод читает информацию с начала файла и, 
                                если параметр count не указан, до конца файла.
                                <br>Например:
                                <pre class="code">my_file = open("some.txt")<br>my_string = my_file.read()<br>print("Было прочитано:")<br>print(my_string)<br>my_file.close()</pre>
                            </p>
                            <p>
                                После того как вы вызвали метод read() на файловом объекте, 
                                если вы повторно вызовете read(), то увидите лишь пустую строку. 
                                Это происходит потому, что после первого прочтения указатель находится в конце файла. 
                                Для того чтобы узнать позицию указателя можно использовать метод <b class="red">tell()</b>.
                                <pre class="code">my_file = open("some.txt")<br>my_file.read(10)<br>print ("Я на позиции:", my_file.tell())<br>my_file.close()</pre>
                            </p>
                            <p>
                                Чтобы перейти на нужную нам позицию, следует использовать другой метод - <b class="red">seek()</b>.
                                <br><span class="code">my_file.seek(0)</span>
                            </p>
                        </div>
                    </div>
                    <h2 id="10">10. Дата и время:</h2>
                    <div class="card">
                        <h3 id="10.1">
                            <b>
                                <a href="https://docs.python.org/3/library/datetime.html" target="_blank">
                                    10.1 Библиотека datetime.
                                </a>
                            </b>
                        </h3>
                        <div class="text-in-card">
                            <p>
                                Модуль <b class="red">datetime</b> предоставляет классы для обработки времени и даты разными способами. 
                                Поддерживается и стандартный способ представления времени, однако больший упор 
                                сделан на простоту манипулирования датой, временем и их частями.
                                <br><span class="code">import datetime</span>
                                <br><b>Модуль экспортирует следующие константы:</b>
                                <ul>
                                    <li>
                                        <span class="code">datetime.MINYEAR</span> - Наименьшее число года, допустимое в объекте date или datetime.
                                    </li>
                                    <li>
                                        <span class="code">datetime.MAXYEAR</span> - Наибольший номер года, допустимый в dateили datetimeобъекте.
                                    </li>
                                </ul>
                            </p>
                            <p>
                                <b>
                                    Модуль <span class="red">datetime</span> включает в себя несколько разных классов, каждый из которых обладает собственными 
                                    методами и свойствами, а также служит для определенных целей.
                                </b>
                                <ul>
                                    <li>
                                        <b class="red">date</b> - Представляет собой дату, полностью исключая данные о времени, на основе Григорианского календаря
                                        <br><span class="code">from datetime import data</span>
                                        <ul>
                                            <li>
                                                <span class="code">.today()</span> - Вернуть текущую местную дату. Это эквивалентно date.fromtimestamp(time.time()).
                                                <br><span class="code">date.today() # datetime.date(2017, 5, 3)</span>
                                            </li>
                                            <li>
                                                <span class="code">.yaer</span> - Возвращает год.
                                                <br><span class="code">date.today().yaer #2017</span>
                                            </li>
                                            <li>
                                                <span class="code">.month</span> - Возвращает месяц.
                                                <br><span class="code">date.today().month #5</span>
                                            </li>
                                            <li>
                                                <span class="code">.day</span> - Возвращает день.
                                                <br><span class="code">date.today().day #3</span>
                                            </li>
                                            <li>
                                                <span class="code">.fromordinal(<Количество дней с 1 года>)</span> - Возвращает дату date, 
                                                соответствующую количеству дней, прошедших с 1 года:
                                                <br><pre class="code">datetime.date.max.toordinal() # 3652059<br>datetime.date.fromordinal(3652059) # datetime.date(9999, 12, 31)<br>datetime.date.fromordinal(1) # datetime.date(1, 1, 1)</pre>
                                            </li>
                                            <li>
                                                <span class="code">.fromtimestamp(<Количество секунд>)</span> - Возвращает дату date, 
                                                соответствующую количеству секунд, прошедших с начала эпохи:
                                                <br><pre class="code">datetime.date.fromtimestamp(time.time()) <br># datetime.date(2014, 8, 24)<br>datetime.date.fromtimestamp(1233368623.0) <br># datetime.date(2009, 1, 31)</pre>
                                            </li>
                                            <li>
                                                <span class="code">.isoformat(date)</span> - Возвращает строку, дату в исо формате:
                                                <br><pre class="code">datetime.date.isoformat(datetime.date.today())<br># '2017-03-05'</pre>
                                            </li>
                                            <li>
                                                <span class="code">.ctime()</span> - Возвращает строку специального формата:
                                                <br><pre class="code">datetime.date().ctime()<br># 'Sun Jun 5 00:00:00 2011'</pre>
                                            </li>
                                            <li>
                                                <span class="code">.isocalendar()</span> - Возвращает кортеж из 3х элементов 
                                                (год, номер недели и порядковый номер дня в неделе).
                                            </li>
                                            <li>
                                                <span class="code">.isoformat()</span> - Возвращает дату в формате ГГГГ-ДД-ММ.
                                            </li>
                                            <li>
                                                <span class="code">.isoweekday()</span>- Возвращает порядковый номер дня недели 
                                                (начинается с 1).
                                            </li>
                                            <li>
                                                <span class="code">.replace([year][, month][ , day])</span> - 
                                                Возвращает дату с обновленными значемниями.
                                            </li>
                                            <li>
                                                <span class="code">.strftime(<Строка формата>)</span> - 
                                                Возвращает отформатированную строку.
                                            </li>
                                            <li>
                                                <span class="code">.timetuple()</span> - 
                                                Возвращает time.struct_time с датой и временем.
                                            </li>
                                            <li>
                                                <span class="code">.toordinal()</span> - 
                                                Возвращает количесвто дней, прошедших с 1 года.
                                            </li>
                                            <li>
                                                <span class="code">.weekday()</span> - 
                                                возвращает порядковый номер дня в недели (начинается с 0).
                                            </li>
                                        </ul>
                                    </li>
                                    <li>
                                        <b class="red">datetime</b> - Содержит информацию о времени и дате, основываясь на данных из Григорианского календаря
                                        <br><span class="code">from datetime import datetime</span>
                                        <ul>
                                            <li>
                                                <span class="code">.year</span> - Год.
                                            </li>
                                            <li>
                                                <span class="code">.month</span> - Месяц.
                                            </li>
                                            <li>
                                                <span class="code">.day</span> - День.
                                            </li>
                                            <li>
                                                <span class="code">.hour</span> - Часы.
                                            </li>
                                            <li>
                                                <span class="code">.minute</span> - Минуты.
                                            </li>
                                            <li>
                                                <span class="code">.second</span> - Секунды.
                                            </li>
                                            <li>
                                                <span class="code">.microsecond</span> - Микросекунды.
                                            </li>
                                            <li>
                                                <span class="code">.tzinfo</span> - Временная зона.
                                            </li>
                                            <li>
                                                <span class="code">.combine(&lt;date&gt;, &lt;time&gt;)</span> - 
                                                Создает экземпляр класса в соответствии со значениями экземпляров класса date и time.
                                            </li>
                                            <li>
                                                <span class="code">.fromordinal(<Количесвто дней с 1 года>)</span> -
                                                Возвращает дату, соответсвующую количесвту дней, прошедших с 1 года.
                                            </li>
                                            <li>
                                                <span class="code">.fromtimestamp(<Количество секунд>[, <Зона>])</span> -
                                                возвращает дату, соотвествующую количесвтоу секунд с начала эпохи.
                                            </li>
                                            <li>
                                                <span class="code">.now([<Зона>])</span> - 
                                                Возвращает текущую дату и время.
                                            </li>
                                            <li>
                                                <span class="code">.strptime(<стркоа с датой>, <Строка формата>)</span>
                                                 - Разбирает строку с датой в соответсвии со строкой формата.
                                            </li>
                                            <li>
                                                <span class="code">.today()</span> - Возвращает текущую дату и время.
                                            </li>
                                            <li>
                                                <span class="code">.utcfromtimestamp(<Количество секунд>)</span> - 
                                                Возвращает дату, соответствующую количесвту секунд, прошедших с начала эпохи в универсальном времени (UTC).
                                            </li>
                                            <li>
                                                <span class="code">.utcnow()</span> - 
                                                Возвращает текущее универсальное время (UTC)
                                            </li>
                                            <li>
                                                <span class="code">.ctime()</span> -
                                                Возвращает строку специального формата
                                            </li>  
                                            <li>      
                                                <span class="code">.date()</span> -
                                                Возврашает дату в формате date.
                                            </li>
                                            <li>       
                                                <span class="code">.isocalendar()</span> -
                                                Возвращает кортеж из трех элементов 
                                                (год, номер недели в году и порядковый номер дня в неделе).
                                            </li> 
                                            <li>        
                                                <span class="code">.isoformat([<Разделитель>='T'])</span> -
                                                Возвращает дату в формате ISO 8601.
                                            </li>
                                            <li>        
                                                <span class="code">.isoweekday()</span> - 
                                                Возвращает порядковый номер дня недели (начинается с 1).
                                            </li> 
                                            <li>       
                                                <span class="code">.replace([year][ , month][ , day][ , hour]
                                                <br>    [, minute][, second][, microsecond][, tzinfo])</span> - 
                                                Возвращает дату с обновленными значениями.
                                            </li>
                                            <li>       
                                                <span class="code">.strftime(<строка формата>)</span> -
                                                Возвращает отформатированную строку.
                                            </li>
                                            <li>         
                                                <span class="code">.time()</span> -
                                                Возвращает время в формате time.
                                            </li>
                                            <li>        
                                                <span class="code">.timetuple()</span> - 
                                                Возвращает дату и время в формате struct_time.
                                            </li>
                                            <li>        
                                                <span class="code">.timetz()</span> -
                                                Возвращает время в формате time с учетом временной зоны
                                            </li>
                                            <li>        
                                                <span class="code">.toordinal()</span> - 
                                                Возвращает количесвто дней с 1 года.
                                            </li>
                                            <li>        
                                                <span class="code">.utctimetuple()</span> - 
                                                Возвращает дату и время в формате struct_time 
                                                в универсальном времене.
                                            </li>
                                            <li>        
                                                <span class="code">.weekday()</span> - 
                                                Возвращает порядковый номер дня в недели (начинается с 0).
                                            </li>
                                        </ul>
                                    </li>
                                    <li>
                                        <b class="red">timedelta</b> - Описывает определенный период во времени, который находится между двумя различными моментами
                                        <br><span class="code">from datetime import timedelta</span>
                                        <ul class="m-t-m">
                                            <br><b class="">Арифметические операции:</b>
                                            <pre class="code">d1 = datetime.timedelta(days=2)<br>d2 = datetime.timedelta(days=7)<br><br>d1 + d2, d2 - d1<br># datetime.timedelta(9), datetime.timedelta(5)<br><br>d2 / d1<br># 3.5<br><br>d1 / 2, d2 / 2.5<br># datetime.timedelta(1), datetime.timedelta(2, 69120)<br><br>d2 // d1<br># 3<br><br>d1 // 2, d2 // 2<br># datetime.timedelta(1), datetime.timedelta(3, 43200)<br><br>d2 % d1<br># datetime.timedelta(1)<br><br>d1 * 2, d2 * 2<br># datetime.timedelta(4), datetime.timedelta(14)<br><br>2 * d1, 2 * d2<br># datetime.timedelta(4), datetime.timedelta(14)<br><br>d3 = -d1<br>d3, abs(d3)<br># (datetime.timedelta(-2), datetime.timedelta(2)</pre>
                                            <b class="m-t-m">Логические операции:</b>
                                            <pre class="code">d1 = datetime.timedelta(days=2)<br>d2 = datetime.timedelta(days=7)<br>d3 = datetime.timedelta(weeks=1)<br><br>d1 == d2, d2 == d3<br># (False, True)<br><br>d1 != d2, d2 != d3<br># (True, False)<br><br>d1 < d2, d2 <= d3<br># (True, True)<br><br>d1 > d2, d2 >= d3<br># (False, True)</pre>
                                            <b>Так же доступны следующие методы:</b>
                                            <li>
                                                <span class="code">.days</span> - Количество дней.
                                            </li>
                                            <li>
                                                <span class="code">.microseconds</span> -
                                                Количество микросекунд.
                                            </li>
                                            <li>
                                                <span class="code">.seconds</span> -
                                                Количесвто секунд.
                                            </li>
                                            <li>
                                                <span class="code">.total_seconds()</span> - 
                                                Возвращает результат в секундах.
                                            </li>
                                        </ul>
                                    </li>
                                    <li>
                                        <b class="red">time</b> - Включает данные о времени, полностью игнорируя сведения о дате
                                        <br><span class="code">from datetime import timed</span>
                                        <ul>
                                            <li>
                                                <span class="code">.hour</span> - Часы.
                                            </li>
                                            <li>
                                                <span class="code">.minute</span> - Минуты.
                                            </li>
                                            <li>
                                                <span class="code">.second</span> - Секунды.
                                            </li>
                                            <li>
                                                <span class="code">.microsecond</span> - Микросекунды.
                                            </li>
                                            <li>
                                                <span class="code">.tzinfo</span> - Информаиця о временной зоне.
                                            </li>
                                            <li>
                                                <span class="code">.isoformat()</span> - 
                                                Возвращает время в формате ISO 8601:
                                                <pre class="code">datetime.time(23, 12, 38, 375000).isoformat()<br># '23:12:38.375000'</pre>
                                            </li>
                                            <li>
                                                <span class="code">.replace([hour][ , minute][ , second][ , microsecond][ , tzinfo])</span> -
                                                Возвращает время с обновленными значениями.
                                            </li>
                                            <li>
                                                <span class="code">.strftime(<Строка формата>)</span> - Возвращает отформатированную строку.
                                            </li>
                                        </ul>
                                    </li>
                                    <li>
                                        <b class="red">tzinfo</b> - Представляет различные сведения о часовом поясе
                                    </li>
                                    <li>
                                        <b class="red">timezone</b> - Описывает время, руководствуясь стандартом UTC
                                    </li>
                                </ul>
                            </p>
                        </div>
                    </div>
                    <h2 id="13">13. Виртуальное окружение:</h2>
                    <div class="card">
                        <div class="text-in-card">
                            <p>
                                При разработке Python-приложений или использовании решений на Python, 
                                созданных другими разработчиками, может возникнуть ряд проблем, связанных с 
                                использованием библиотек различных версий.
                                <ul>
                                    <li>
                                        <b>Во-первых:</b> различные приложения могут использовать одну и 
                                        туже библиотеку, но при этом требуемые версии могут отличаться.
                                    </li>
                                    <li>
                                        <b>Во-вторых:</b> может возникнуть необходимость в том, чтобы запретить вносить 
                                        изменения в приложение на уровне библиотек, т.е. вы установили приложение и хотите, 
                                        чтобы оно работало независимо от того обновляются у вас библиотеки или нет. 
                                        Как вы понимаете, если оно будет использовать библиотеки из глобального хранилища 
                                        (/usr/lib/pythonXX/site-packages), то, со временем, могут возникнуть проблемы.
                                    </li>
                                    <li>
                                        <b>В-третьих:</b> у вас просто может не быть доступа к каталогу /usr/lib/pythonXX/site-packages.
                                    </li>
                                </ul>
                            </p>
                            <p>
                                Для решения данных вопросов используется подход, основанный на построении 
                                виртуальных окружений – своего рода песочниц, в рамках которых запускается 
                                приложение со своими библиотеками, обновление и изменение которых не затронет 
                                другие приложение, использующие те же библиотеки.
                            </p>
                        </div>
                        <h3 id="13.1"><b>13.1 virtualenv.</b></h3>
                        <div class="text-in-card">
                            <p>
                                Будем рассматривать работу с virtualenv в рамках операционной системы Linux. 
                                Для Windows все будет очень похоже, за исключением моментов, связанных со спецификой 
                                этой ОС: названия и расположение каталогов, запуск скриптов оболочки и т.п.
                                <br>Virtualenv можно установить с использованием менеджера pip:
                                <span class="code">pip install virtualenv</span>
                            </p>
                            <p>
                                Виртуальное окружение создается следующей командой:
                                <br><span class="code">virtualenv PRG1</span>
                                <br>PRG1 в данном случае – это имя окружения. После выполнения данной команды, 
                                в текущем каталоге будет создан новый каталог с именем PRG1. 
                                <br>Содержимое:
                                <ul>
                                    <li>
                                        <b class="red">RPG1/bin/</b> – содержит скрипты для активации/деактивации окружения, 
                                        интерпретатор Python, используемый в рамках данного окружения, 
                                        менеджер pip и ещё несколько инструментов, обеспечивающих работу с пакетами Python. 
                                        В Windows, это каталог PRG1\Scripts
                                    </li>
                                    <li>
                                        <b class="red">PRG1/include/</b> и <b class="red">PRG1/lib/</b> – каталоги, 
                                        содержащие библиотечные файлы окружения. 
                                        Новые пакеты будут установлены в каталог PRG1/lib/pythonX.X/site-packages/.
                                    </li>
                                </ul>
                            </p>
                            <p>
                                Для активации виртуального окружения воспользуйтесь командой (для <b class="red">Linux</b>)
                                Команда <b class="red">source</b> выполняет bash-скрипт без запуска второго bash-процесса.:
                                <br><span class="code">source PRG1/bin/activate</span>
                                <br>для <b class="red">Windows</b> команда будет выглядеть так:
                                <br><span class="code">PRG1\Scripts\activate.bat</span>
                                <br>Для деактивации виртуального окружения (выхода из него), 
                                введите команду <b class="red">deactivate</b> для Linux или <b class="red">deactivate.bat</b>, 
                                если вы работаете в Windows:
                                <br><span class="code">deactivate</span>
                            </p>
                        </div>
                        <h3 id="13.2"><b>13.2 venv.</b></h3>
                        <div class="text-in-card">
                            <p>
                                Устанавливать venv не нужно, т.к. он входит в стандартную библиотеку Python. 
                                Т.е. если вы установили себе Python, то venv у вас уже есть.
                                <br>Для создания виртуального окружения с именем PRG2 с помощью venv выполните 
                                следующую команду:
                                <br><span class="code">python -m venv PRG2</span>
                                <br>В результате будет создан каталог PRG2 со структурой похожей на ту, 
                                что была описана для virtualenv. Функциональное назначение каталогов тоже самое.
                                <br>Активация виртуального окружения в <b class="red">Linux</b> выполняется командой:
                                <br><span class="code">source PRG2/bin/activate</span>
                                <br>в <b class="red">Windows</b>:
                                <br><span class="code">PRG2\Scripts\activate.bat</span>
                                <br>Деактивация выполняется командой <b class="red">deactivate</b> (работает как в Windows, так и в Linux)
                                <br><span class="code">deactivate</span>
                            </p>
                        </div>
                    </div>
                    <h2 id="15">15. MatPlotLib:</h2>
                    <div class="card">
                        <h3 id="15.1">15.1 Введение:</h3>
                        <div class="text-in-card">
                            <p>
                                <b>Библиотека</b> <b class="red">matplotlib</b> - это бибилиотека двумерной графики для языка 
                                программирования python с помощью которой можно создавать высококачественные 
                                рисунки различных форматов. Matplotlib представляет собой модуль-пакет для python.
                            </p>
                            <p>
                                <span class="code">import matplotlib as mpl</span> - вызов библиотеки matplotlib.
                            </p>
                            <p>
                                Matplotlib состоит из множества модулей. Модули наполнены различными 
                                классами и функциями, которые иерархически связаны между собой:
                                <ul>
                                    <li>
                                        <b>Рисунок (Figure)</b> - Рисунок является объектом самого верхнего 
                                        уровня, на котором располагаются одна или несколько областей 
                                        рисования (Axes), элементы рисунка Artisits (заголовки, легенда и т.д.) и 
                                        основа-холст (Canvas). На рисунке может быть несколько областей 
                                        рисования Axes, но данная область рисования Axes может принадлежать 
                                        только одному рисунку Figure.
                                    </li>
                                    <li>
                                        <b>Область рисования (Axes)</b> - Область рисования является объектом 
                                        среднего уровня, который является, наверное, главным объектом работы с 
                                        графикой matplotlib в объектно-ориентированом стиле. 
                                        Это то, что ассоциируется со словом "plot", это часть изображения 
                                        с пространством данных. Каждая область рисования Axes содержит 
                                        две (или три в случае трёхмерных данных) координатных оси 
                                        (Axis объектов), которые упорядочивают отображение данных.
                                    </li>
                                    <li>
                                        <b>Координатная ось (Axis)</b> - Координатная ось являются объектом среднего уровня, 
                                        которые определяют область изменения данных, на них наносятся деления 
                                        ticks и подписи к делениям ticklabels. Расположение делений определяется 
                                        объектом Locator, а подписи делений обрабатывает объект Formatter. 
                                        Конфигурация координатных осей заключается в комбинировании различных свойств 
                                        объектов Locator и Formatter.
                                    </li>
                                    <li>
                                        <b>Элементы рисунка (Artists)</b> - Элементы рисунка Artists являются как бы красной 
                                        линией для всех иерархических уровней. Практически всё, что отображается на рисунке 
                                        является элементом рисунка (Artist), даже объекты Figure, Axes и Axis. 
                                        Элементы рисунка Artists включают в себя такие простые объекты как текст (Text), 
                                        плоская линия (Line2D), фигура (Patch) и другие.
                                    </li>
                                </ul>
                            </p>
                            <p>
                                В matplotlib работает правило "текущей области" ("current axes"), 
                                которое означает, что все графические элементы наносятся на текущую 
                                область рисования. Несмотря на то, что областей рисования может быть 
                                несколько, одна из них всегда является текущей.
                                <br><span class="code">plt.figure()</span> - создать рисунок figure. 
                            </p>
                            <p>    
                                После вызова любой графической команды, то есть функции, которая создаёт 
                                какой-либо графический объект, например, <span class="code">plt.scatter()</span> 
                                или <span class="code">plt.plot()</span>, 
                                всегда существует хотя бы одна область для рисования (по умолчанию прямоугольной 
                                формы).
                            </p>
                            <p>
                                Чтобы результат рисования, то есть текущее состояние рисунка, 
                                отразилось на экране, можно воспользоваться командой 
                                <span class="code">plt.show()</span>. 
                                Будут показаны все рисунки (figures), которые были созданы.
                            </p>
                            <button class="accordion">Пример:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">fig = plt.figure()   # Создание объекта Figure<br>plt.scatter(1.0, 1.0)   <br># scatter - метод для нанесения маркера в точке (1.0, 1.0)<br><br>plt.show()</pre>
                                </p>
                                <img src="img/matplotlib/p_1/vv_figure_1.png" class="image" height="200" alt="lorem">
                            </div>
                            <p>
                                Чтобы сохранить получившийся рисунок нужно воспользоваться методом 
                                <span class="code">plt.savefig()</span>. Он сохраняет текущую конфигурацию 
                                текущего рисунка в графический файл с некоторым расширением (png, jpeg, pdf и др.), 
                                который можно задать через параметр fmt. Поэтому её нужно вызывать 
                                в конце исходного кода, после всех вызова всех других команд. 
                                Если в python-скрипте создать несколько рисунков figure и попытаться 
                                сохранить их одной командой <span class="code">plt.savefig()</span>, то будет сохранён 
                                последний рисунок figure.
                            </p>
                            <button class="accordion">Пример:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">fig = plt.figure()<br># Добавление на рисунок круговой области рисования<br>ax = fig.add_axes([0, 0, 1, 1], polar=True)<br>plt.scatter(0.0, 0.5)<br>plt.savefig('example 142b.png', fmt='png')</pre>
                                </p>
                                <img src="img/matplotlib/p_1/figure_2.png" class="image" height="200" alt="lorem">
                            </div>
                            <p>
                                Всё пространство рисунка Figure (прямоугольной или иной формы) 
                                можно использовать для нанесения других элементов рисунка, например, 
                                контейнеров Axes, графических примитивов в виде линий, фигур, 
                                текста и так далее. В любом случае каждый рисунок можно структурно 
                                представить следующим образом:
                                <ul>
                                    <li>
                                        Область рисования <b>Axes</b>
                                        <ul>
                                            <li>Заголовок области рисования -> <span class="code">plt.title()</span>;</li>
                                        </ul>
                                    </li>
                                    <li>
                                        Ось абсцисс <b>Xaxis</b>
                                        <ul>
                                            <li>
                                                Подпись оси абсцисс <b>OX</b> -> <span class="code">plt.xlabel()</span>;
                                            </li>
                                        </ul>
                                    </li>
                                    <li>Легенда -> <span class="code">plt.legend()</span></li>
                                    <li>
                                        Цветовая шкала -> <span class="code">plt.colorbar()</span>
                                        <ul>
                                            <li>
                                                Подпись горизонтальной оси абсцисс <b>OY</b> -> 
                                                <span class="code">cbar.ax.set_xlabel()</span>;
                                            </li>
                                            <li>
                                                Подпись вертикальной оси абсцисс <b>OY</b> -> 
                                                <span class="code">cbar.ax.set_ylabel()</span>;
                                            </li>
                                        </ul>
                                    </li>
                                    <li>Деления на оси абсцисс <b>OX</b> -> <span class="code">plt.xticks()</span></li>
                                    <li>Деления на оси ординат <b>OY</b> -> <span class="code">plt.yticks()</span></li>
                                </ul>
                            </p>
                            <p>
                                Для каждого из перечисленных уровней-контейнеров 
                                есть возможность нанести заголовок (title) или подпись (label). 
                                Подписи к рисунку облегчают понимание того, в каких единицах 
                                представлены данные на графике или диаграмме.
                            </p>
                            <button class="accordion">Пример:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">import matplotlib.pyplot as plt<br>import numpy as np<br><br>lag = 0.1<br>x = np.arange(0.0, 2*np.pi+lag, lag)<br>y = np.cos(x)<br><br>fig = plt.figure()<br>plt.plot(x, y)<br><br>plt.text(np.pi-0.5, 0,  '1 Axes',<br>   fontsize=26, bbox=dict(edgecolor='w', color='w'))<br>plt.text(0.1, 0, '3 Yaxis', <br>   fontsize=18, bbox=dict(edgecolor='w', color='w'), rotation=90)<br>plt.text(5, -0.9, '2 Xaxis', <br>   fontsize=18, bbox=dict(edgecolor='w', color='w'))<br><br>plt.title('1a TITLE')<br>plt.ylabel('3a Ylabel')<br>plt.xlabel('2a Xlabel ')<br><br>plt.text(5, 0.85, '6 Xticks', <br>   fontsize=12, bbox=dict(edgecolor='w', color='w'), rotation=90)<br>plt.text(0.95, -0.55, '6 Xticks', <br>   fontsize=12, bbox=dict(edgecolor='w', color='w'), rotation=90)<br><br>plt.text(5.75, -0.5, '7 Yticks', <br>   fontsize=12, bbox=dict(edgecolor='w', color='w'))<br>plt.text(0.15, 0.475, '7 Yticks', <br>   fontsize=12, bbox=dict(edgecolor='w', color='w'))<br><br>plt.grid(True)<br><br>plt.show()</pre>
                                </p>
                                <img src="img/matplotlib/p_1/figure_3.png" class="image" height="200" alt="lorem">
                            </div>
                        </div>
                        <h3 id="15.2">15.2 Свойства графических элементов:</h3>
                        <div class="text-in-card">
                            <p>
                                Многообразие и удобство создания графики в matplotlib 
                                обеспечивается не только за счёт созданных графических 
                                команд, но и за счёт богатого арсенала по конфигурации 
                                типовых форм. Эта настройка включает в себя работу с цветом, 
                                формой, типом линии или маркера, толщиной линий, 
                                степенью прозрачности элементов, размером и типом шрифта и 
                                другими свойствами.
                            </p>
                            <p>
                                Параметры, которые определяют эти свойства в различных 
                                графических командах, обычно имеют одинаковый синтаксис, 
                                то есть называются одинаково. Стандартным способом 
                                задания свойств какого либо создаваемого объекта (или методу) 
                                является передача по ключу: ключ=значение. Наиболее часто встречаемые 
                                названия параметров изменения свойств графических объектов перечислены ниже:
                            </p>
                            <ul>
                                <li>
                                    <b class="red">color</b>, 
                                    <b class="red">colors</b>, 
                                    <b class="red">c</b> - цвет;
                                </li>
                                <li>
                                    <b class="red">linewidth</b>, <b class="red">linewidths</b> - толщина линии;
                                </li>
                                <li><b class="red">linestyle</b> - тип линии;</li>
                                <li>
                                    <b class="red">alpha</b> - степень прозрачности 
                                    (от полностью прозрачного 0 до непрозрачного 1);
                                </li>
                                <li><b class="red">fontsize</b> - размер шрифта;</li>
                                <li><b class="red">marker</b> - тип маркера;</li>
                                <li><b class="red">s</b> - размер маркера в методе plt.scatter(только цифры);</li>
                                <li><b class="red">rotation</b> - поворот строки на X градусов.</li>
                            </ul>
                            <p>
                                При создании функций или методов классов, особенно в случае наследования, 
                                параметры часто передают в виде объединений последовательностей: 
                                кортежа или словаря. Для этого существуют специальные символы-приставки: 
                                "*" или "**" соответственно. Это особенно полезно в случаях, 
                                когда функция/метод может принимать переменное число параметров.
                            </p>
                            <p>
                                Принято, что для передачи кортежа используется переменная args, 
                                а в случае со словарём - kwargs. Если перед переменной args 
                                указан символ "*", то все дополнительные аргументы, 
                                переданные функции/методу, сохранятся в args в виде кортежа. 
                                Если перед args будет указан символ "**", то все дополнительные 
                                параметры будут рассматриваться как пары "ключ - значение" в словаре.
                            </p>
                            <button class="accordion">Пример:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">N = 100<br>x = np.arange(N)<br># Задаём выборку из Гамма-распредления с <br>#    параметрами формы=1. и масштаба=0.<br>z = np.random.gamma(2., 1., N)<br>z1 = np.cos(x/10.)<br>z2 = np.cos(x/20.)<br><br>y = z.reshape(10,10)<br>#y = np.cos(y)<br><br>fig = plt.figure()<br>cc = plt.contourf(y)<br>cbar = plt.colorbar(cc)<br><br>plt.title('1. TITLE', color='green')<br>plt.xlabel('2. X - LABEL')<br>plt.ylabel('3. Y - LABEL', fontsize=16)<br><br>#Подписи для цветовых шкал имеют отличный от <br>#   остальных подписей синтаксис<br>cbar.ax.set_xlabel('4. COLORBAR X-LABEL', color='b')<br>cbar.ax.set_ylabel('5. COLORBAR Y-LABEL', color='r')<br>plt.grid(True)<br><br>fig = plt.figure()<br><br>my_dict = {'color' : 'grey', <br>    'linewidth' : 2.5, 'linestyle' : '--'}<br>xz = [x, z]<br><br># передача параметров через список xz и <br>#    словарь my_dict. Наличие знаков * и ** обязательно!<br>cc = plt.plot(*xz, **my_dict) <br># результат аналогичен такой записи<br>#cc = plt.plot(x, z, color='grey',#    linewidth=2.5, linestyle='--')<br><br>plt.scatter(x, y + 2.0, marker='v', s=10, color='red')<br><br>plt.title('Sample from Gamma distribution')<br>plt.xlabel('Gamma sample values')<br>plt.ylabel('Sample numbers')<br><br># Подписи для цветовых шкал имеют отличный <br>#    от остальных подписей синтаксис<br>cbar.ax.set_xlabel('4. COLORBAR X-LABEL', fontsize=8)<br>cbar.ax.set_ylabel('5. COLORBAR Y-LABEL', color='r')<br>plt.grid(True, color='blue', linewidth=1.0)<br><br>fig = plt.figure()<br><br># создание словаря<br>my_dict = {'color' : 'green', <br>    'linewidth' : 4.0, 'alpha' : 0.5}<br><br>plt.fill_between(x, z2, z1, color='green', alpha=0.25)<br>plt.plot(x, z1, color='green', linewidth=4.0)<br>plt.plot(x, z2, **my_dict)<br>plt.title('Different alpha values')<br>plt.grid(True)<br><br>plt.show()<br></pre>
                                </p>
                                <img src="img/matplotlib/p_2/figure_1.png" class="image" height="200" alt="lorem">
                                <img src="img/matplotlib/p_2/figure_2.png" class="image" height="200" alt="lorem">
                                <img src="img/matplotlib/p_2/figure_3.png" class="image" height="200" alt="lorem">
                            </div>
                        </div>
                        <h3 id="15.3">15.3 Основные графические команды:</h3>
                        <div class="text-in-card">
                            <p>
                                <b class="red">Графические команды</b> - это функции, которые, принимая некоторые 
                                параметры, возвращают какой-то графический результат. 
                                Это может быть текст, линия, график, диаграмма и др.
                            </p>
                            <p>
                                В Matplotlib заложены как простые графические команды, так и достаточно сложные. 
                                Доступ к ним через pyplot означает использование синтаксиса вида 
                                <span class="code">plt.название_команды()</span>.
                            </p>
                            <p>Наиболее распространённые команды для создания научной графики в matplotlib это:</p>
                            <ul>
                                <li>
                                    Самые простые графические команды:
                                    <ul>
                                        <li><b class="red">plt.scatter()</b> - маркер или точечное рисование;</li>
                                        <li><b class="red">plt.plot()</b> - ломаная линия;</li>
                                        <li><b class="red">plt.text()</b> - нанесение текста;</li>
                                    </ul>
                                </li>
                                <li>
                                    Диаграммы:
                                    <ul>
                                        <li>
                                            <b class="red">plt.bar()</b>, 
                                            <b class="red">plt.barh()</b>, 
                                            <b class="red">plt.barbs()</b>, 
                                            <b class="red">broken_barh()</b> 
                                            - столбчатая диаграмма;
                                        </li>
                                        <li>
                                            <b class="red">plt.hist()</b>, 
                                            <b class="red">plt.hist2d()</b>, 
                                            <b class="red">plt.hlines</b> 
                                            - гистограмма;
                                        </li>
                                        <li><b class="red">plt.pie()</b> - круговая диаграмма;</li>
                                        <li><b class="red">plt.boxplot()</b> - "ящик с усами" (boxwhisker);</li>
                                        <li><b class="red">plt.errorbar()</b> - оценка погрешности, "усы";</li>
                                    </ul>
                                </li>
                                <li>
                                    Изображения в изолиниях:
                                    <ul>
                                        <li><b class="red">plt.contour()</b> - изолинии;</li>
                                        <li><b class="red">plt.contourf()</b> - изолинии с послойной окраской;</li>
                                    </ul>
                                </li>
                                <li>
                                    Отображения:
                                    <ul>
                                        <li>
                                            <b class="red">plt.pcolor()</b>, 
                                            <b class="red">plt.pcolormesh()</b> 
                                            - псевдоцветное изображение матрицы (2D массива);
                                        </li>
                                        <li><b class="red">plt.imshow()</b> - вставка графики (пиксели + сглаживание);</li>
                                        <li><b class="red">plt.matshow()</b> - отображение данных в виде квадратов;</li>
                                    </ul>
                                </li>
                                <li>
                                    Заливка:
                                    <ul>
                                        <li><b class="red">plt.fill()</b> - заливка многоугольника;</li>
                                        <li>
                                            <b class="red">plt.fill_between()</b>, 
                                            <b class="red">plt.fill_betweenx()</b> 
                                            - заливка между двумя линиями;
                                        </li>
                                    </ul>
                                </li>
                                <li>
                                    Векторные диаграммы:
                                    <ul>
                                        <li><b class="red">plt.streamplot()</b> - линии тока;</li>
                                        <li><b class="red">plt.quiver()</b> - векторное поле;</li>
                                    </ul>
                                </li>
                            </ul>
                            <p>
                                В списке нет команд для рисования различных геометрических фигур 
                                (круги, многоугольники и т.д.). Это связано с тем, что в matplotlib 
                                они вызываются через matplotlib.patches, который за них отвечает.
                            </p>
                            <p>
                                Ниже показаны примеры графики, которую matplotlib создаёт 
                                "по умолчанию" при вызове той или иной графической команды. 
                                В дальнейшем будет показано как задать ту или иную конфигурацию 
                                конкретного графика и как настроить сопутствующие рисунку 
                                элементы (подписи, линии вспомогательной сетки, шрифты и т.д.).
                            </p>
                            <button class="accordion">Пример №1:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">import matplotlib.pyplot as plt<br># Создаём фигуру<br># Добавление на рисунок прямоугольной (по умолчанию)<br>#области рисования<br>fig = plt.figure()<br># Ставим точку в координаты (0, 1)<br>scatter1 = plt.scatter(0.0, 1.0)<br># Пишем в консоли точку и объект точки<br>print('Scatter: ', type(scatter1))<br># Рисуем линию где первый аргумент <br>#первого массива это x начала линии, <br># а 1-й аргумент 2-го массива это y начала линии<br># А вторые аргументы массивов это конец линии (x, y)<br>graph1 = plt.plot([-1.0, 1.0], [0.0, 1.0])<br>print('Plot: ', len(graph1), graph1)<br>#Пишем текст "Text on figure" в точке (0.5, 0.5)<br>text1 = plt.text(0.5, 0.5, 'Text on figure')<br>print('Text: ', type(text1))<br>grid1 = plt.grid(True)   # линии вспомогательной сетки<br>#Выводим график<br>plt.show()</pre>
                                </p>
                                <img src="img/matplotlib/p_3/figure_1.png" class="image" height="200" alt="lorem">
                            </div>
                            <button class="accordion">Пример №2:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">import matplotlib.pyplot as plt<br>import numpy as np<br>#Задаём данные для графиков<br>s = ['one','two','three ','four' ,'five']<br>x = [1, 2, 3, 4, 5]<br>z = np.random.random(100)<br>z1 = [10, 17, 24, 16, 22]<br>z2 = [12, 14, 21, 13, 17]<br># bar() создаём фигуру<br>fig = plt.figure()<br># Даём данные в столбчатую диаграмму<br>plt.bar(x, z1)<br>#Пишем название графика и добавляем сетку<br>plt.title('Simple bar chart')<br>plt.grid(True)   # линии вспомогательной сетки<br># hist() Создаём сетку<br>fig = plt.figure()<br># Даём случайные данные в диаграмму, от прошлой она <br>#отличается отсутствием отступов между столбцами<br># А далее так же называем график и добавляем сетку<br>plt.hist(z)<br>plt.title('Simple histogramm')<br>plt.grid(True)<br># pie() Создаём фигуру<br>fig = plt.figure()<br># В команду круговой диаграмы добавляем данные <br>#x и названия к этим данным, а дальше название, сетки нет<br>plt.pie(x, labels=s)<br>plt.title('Simple pie chart')<br># boxplot() Создаём фигуру<br>fig = plt.figure()<br># Добавляем данные, по данным можно посмотреть, <br>#что за что отвечает, а дальше название и сетка<br>plt.boxplot([z1, z2])<br>plt.title('Simple box whisker chart')<br>plt.grid(True)<br># errorbar() Создаём фигуру<br>fig = plt.figure()<br># Разкладываем один из наших усатых ящиков на составляющие части<br>plt.errorbar(x, z1, xerr=1, yerr=0.5)<br>plt.title('Simple error bar chart')<br>plt.grid(True)<br><br>plt.show()</pre>
                                </p>
                                <img src="img/matplotlib/p_3/figure_2.png" class="image" height="200" alt="lorem">
                                <img src="img/matplotlib/p_3/figure_3.png" class="image" height="200" alt="lorem">
                                <img src="img/matplotlib/p_3/figure_4.png" class="image" height="200" alt="lorem">
                                <img src="img/matplotlib/p_3/figure_5.png" class="image" height="200" alt="lorem">
                                <img src="img/matplotlib/p_3/figure_6.png" class="image" height="200" alt="lorem">
                            </div>
                            <button class="accordion">Пример №3:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">import matplotlib.pyplot as plt<br>import numpy as np<br>#Делаем данные для графика и сразу же переводим<br>#их в матрицу нужного размера<br>dat = np.random.random(200).reshape(20,10)<br>#создаём матрицу значений<br>#Создаём фигуру<br>fig = plt.figure()<br>pc = plt.pcolor(dat)<br>#метод псевдографики pcolor для отображения 2-х мерной матрицы<br>plt.colorbar(pc)<br>#Помещаем данные на псевдографику и подписываем фигуру<br>plt.title('Simple pcolor plot')<br>#Делаем то же самое<br>fig = plt.figure()<br>me = plt.imshow(dat)<br>plt.colorbar(me)<br>plt.title('Simple imshow plot')<br>plt.show()</pre>
                                </p>
                                <img src="img/matplotlib/p_3/figure_7.png" class="image" height="200" alt="lorem">
                                <img src="img/matplotlib/p_3/figure_8.png" class="image" height="200" alt="lorem">
                            </div>
                            <button class="accordion">Пример №4:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">import matplotlib.pyplot as plt<br>import numpy as np<br># Тут всё так же как и было в прошлом примере,<br>#только метод отображения немного другой, хотя смысл<br>#у него как и у цветных квадратиков<br>dat = np.random.random(200).reshape(20,10)<br># создаём матрицу значений<br>fig = plt.figure()<br>cr = plt.contour(dat)<br>plt.colorbar(cr)<br>plt.title('Simple contour plot')<br>fig = plt.figure()<br>cf = plt.contourf(dat)<br>plt.colorbar(cf)<br>plt.title('Simple contourf plot')<br>fig = plt.figure()<br>cf = plt.matshow(dat)<br>plt.colorbar(cf, shrink=0.7)<br>plt.title('Simple matshow plot')<br><br>plt.show()</pre>
                                </p>
                                <img src="img/matplotlib/p_3/figure_9.png" class="image" height="200" alt="lorem">
                                <img src="img/matplotlib/p_3/figure_10.png" class="image" height="200" alt="lorem">
                                <img src="img/matplotlib/p_3/figure_11.png" class="image" height="200" alt="lorem">
                            </div>
                            <button class="accordion">Пример №5:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">import matplotlib.pyplot as plt<br>import numpy as np<br>#Создаём массив от 0 до 4*pi+0.1 с шагом 0.1<br>x = np.arange(0, 4*np.pi+0.1, 0.1)<br>#Ищем синусы от массива<br>y = np.sin(x)<br>#Ищем синусы от удвоенного массива<br>z = np.sin(2*x)<br>#Делаем массив от 01 до 19 и создаём <br>массив значений прямых<br>x2 = np.arange(20)<br>y2 = -1.5*x2 + 2.33<br>z2 = 0.7*x2 - 8.5<br># fill() Создаём фигуру<br>fig = plt.figure()<br>plt.fill(x, y, 'r')<br># метод графики который заливает фигуру, <br>"r" это красный цвет<br>plt.grid(True)<br>#fill_between() Создаём фигуру и рисуем<br>#2 прямые розового и зелёного цвета<br>fig = plt.figure()<br>plt.plot(x2, z2, color='pink', linewidth=4.0)<br>plt.plot(x2, y2, color='g', linewidth=4.0)<br>#После закрашиваем всё, что есть между нашими кривыми,<br>#пишем заголовок и добавляем сетку<br>plt.fill_between(x2, y2, z2)<br>plt.title('Simple fill_between')<br>plt.grid(True)<br>#fill_betweenx() создаём фигуру и рисуем синусы<br>#от 2x смещённые на единичку<br>fig = plt.figure()<br>plt.plot(z, x, color='pink', linewidth=4.0)<br>plt.plot(z, x-1.0, color='g', linewidth=4.0)<br>#Рисуем и закрашиваем, то что есть между этими<br>#синусами только по горизонтали<br>plt.fill_betweenx(z, x, x-1.0, color='cyan')<br>plt.title('Simple fill_betweenx')<br>plt.grid(True)<br>plt.show()</pre>
                                </p>
                                <img src="img/matplotlib/p_3/figure_12.png" class="image" height="200" alt="lorem">
                                <img src="img/matplotlib/p_3/figure_13.png" class="image" height="200" alt="lorem">
                                <img src="img/matplotlib/p_3/figure_14.png" class="image" height="200" alt="lorem">
                            </div>
                            <button class="accordion">Пример №6:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">import matplotlib.pyplot as plt<br>import numpy as np<br>#Создаём массив в указанных пределах с шагом с 0.1<br>x = np.arange(-2*np.pi, 2*np.pi, 0.1)<br>u = np.sin(x)*np.cos(x)<br>v = np.cos(x)<br># Создаёт координатные матрицы из координатных векторов<br>uu, vv = np.meshgrid(u,v)<br>N = 100<br>x1 = np.random.random(N).reshape((10, 10))<br>y1 = np.random.random(N).reshape((10, 10))<br># Ну и дальше рисуем всякое, легко узнать что и как мы рисуем<br># streamplot()<br>fig = plt.figure()<br>plt.streamplot(x, x, uu, vv)<br>plt.title('Simple stream plot')<br>plt.grid(True)<br># quiver()<br>fig = plt.figure()<br>plt.quiver(x1, y1, color='green')<br>plt.title('Simple quiver plot')<br>plt.grid(True)<br>plt.show()</pre>
                                </p>
                                <img src="img/matplotlib/p_3/figure_15.png" class="image" height="200" alt="lorem">
                                <img src="img/matplotlib/p_3/figure_16.png" class="image" height="200" alt="lorem">
                            </div>
                        </div>
                        <h3 id="15.4">15.4 Текст и шрифты:</h3>
                        <div class="text-in-card">
                            <p>
                                Текст является одним из базовых графических элементов рисунка в matplotlib. 
                                Подписи координатных осей и их делений, заголовки, пояснительные подписи 
                                на графиках и диаграммах - это всё текст. В Matplotlib возможна 
                                поддержка кириллицы для создания научной графики с подписями на 
                                русском языке. Одним из весомых преимуществ matplotlib при работе с 
                                текстом является простая поддержка математических формул с помощью LaTex.
                            </p>
                            <p>
                                Одними из самых базовых графических команд являются команды, отображающие текст. 
                                Самой простой такой командой, не привязной к какому-либо объекту вроде 
                                координатной оси или делений координатной оси, является команда 
                                <b class="red">plt.text()</b>. В качестве входящих данных она принимает 
                                координаты положения будущей строки и сам текст в виде строки. 
                                По умолчанию координаты положения строки будут приурочены к области изменения данных.
                                Можно задать положение текста в относительных координатах, 
                                когда вся область рисования изменяется по обеим координатным 
                                осям от 0 до 1 включительно. Таким образом, координата (0.5, 0.5) 
                                в относительных координатах означает центр области рисования.
                                Текст можно выровнять с помощью параметров 
                                <b class="red">horizontalalignment</b> и <b class="red">verticalalignment</b>, 
                                а также заключать его в рамку с цветным фоном, передав параметр <b class="red">bbox</b>. 
                                <b class="red">Bbox</b> - это словарь, работающий со свойствами прямоугольника, 
                                то есть объектом Rectangle.
                            </p>
                            <p>
                                Помимо метода text() существуют и другие методы отображения текста в pyplot. 
                                Ниже представлен список текстовых команд в pyplot, в квадратных скобках указан 
                                альтернативный синтаксис вызова аналогичных команд в ООП стиле.
                            </p>
                            <ul>
                                <li>
                                    <b class="red">plt.xlabel()</b> - добавляет подпись оси абсции OX 
                                    [<b class="red">matplotlib.axes.Axes.set_xlabel()</b>];
                                </li>
                                <li>
                                    <b class="red">plt.ylabel()</b> - добавляет подпись оси ординат OY 
                                    [<b class="red">matplotlib.axes.Axes.set_ylabel()</b>];
                                </li>
                                <li>
                                    <b class="red">plt.title()</b> - добавляет заголовок для области рисования Axes 
                                    [<b class="red">matplotlib.axes.Axes.set_title()</b>];
                                </li>
                                <li>
                                    <b class="red">plt.figtext()</b> - добавляет текст на рисунок Figure 
                                    [<b class="red">matplotlib.figure.Figure.text()</b>];
                                </li>
                                <li>
                                    <b class="red">plt.suptitle()</b> - добавляет заголовок для рисунка Figure 
                                    [<b class="red">matplotlib.figure.Figure.suptitle()</b>];
                                </li>
                                <li>
                                    <b class="red">plt.annotate()</b> - добавляет примечание, 
                                    которое состоит из текста и 
                                    необязательной стрелки в указанную область на рисунке 
                                    [<b class="red">matplotlib.axes.Axes.annotate()</b>];
                                </li>
                            </ul>
                            <p>
                                Каждый текст на рисунке - это экземпляр либо исходного класса, либо дочернего класса для 
                                <b class="red">matplotlib.text.Text</b>.
                            </p>
                            <button class="accordion">Пример:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">import matplotlib as mpl<br>import matplotlib.pyplot as plt<br>import numpy as np<br># Готовим данные для осей<br>a = 1.<br>x = np.arange(-2*np.pi, 2*np.pi, 0.05)<br># Уравнение кардиоиды<br>xz = a*(2*np.cos(x) - np.cos(2*x))<br>yz = a*(2*np.sin(x) - np.sin(2*x))<br># Создаём фигуру и рисуем на ней кардиойду<br>fig = plt.figure()<br>plt.plot(xz, yz)<br># Пишем текст в координатах данных<br>str1 = plt.text(-np.pi/2., np.pi/2.,<br>    'Text in absolute coords', fontsize=14)<br># выравнивание по левому краю<br>print('Text class: %s' % str1.__class__)<br># Пишем текст в рамке<br>plt.text(0.5, 0.5, 'Text with borders', fontsize=14,<br>        # выравнивание по вертикали<br>        #и по горизонтали по центру<br>        horizontalalignment='center',<br>        verticalalignment='center',<br>        bbox=dict(facecolor='pink', alpha=0.5))<br># Текст в относительных координатах<br>#области рисования ax<br>ax = fig.add_subplot(111)<br># создаём область рисования ax<br>plt.text(0.5, 0.5, 'Text in relative coords',<br>        fontsize=14,<br>        horizontalalignment='right',<br>        verticalalignment='center',<br>        transform=ax.transAxes)<br>plt.grid()<br><br>plt.show()</pre>
                                </p>
                                <img src="img/matplotlib/p_4/figure_1.png" class="image" height="200" alt="lorem">
                            </div>
                            <h4>Наборы шрифтов. Стили и форматы:</h3>
                            <p>Есть 5 наборов шрифтов:</p>
                            <ul>
                                <li>cursive;</li>
                                <li>fantasy;</li>
                                <li>monospace;</li>
                                <li>sans-serif;</li>
                                <li>serif;</li>
                            </ul>
                            <p>
                                Один из этих пяти наборов является текущим. 
                                За это отвечает параметр <b class="red">font.family</b>. Каждый набор 
                                может состоять из одного или более шрифтов. 
                                Причём можно указывать шрифты, которые не 
                                установлены в ОС. Работать такие шрифты не будут, но формально 
                                указать их можно. Такая настройка определяет шрифт для 
                                всех подписей и текста на рисунке. Если конкретную 
                                подпись необходимо сделать другим шрифтом, можно 
                                указать шрифт из текущего стиля прямо в команде, 
                                передав в качестве соответствующего параметра словарь: 
                                <span class="code">{'fontname':'название_шрифта'}</span>
                            </p>
                            <p>
                                Помимо семейств, текст также может иметь стиль. 
                                Атрибут стиля <b class="red">style</b> может быть либо '<b class="red">italic</b>', 
                                либо '<b class="red">oblique</b>', либо '<b class="red">normal</b>' (по умолчанию). 
                                Толщина или "жирность" шрифта, может быть задана через атрибут <b class="red">fontweight</b>
                                , который принимает значения '<b class="red">bold</b>', 
                                '<b class="red">light</b>' или '<b class="red">normal</b>' (по умолчанию). 
                                Стили и форматы можно комбинировать.
                            </p>
                            <button class="accordion">Пример:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">import matplotlib as mpl<br>import matplotlib.pyplot as plt<br>import numpy as np<br><br>mpl.rcParams['font.fantasy'] = 'Arial', 'Times New Roman',<br>        'Tahoma', 'Comic Sans MS', 'Courier'<br>mpl.rcParams['font.family'] = 'fantasy'<br><br># Текущий стиль-семейство шрифтов<br>cfam = mpl.rcParams.get('font.family')[0]<br>print('cfam %s' % cfam)<br>cfont = mpl.rcParams.get('font.fantasy')[0]<br><br># Первый шрифт в текущем семействе<br>print(mpl.rcParams.get('font.%s' % cfam))<br><br>N = 100<br>x = np.arange(N)<br># Задаём выборку из Гамма-распредления<br>#с параметрами формы=1. и масштаба=3.0<br>y = np.random.gamma(1.0, 3.0, N)<br><br>fig = plt.figure()<br>cc = plt.hist(y)<br><br>text_style = ['italic', 'oblique', 'normal']<br>font_weights = ['bold', 'light', 'normal']<br>for i, ts in enumerate(text_style):<br>    plt.text(6, 20-5*i, '%s text style' % ts,<br>        {'fontname':'Courier'}, style=ts, fontsize=14)<br>    plt.text(6, 35-4*i, '%s & %s text style' % (ts, font_weights[i]),<br>        {'fontname':'Courier'},<br>        style=ts, fontweight=font_weights[i], fontsize=12)<br><br>plt.title('Title has %s font' % cfont,<br>    fontweight='normal', color='k', fontsize=16)<br>plt.xlabel('Bold weight', {'fontname':'Times New Roman'},<br>    fontweight='bold', fontsize=16)<br>plt.ylabel('Light weight', {'fontname':'Times New Roman'},<br>    fontweight='light', fontsize=14)<br>plt.grid(True)<br><br>plt.show()</pre>
                                </p>
                                <img src="img/matplotlib/p_4/figure_2.png" class="image" height="200" alt="lorem">
                            </div>
                            <h4>Кириллица и matplotlib. Подписи по-русски</h4>
                            <p>
                                Кириллица "из коробки" не поддерживается в matplotlib. 
                                Однако настроить поддержку русского алфавита несложно. 
                                Основная проблема matplotlib для отображения кириллических 
                                символов состоит в том, что по умолчанию используются шрифты, 
                                которые не поддерживают кириллицу. Соответственно, решение 
                                проблемы отображения русского алфавита заключается в смене 
                                шрифта на тот, который поддерживает кириллицу. В ОС Windows 
                                это может быть, например, Arial, Times New Roman или Tahoma. 
                                Сделать это можно как в теле самой программы-скрипта, 
                                так и в профильных настройках.
                            </p>
                            <p>
                                У каждого стиля шрифта определены списки из реальных шрифтов, 
                                которыми пользуются в текстовых процессорах и редакторах. 
                                Чтобы поставить шрифт, который будет корректно отображать кириллицу, 
                                можно воспользоваться таким примером:
                            </p>
                            <pre class="code">import matplotlib as mpl<br>mpl.rcParams['font.family'] = 'fantasy'<br>mpl.rcParams['font.fantasy'] = 'Arial', 'Times New Roman', 'Tahoma'</pre>
                            <p>
                                Таким образом, набор fantasy будет основным, 
                                и из него будет использован шрифт Arial. 
                                Если он не будет найден, то будет выбран второй 
                                по списку и так далее. Оба представленных шрифта 
                                корректно отображают кириллические символы.
                            </p>
                            <button class="accordion">Пример:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">from matplotlib import rc<br><br>font = {'family': 'Courier New',<br>        'weight': 'normal'}<br>rc('font', **font)<br><br>cfam = mpl.rcParams.get('font.family')[0]<br>print(cfam)<br>cfont = mpl.rcParams.get('font.fantasy')[0]<br>print(cfont)<br><br>plt.text(0.25, 0.45, u'Стиль %s по умолчанию' % cfam)<br>plt.text(0.25, 0.25, u'Шрифт Arial',<br>        {'fontname':'Arial'})<br><br>plt.xlabel(u'Ось абсцисс',<br>        {'fontname':'Arial'})<br>plt.ylabel(u'Ось ординат',<br>        {'fontname':'Times New Roman'})<br>plt.title(u'Заголовок и буква Ё!<br>        А также разные шрифты элементов рисунка',<br>        {'fontname':'Tahoma'})<br>plt.grid()<br><br>plt.show()</pre>
                                </p>
                                <img src="img/matplotlib/p_4/figure_3.png" class="image" height="200" alt="lorem">
                            </div>
                            <p>Список доступных в ОС шрифтов можно узнать, например, вот так:</p>
                            <pre class="code">import matplotlib.font_manager as fm<br>for i, font in enumerate(sorted(fm.findSystemFonts())):<br>    # Шрифтов в системе очень много.<br>    #Полный список занимает не одну страницу A4<br>    if(i % 50 == 0):<br>        print(i, font)</pre>
                            <p>
                                Для поиска по названию известного вам шрифта в 
                                ОС можно воспользоваться функцией findfont:
                            </p>
                            <pre class="code">import matplotlib.font_manager as fm<br>print('Courier New - %s' % fm.findfont('Courier New'))<br># Ищем Courier New<br>print('Times New Roman - %s' % fm.findfont('times new roman'))<br># Ищем times new roman строчными буквами<br>print('Comic Sans MS - %s' % fm.findfont('COMIC SANS MS'))<br># Ищем COMIC SANS MS прописными буквами</pre>
                        </div>
                        <h3 id="15.5">15.5 Цвета и цветовая палитра:</h3>
                        <div class="text-in-card">
                            <p>
                                Цвет может быть задан либо через пропорции трёх базовых цветов: 
                                красного, зелёного и синего. Такой способ носит название RGB. 
                                Другим стандартным методом является использование шестнадцатиричной 
                                кодировки (HEX), которая широко применяется в HTML.
                            </p>
                            <h4>Цвет как декоративный элемент</h4>
                            <p>
                                Matplotlib предоставляет широкие возможности для работы с цветом. 
                                Существует ряд предустановленных цветов, которые имеют следующие аббревиатуры:
                            </p>
                            <ul>
                                <li>
                                    <b class="red">Красный</b> - 'red', 'r', (1.0, 0.0, 0.0);
                                </li>
                                <li>
                                    <b class="red">Оранжевый</b> - 'orange';
                                </li>
                                <li>
                                    <b class="red">Жёлтый</b> - 'yellow', 'y', (0.75, 0.75, 0);
                                </li>
                                <li>
                                    <b class="red">Зелёный</b> - 'green', 'g', (0.0, 0.5, 0.0);
                                </li>
                                <li>
                                    <b class="red">Голубой</b> - 'cyan', 'c', (0.0, 0.75, 0.75);
                                </li>
                                <li>
                                    <b class="red">Синий</b> - 'blue', 'b', (0.0, 0.0, 1.0);
                                </li>
                                <li>
                                    <b class="red">Фиолетовый</b> - 'magenta', 'm', (0.75, 0, 0.75);
                                </li>
                                <li>
                                    <b class="red">Чёрный</b> - 'black', 'k', (0.0, 0.0, 0.0);
                                </li>
                                <li>
                                    <b class="red">Белый</b> -'white', 'w', (1.0, 1.0, 1.0);
                                </li>
                            </ul>
                            <h4>Способы задания цветов. RGB и HEX</h4>
                            <p>
                                <b class="red">Цвет в формате RGB</b> представляет собой триплет или кортеж, 
                                состоящий из трёх целых значений от 0 до 255 для красного, 
                                зелёного и синего цветов. Различные сочетания этих трёх значений 
                                позволяет получить огромное количество оттенков и цветов.
                            </p>
                            <p>
                                В matplotlib цвета rgb значения задаются в относительных единицах, 
                                в диапазоне от [0, 1]. Если необходимый цвет задан в диапазоне [0, 255], 
                                то нужно просто поделить их на 255.
                            </p>
                            <p>
                                Цвет, представленный в формате HEX, передаётся в виде 
                                шестнадцатеричной html строки 
                                (символ # перед шестизначным значением обязателен).
                            </p>
                            <button class="accordion">Пример:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">import matplotlib.pyplot as plt<br>import numpy as np<br>fig = plt.figure() # Создаём фигуру<br>ax = fig.add_subplot(111)<br># добавление области рисования ax<br># Делаем данные<br>N = 10<br>x = np.arange(1, N+1, 1)<br>y = 20.*np.random.rand(N)<br>#Задаём цвета<br>rgb = np.array([204,255,51])/255.<br>myhex = '#660099'<br># А теперь рисуем то что нам нужно<br>ax.plot(x, y, color=myhex)<br>ax.bar(x, y, color=rgb, alpha=0.75, align='center')<br>ax.set_xticks(x)   # установка делений на оси OX<br>ax.set_xlim(np.min(x)-1, np.max(x)+1)<br># ограничение области изменения по оси OX<br>ax.grid(True)<br>plt.show()</pre>
                                </p>
                                <img src="img/matplotlib/p_5/figure_1.png" class="image" height="200" alt="lorem">
                            </div>
                            <h4>Цветовая палитра colormap</h4>
                            <p>
                                Последовательность или набор цветов образует цветовую палитру colormap. 
                                Чаще всего она используется при отрисовке трёхмерных данных. 
                                Но и автоматический подбор цветов при добавлении каждого нового 
                                экземпляра plot также осуществляется из цветовой палитры по умолчанию.
                            </p>
                            <p>
                                Для получения текущей цветовой палитры можно воспользоваться методом 
                                <span class="code">plt.get_cmap('название палитры')</span>. 
                                Список всех предустановленных палитр можно получить с 
                                помощью метода <span class="code">plt.cm.datad</span>. В настройках 
                                <b class="red">matplotlibrc</b> можно также изменить цветовую палитру 
                                с помощью параметра <span class="code">image.cmap</span>. 
                                В интерактивном режиме её можно поменять через 
                                <span class="code">plt.rcParams['image.cmap']='имя_палитры'</span> 
                                или через <span class="code">plt.set_cmap('имя_палитры')</span>. 
                                Последний позволяет изменить палитру текущего рисунка уже после 
                                вызова графических команд.
                            </p>
                            <button class="accordion">Пример:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">import matplotlib as mpl<br>import matplotlib.pyplot as plt<br>import numpy as np<br>dat = np.random.random(200).reshape(20,10)<br># создаём матрицу значений<br># Создаём список цветовых палитр из словаря<br>maps = [m for m in plt.cm.datad]<br># или так<br>maps = []<br>for i, m in enumerate(plt.cm.datad):<br>    maps.append(m)<br>#   print('%d - %s' % (i, m))<br>print(u'Предустановленные цветовые палитры:', maps)<br>fig, axes= plt.subplots(nrows=2,<br>        ncols=2, sharex=True, sharey=True)<br>cmaplist = plt.cm.datad<br>for ax in fig.axes:<br>    random_cmap = np.random.choice(maps)<br>    cf = ax.contourf(dat, cmap=plt.get_cmap(random_cmap))<br>    ax.set_title('%s colormap' % random_cmap)<br>    fig.colorbar(cf, ax=ax)<br><br>plt.suptitle(u'Различные цветовые палитры')<br># единый заголовок рисунка<br><br>plt.show()</pre>
                                </p>
                                <p>
                                    Вывод: Предустановленные цветовые палитры: 
                                    ['Blues', 'BrBG', 'BuGn', 'BuPu', 'CMRmap', 
                                    'GnBu', 'Greens', 'Greys', 'OrRd', 'Oranges', 
                                    'PRGn', 'PiYG', 'PuBu', 'PuBuGn', 'PuOr', 
                                    'PuRd', 'Purples', 'RdBu', 'RdGy', 'RdPu', 
                                    'RdYlBu', 'RdYlGn', 'Reds', 'Spectral', 'Wistia', 
                                    'YlGn', 'YlGnBu', 'YlOrBr', 'YlOrRd', 'afmhot', 
                                    'autumn', 'binary', 'bone', 'brg', 'bwr', 'cool', 
                                    'coolwarm', 'copper', 'cubehelix', 'flag', 'gist_earth', 
                                    'gist_gray', 'gist_heat', 'gist_ncar', 'gist_rainbow', 
                                    'gist_stern', 'gist_yarg', 'gnuplot', 'gnuplot2', 'gray', 
                                    'hot', 'hsv', 'jet', 'nipy_spectral', 'ocean', 'pink', 
                                    'prism', 'rainbow', 'seismic', 'spring', 'summer', 'terrain', 
                                    'winter', 'Accent', 'Dark2', 'Paired', 'Pastel1', 'Pastel2', 
                                    'Set1', 'Set2', 'Set3', 'tab10', 'tab20', 'tab20b', 'tab20c', 
                                    'Blues_r', 'BrBG_r', 'BuGn_r', 'BuPu_r', 'CMRmap_r', 'GnBu_r', 
                                    'Greens_r', 'Greys_r', 'OrRd_r', 'Oranges_r', 'PRGn_r', 
                                    'PiYG_r', 'PuBu_r', 'PuBuGn_r', 'PuOr_r', 'PuRd_r', 'Purples_r', 
                                    'RdBu_r', 'RdGy_r', 'RdPu_r', 'RdYlBu_r', 'RdYlGn_r', 
                                    'Reds_r', 'Spectral_r', 'Wistia_r', 'YlGn_r', 'YlGnBu_r', 
                                    'YlOrBr_r', 'YlOrRd_r', 'afmhot_r', 'autumn_r', 'binary_r', 
                                    'bone_r', 'brg_r', 'bwr_r', 'cool_r', 'coolwarm_r', 'copper_r', 
                                    'cubehelix_r', 'flag_r', 'gist_earth_r', 'gist_gray_r', 
                                    'gist_heat_r', 'gist_ncar_r', 'gist_rainbow_r', 'gist_stern_r', 
                                    'gist_yarg_r', 'gnuplot_r', 'gnuplot2_r', 'gray_r', 'hot_r', 
                                    'hsv_r', 'jet_r', 'nipy_spectral_r', 'ocean_r', 'pink_r', 
                                    'prism_r', 'rainbow_r', 'seismic_r', 'spring_r', 'summer_r', 
                                    'terrain_r', 'winter_r', 'Accent_r', 'Dark2_r', 'Paired_r', 
                                    'Pastel1_r', 'Pastel2_r', 'Set1_r', 'Set2_r', 'Set3_r', 'tab10_r', 
                                    'tab20_r', 'tab20b_r', 'tab20c_r']
                                </p>
                                <img src="img/matplotlib/p_5/f.png" class="image" height="200" alt="lorem">
                            </div>
                            <p>Всё многообразие цветовых палитр можно разбить на два типа:</p>
                            <ul>
                                <li>плавная палитра LinearSegmentedColormap</li>
                                <li>дискретная палитра ListedColormap</li>
                            </ul>
                            <p>
                                Первая используется для создания всех встроенных экземпляров colormap, 
                                а также очень полезна при создании пользовательских цветовых шкал. 
                                Вторая используется для создания пользовательской цветовой палитры 
                                colormap из заданного списка цветов.
                            </p>
                            <h4>Плавная цветовая палитра</h4>
                            <p>
                                Плавная цветовая палитра представляет собой результат 
                                линейной интерполяции между последовательностью цветов, 
                                составляющих основу палитры.
                            </p>
                            <p>
                                Различные методы отображения трёхмерных данных (разные графические команды) 
                                по умолчанию используют разные типы цветовых палитр. 
                                Так методы <b class="red">plt.imshow()</b> и <b class="red">plt.pcolor()</b> 
                                будут сопровождаться плавной цветовой палитрой:
                            </p>
                            <button class="accordion">Пример:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">import matplotlib as mpl<br>import matplotlib.pyplot as plt<br>import numpy as np<br>dat = np.random.random(200).reshape(20,10)<br># создаём матрицу значений<br># Создаём список цветовых палитр из словаря<br>maps = [m for m in plt.cm.datad]<br># или так<br>maps = []<br>for m in plt.cm.datad:<br>    maps.append(m)<br>fig, axes= plt.subplots(nrows=2, ncols=1, sharex=True)<br># смотри главу "Рисунки с несколькими областями рисования"<br>cmaplist = plt.cm.datad<br>for i, ax in enumerate(fig.axes):<br>    random_cmap = np.random.choice(maps)<br>    if(i == 0):<br>        cf = ax.pcolor(dat, cmap=plt.get_cmap(random_cmap))<br>    else:<br>        cf = ax.imshow(dat, cmap=plt.get_cmap(random_cmap))<br>    ax.set_title('%s colormap' % random_cmap)<br><br>    fig.colorbar(cf, ax=ax)<br>plt.suptitle(u'Различные цветовые палитры')<br>plt.show()</pre>
                                </p>
                                <img src="img/matplotlib/p_5/figure_2.png" class="image" height="200" alt="lorem">
                            </div>
                            <p>
                                Чтобы создать пользовательскую плавную цветовую палитру нужно, 
                                во-первых, определиться с её основными цветами. 
                                Пусть мы выбрали следующее сочетание цветов: розовый, синий, 
                                зелёный, оранжевый и красный. В представлении RGB это означает 
                                список следующих значений:
                            </p>
                            <ul>
                                <li><b class="red">Розовый</b> - rgb(150, 0, 0);</li>
                                <li><b class="red">Синий</b> - rgb(0, 0, 255);</li>
                                <li><b class="red">Зелёный</b> - rgb(0, 255, 0);</li>
                                <li><b class="red">Оранжевый</b> - rgb(255, 150, 0);</li>
                                <li><b class="red">Красный</b> - rgb(255, 0, 0);</li>
                            </ul>
                            <p>
                                Matplotlib работает с rgb в относительных единицах, 
                                поэтому классические значения rgb триплетов нужно поделить на 255.
                            </p>
                            <p>
                                После этого нужно создать "словарь палитры" cdict. 
                                Это словарь для каждого из оттенков RGB ('red', 'blue', 'green'), 
                                где каждому оттенку приписан список или кортеж (x, y0, y1):
                            </p>
                            <ul>
                                <li>
                                    <b class="red">x</b> - определяет положение в палитре в диапазоне [0,1]. 
                                    Проще представить будущую палитру в виде шкалы от 0 до 1;
                                </li>
                                <li>
                                    <b class="red">y0</b> - значение цвета в относительных единицах 
                                    ([0, 255] -> [0, 1]) с одной стороны (слева) от положения x;
                                </li>
                                <li>
                                    <b class="red">y1</b> - значение цвета ([0, 255] -> [0, 1]) с другой стороны 
                                    (справа) от положения x;
                                </li>
                            </ul>
                            <p>
                                Между заданными позициями x метод 
                                <b class="red">LinearSegmentedColormap</b> линейно интерполирует 
                                значения цветов между (x_i - y1_i) и (x_i+1 - y0_i). 
                                Обычно y0 и y1 совпадают, но, используя разные значения, 
                                можно добиваться более сложых эффектов, например разрывов в палитре.
                            </p>
                            <button class="accordion">Пример:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">import matplotlib as mpl<br>import matplotlib.pyplot as plt<br>import numpy as np<br>dat = np.random.random(200).reshape(20,10)<br># создаём матрицу значений<br>xx = np.array([0.5, 0.0, 0.1])*255<br>print xx<br># Создаём список цветовых палитр из словаря<br># ---------------------------------------------------------<br># Вариант 1 Ромашка (бело-жёлтый)<br>cdict1 = {'red':   ((0.0, 1.0, 1.0),<br>                   (1.0, 1.0, 1.0)),<br>         'green': ((0.0, 1.0, 1.0),<br>                   (1.0, 1.0, 1.0)),<br>         'blue':  ((0.0, 1.0, 1.0),<br>                   (1.0, 0.0, 0.0))<br>        }<br>cmap1 = mpl.colors.<br>        LinearSegmentedColormap('cmap1', cdict1)<br><br># Вариант 2 Светофор(красный-жёлтый-зелёный)<br>cdict2 = {'red':   ((0.0, 0.0, 0.0),<br>                   (0.5, 1.0, 1.0),<br>                   (1.0, 1.0, 1.0)),<br>         'green': ((0.0, 1.0, 1.0),<br>                   (0.5, 1.0, 1.0),<br>                   (1.0, 0.0, 0.0)),<br>         'blue':  ((0.0, 0.0, 0.0),<br>                   (0.5, 0.0, 0.0),<br>                   (1.0, 0.0, 0.0))<br>        }<br>cmap2 = mpl.colors.<br>        LinearSegmentedColormap('cmap2', cdict2)<br># ---------------------------------------------------------<br>fig, axes= plt.subplots(nrows=2, ncols=1, sharex=True)<br>cmaplist = plt.cm.datad<br>cmaps = [cmap1, cmap2]<br>for i, ax in enumerate(fig.axes):<br>    cf = ax.imshow(dat, cmap=cmaps[i])<br>    fig.colorbar(cf, ax=ax)<br>plt.suptitle(u'Создание цветовых палитр')<br>plt.show()</pre>
                                </p>
                                <img src="img/matplotlib/p_5/figure_3.png" class="image" height="200" alt="lorem">
                            </div>
                            <p>
                                Позиции цветов x на палитре могут быть неравномерными. 
                                Тогда на какие-то цвета будет приходиться большие участки цветовой палитры.
                            </p>
                            <button class="accordion">Пример:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">import matplotlib as mpl<br>import matplotlib.pyplot as plt<br>import numpy as np<br># розовый [255, 204, 255] -> [1., 0.8, 1.]<br># фиолетовый [153, 0, 255] -> [0.6, 0., 1.]<br># синий [0, 0, 255] -> [0., 0., 1.]<br># красный [255, 0, 0] -> [1., 0., 0.]<br>dat = np.random.random(200).reshape(20,10)<br># создаём матрицу значений<br>cdict1 = {'red':   ((0.0, 1.0, 1.0),<br>                    # red in RGB of pink, розовый<br>                   (0.2, 0.6, 0.6),<br>                   # red in RGB of blue синий<br>                   (0.8, 0.0, 0.0),<br>                   # red in RGB of violet фиолетовый<br>                   (1.0, 1.0, 1.0)),<br>                   # red in RGB of red красный<br>         'green':  ((0.0, 0.8, 0.8),<br>                    # green in RGB of pink, розовый<br>                   (0.2, 0.0, 0.0),<br>                   # green in RGB of blue синий<br>                   (0.8, 0.0, 0.0),<br>                   # green in RGB of violet фиолетовый<br>                   (1.0, 0.0, 0.0)),<br>                   # green in RGB of red красный<br>         'blue':  ((0.0, 1.0, 1.0),<br>                    # blue in RGB of pink, розовый<br>                   (0.2, 1.0, 1.0),<br>                   # blue in RGB of blue синий<br>                   (0.8, 1.0, 1.0),<br>                   # blue in RGB of violet фиолетовый<br>                   (1.0, 0.0, 0.0))<br>                   # blue in RGB of red красный<br>          }<br>cmap1 = mpl.colors.LinearSegmentedColormap('cmap1', cdict1)<br>plt.register_cmap(cmap=cmap1)<br># ---------------------------------------------------------<br>fig = plt.figure()<br>ax = fig.add_subplot(111)<br>cmaplist = plt.cm.datad<br>cf = ax.pcolor(dat, cmap=cmap1)<br>cbar = fig.colorbar(cf, ax=ax)<br>plt.suptitle(u'Розово-сине-фиолетово-красная палитра')<br>plt.show()</pre>
                                </p>
                                <img src="img/matplotlib/p_5/figure_4.png" class="image" height="200" alt="lorem">
                            </div>
                            <h4>Дискретная цветовая палитра</h4>
                            <p>
                                Плавная палитра, несомненно, лучше смотрятся при отображении 
                                трёхмерных поверхностей в виде плоских карт и 3D графиков. 
                                Однако в научной графике часто требуется не столько красота, 
                                сколько простота и однозначность рисунка. Чтобы избежать споров 
                                при определении оттенков и, соответственно, значений поля, 
                                следует использовать дискретные палитры там, где это критично.
                            </p>
                            <p>
                                Дискретная палитра представляет собой набор цветов с чёткой 
                                границей между соседними оттенками. Обычно этот набор берётся 
                                из одной из непрерывных шкал, но можно задать свою последовательность 
                                цветов либо в RGB, либо в HEX форматах.
                            </p>
                            <button class="accordion">Пример:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">import matplotlib as mpl<br>import matplotlib.pyplot as plt<br>import numpy as np<br>dat = np.random.random(200).reshape(20,10)<br># создаём матрицу значений<br>N = 10<br># Список цветов<br>cpool = [ '#bd2309', '#bbb12d', '#1480fa', '#14fa2f', '#000000',<br>          '#faf214', '#2edfea', '#ea2ec4', '#ea2e40', '#cdcdcd',<br>          '#577a4d', '#2e46c0', '#f59422', '#219774', '#8086d9' ]<br># Создание дискретных colormap<br>cmap1 = mpl.colors.ListedColormap(['r','orange','y',<br>            'g','c','b','violet'], 'indexed')<br>cmap2 = mpl.colors.ListedColormap(cpool[5:5+N], 'indexed')<br>#plt.register_cmap(cmap=cmap3)<br>fig, axes= plt.subplots(nrows=2, ncols=1, sharex=True)<br>cmaps = [cmap1, cmap2]<br>for i, ax in enumerate(fig.axes):<br>    cf = ax.pcolor(dat, cmap=cmaps[i])<br>    fig.colorbar(cf, ax=ax)<br>fig.suptitle(u'Создание дискретных цветовых палитр')<br>plt.show()</pre>
                                </p>
                                <img src="img/matplotlib/p_5/figure_5.png" class="image" height="200" alt="lorem">
                            </div>
                        </div>
                        <h3 id="15.6">15.6 Рисунок Figure:</h3>
                        <div class="text-in-card">
                            <p>
                                Рисунок <b class="red">Figure</b> является основой каждого изображения, 
                                которые создаётся в matplotlib. Обычно после создания экземпляра рисунка 
                                (точнее - экземпляра класса <b class="red">matplotlib.figure.Figure</b>) 
                                о нём можно забыть. 
                                Тем не менее, именно на основе экземпляра Figure вызываются экземпляры 
                                Axes, которые несут основную нагрузку при создании научной графики.
                            </p>
                            <p>
                                Стоит помнить, что пока идёт работа с одним единственным экземпляром 
                                типа Figure, то результат выполнения всех графических команд 
                                будут отображаться именно на нём. При работе со многими 
                                экземплярами Figure нельзя забывать об очищении "холста" 
                                от "красок" предыдущего рисунка.
                            </p>
                            <h4>Контейнер Figure</h4>
                            <p>
                                Верхним логическим уровнем среди контейнеров <b class="red">Artists</b> 
                                является <b class="red">matplotlib.figure.Figure</b>, который включает 
                                всё, что есть на рисунке (figure). Фоном (background) рисунка, 
                                который определяетcя в <b class="red">Figure.patch</b>, по умолчанию является 
                                прямоугольник (Rectangle). Когда на рисунке добавляются 
                                экземпляры subplots (например, с помощью метода <b class="red">add_subplot()</b>) 
                                или axes (с помощью метода <b class="red">add_axes()</b>), они автоматически 
                                добавляются в список <b class="red">Figure.axes</b>. Так как matplotlib поддерживает 
                                концепцию "текущей области" ("current axes") для работы с 
                                <b class="red">pylab</b>/<b class="red">pyplot</b>, то не рекомендуется 
                                добавлять или убирать axes 
                                из списка (<b class="red">axes list</b>) вручную. Лучше использовать методы 
                                <b class="red">add_subplot()</b>/<b class="red">add_axes()</b> для 
                                добавления экземпляров Axes 
                                и <b class="red">delaxes()</b> для их удаления.
                            </p>
                            <button class="accordion">Пример:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">import matplotlib.pyplot as plt<br>import numpy as np<br><br>fig = plt.figure()<br><br>print(type(fig))<br># Создание экземпляра Axes c помощью <br>#Figure-метода add_subplot()<br>ax = fig.add_subplot(111)<br># или так<br>box = [0.25, 0.5, 0.25, 0.25]<br># Создание экземпляра Axes c помощью <br>#Figure-метода add_axes()<br>ax2 = fig.add_axes(box)<br><br>x = np.arange(0.0, 1.0, 0.1)<br>y = np.sin(x)*np.exp(x)<br>z = np.cos(x)*np.sin(x)<br><br># Методы plot() вызываются через экземпляры<br>#ax, а не plt (интерфейс pyplot)<br>ax.plot(y)<br>ax.plot(z)<br><br>#for ax in fig.axes: можно сделать так<br>#  ax.grid(True)<br>#А можно так<br>ax.grid(True)<br>ax2.grid(True)<br><br>plt.show()</pre>
                                </p>
                                <img src="img/matplotlib/p_6/figure_1.png"  height="200" alt="lorem">
                            </div>
                            <p>Список элементов рисунка (Artists) для контейнера Figure:</p>
                            <ul>
                                <li><b class="red">axes</b> - список экземпляров Axes (включая Subplot);</li>
                                <li>
                                    <b class="red">images</b> - список FigureImages patches 
                                    (эффективно для отображения пикселей);
                                </li>
                                <li>
                                    <b class="red">legends</b> - список экземпляров Figure Legend 
                                    (отличается от Axes.legends);
                                </li>
                                <li><b class="red">lines</b> - список экземпляров Figure Line2D (редко используется);</li>
                                <li><b class="red">patch</b> - фон Rectangle;</li>
                                <li><b class="red">patches</b> - список Figure patches (редко используется);</li>
                                <li><b class="red">texts</b> - список экземпляров Figure Text;</li>
                            </ul>
                            <h4>Конфигурация Figure</h4>
                            <p>Одним из стандартных методов создания экземпляра Figure является следующий:</p>
                            <pre class="code">import matplotlib.pyplot as plt<br><br>fig = plt.figure()<br>print(u'Тип Figure %s' % type(fig))</pre>
                            <p>
                                Основные параметры созданного экземпляра Figure определяются в 
                                конфигурационном файле <b class="red">matplotlibrc</b>. Атрибуты Figure можно 
                                изменить во время создания экземпляра:
                            </p>
                            <ul>
                                <li>
                                    <b class="red">figsize</b> : кортеж из целых или действительных чисел, 
                                    который определяет ширину и высоту в дюймах. 
                                    По умолчанию равен значению <b class="red">figure.figsize</b> 
                                    из настроек <b class="red">rcParams</b>;
                                </li>
                                <li>
                                    <b class="red">dpi</b> : разрешение рисунка. По умолчанию равен 
                                    значению <b class="red">figure.dpi</b> из настроек <b class="red">rcParams</b>;
                                </li>
                                <li>
                                    <b class="red">facecolor</b> : цвет фона. По умолчанию равен 
                                    значению <b class="red">figure.facecolor</b> из настроек <b class="red">rcParams</b>;
                                </li>
                                <li>
                                    <b class="red">edgecolor</b> : цвет границы. По умолчанию равен значению 
                                    <b class="red">figure.edgecolor</b> из настроек <b class="red">rcParams</b>.
                                </li>
                            </ul>
                            <button class="accordion">Пример:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">import matplotlib.pyplot as plt<br>from matplotlib import rcParams<br><br>figsize = (8,6)<br><br>fig = plt.figure(figsize=figsize,<br>        facecolor='pink', frameon=True)<br>plt.plot([[0.0,0.0],[1.,1.]],'k')<br>plt.grid(True)<br>rcParams['figure.edgecolor'] = 'blue'<br><br>plt.show()</pre>
                                </p>
                                <img src="img/matplotlib/p_6/figure_2.png"  height="200" alt="lorem">
                            </div>
                            <p>
                                По умолчанию цвета координатной координатных осей, линий вспомогательной 
                                сетки отрисовываются чёрным цветом, а цвет фона (основы рисунка) - белым. 
                                Заменив параметры, отвечающие за соответствующие цвета, 
                                можно создать, например, инвертированный бело-чёрный рисунок. 
                                Иногда такая графика смотрится очень наглядно, стильно и 
                                привлекает к вашему материалу повышенное внимание.
                            </p>
                            <button class="accordion">Пример:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">from matplotlib import rcParams<br>import matplotlib.pyplot as plt<br>import numpy as np<br>rcParams['font.family'] = 'Times New Roman', 'Arial', 'Tahoma'<br>rcParams['font.fantasy'] = 'Times New Roman'<br># Изменение параметров рисования<br>#(смена чёрного по белому на белое по чёрному)<br>facecolor = 'k'<br>rcParams['figure.edgecolor'] = facecolor<br>rcParams['figure.facecolor'] = facecolor<br>rcParams['axes.facecolor'] = facecolor<br>#rcParams['axes.edgecolor'] = 'k'<br>rcParams['grid.color'] = 'w'<br>rcParams['xtick.color'] = 'w'<br>rcParams['ytick.color'] = 'w'<br>rcParams['axes.labelcolor'] = 'w'<br>x = np.arange(0, 4*np.pi, 0.12)<br>y = np.tan(x)<br>fig = plt.figure()<br>plt.plot(x, y,'w')<br>plt.xlim(x[0], x[-1])<br>plt.ylim(np.min(y), np.max(y))<br>plt.xlabel(u'Время [c]', fontsize=12)<br>plt.ylabel(u'Амплитуда [м]', fontsize=12)<br>plt.grid(True, color='w')<br><br>plt.show()</pre>
                                </p>
                                <img src="img/matplotlib/p_6/figure_3.png"  height="200" alt="lorem">
                            </div>
                            <h4>Сохранение рисунка</h4>
                            <p>
                                Сохранить получившийся рисунок можно с помощью метода <b class="red">savefig</b>, 
                                применённого либо к экземпляру Figure (<span class="code">fig.savefig()</span>), 
                                либо через pyplot (<span class="code">plt.savefig()</span>).
                            </p>
                            <p>
                                Стоит помнить, что по умолчанию метод <b class="red">savefig</b> имеет значения 
                                атрибутов типа <b class="red">facecolor</b> отличные от значений 
                                <b class="red">figure.facecolor</b>. 
                                В конфигурационном файле <b class="red">matplotlibrc</b> можно настроить 
                                соответствующие параметры как для <b class="red">savefigure</b>, так и для 
                                <b class="red">figure</b>. Поэтому чтобы сохранить пользовательские настройки 
                                рисунка методом savefig, нужно изменить атрибуты savefig, 
                                а не соответствующие атрибуты figure 
                                (<span class="code">dpi, format, edgecolor, facecolor, frameon</span>) или передать 
                                соответствующие значения атрибутов явно при вызове метод savefig:
                            </p>
                            <button class="accordion">Пример:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">from matplotlib import rcParams<br>import matplotlib.pyplot as plt<br>import numpy as np<br>rcParams['font.family'] = 'Times New Roman', 'Arial', 'Tahoma'<br>rcParams['font.fantasy'] = 'Times New Roman'<br># Изменение параметров рисования<br>#(смена чёрного по белому на белое по чёрному)<br>facecolor = 'k'<br>rcParams['figure.edgecolor'] = facecolor<br>rcParams['figure.facecolor'] = facecolor<br>rcParams['axes.facecolor'] = facecolor<br>#rcParams['axes.edgecolor'] = 'k'<br>rcParams['grid.color'] = 'w'<br>rcParams['xtick.color'] = 'w'<br>rcParams['ytick.color'] = 'w'<br>rcParams['axes.labelcolor'] = 'w'<br>x = np.arange(0, 4*np.pi, 0.12)<br>y = np.tan(x)<br>fig = plt.figure()<br>plt.plot(x, y,'w')<br>plt.xlim(x[0], x[-1])<br>plt.ylim(np.min(y), np.max(y))<br>plt.xlabel(u'Время [c]', fontsize=12)<br>plt.ylabel(u'Амплитуда [м]', fontsize=12)<br>plt.grid(True, color='w')<br>rcParams['savefig.edgecolor'] = 'k'<br>rcParams['savefig.facecolor'] = 'k'<br>rcParams['grid.color'] = 'w'<br>rcParams['xtick.color'] = 'w'<br>rcParams['ytick.color'] = 'w'<br>rcParams['axes.labelcolor'] = 'w'<br>fig.savefig('pic_5_3_1.png', format='png')<br>fig.savefig('pic_5_3_1.pdf', format='pdf')<br># Сохранение рисунка с пользовательскими<br>#параметрами цвета фона<br>rcParams['savefig.edgecolor'] = 'w'<br>rcParams['savefig.facecolor'] = 'w'<br>rcParams['grid.color'] = 'k'<br>rcParams['xtick.color'] = 'k'<br>rcParams['ytick.color'] = 'k'<br>rcParams['axes.labelcolor'] = 'k'<br># Атрибут facecolor передаётся явно<br>fig.savefig('pic_5_3_2.png', format='png', facecolor='k')<br>fig.savefig('pic_5_3_2.pdf', format='pdf', facecolor='k')<br>plt.show()</pre>
                                </p>
                                <img src="img/matplotlib/p_6/figure_4.png"  height="200" alt="lorem">
                            </div>
                            <p>
                                Так как для сохранения рисунков методом savefig 
                                требуется явно задать некоторые атрибуты, то среди 
                                атрибутов при создании экземпляра Figure имеет смысл 
                                задавать те, которые не являются входящими для метода 
                                savefig, а именно <b class="red">figsize</b>. 
                                <b class="red">Figsize</b> позволяет сделать 
                                рисунок меньше или больше и определяет физический размер 
                                рисунка. Так можно подобрать нужный размер для печати.
                            </p>
                            <button class="accordion">Пример:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">from matplotlib import rcParams<br>import matplotlib.pyplot as plt<br>import numpy as np<br>def sm2inch(a):<br>    '''<br>    Converts inches to santimeters<br>    '''<br>    b = []<br>    for i in a:<br>        b.append(i/2.54)<br>    return b<br># Возвращаем обычные значения<br>#цветов для дальнейшей интерактивной работы<br>rcParams['figure.edgecolor'] = 'w'<br>rcParams['figure.facecolor'] = 'w'<br>rcParams['axes.facecolor'] = 'w'<br>rcParams['axes.edgecolor'] = 'k'<br>rcParams['grid.color'] = 'k'<br>rcParams['xtick.color'] = 'k'<br>rcParams['ytick.color'] = 'k'<br>rcParams['axes.labelcolor'] = 'k'<br>figsize = (30.5, 20.5) # см<br>figsize = sm2inch(figsize)<br>print(figsize)<br>fig2 = plt.figure(figsize=figsize, facecolor='w')<br>rcParams['figure.edgecolor'] = 'w'<br>plt.text(0.45, 0.45,'Hello, world!',<br>        color='red', fontsize=16)<br>plt.grid(True)<br><br>plt.show()</pre>
                                </p>
                                <img src="img/matplotlib/p_6/figure_5.png"  height="200" alt="lorem">
                            </div>
                        </div>
                        <h3 id="15.7">15.7 Область рисования Axes:</h3>
                        <div class="text-in-card">
                            <p>
                                <b class="red">Область рисования Axes</b> - это центральный объект при 
                                создании научных графиков. Это тот объект, та область на 
                                которую наносятся координатные оси, линии графиков и столбцы диаграмм, 
                                легенды к ним и так далее. Взамен активного использования pyplot 
                                предлагается использовать более объектно-ориентированный подход 
                                для вызова графических команд и изменениях их свойств
                            </p>
                            <h4>Контейнер Axes</h4>
                            <p>
                                Структурно область рисования Axes необходима как элемент 
                                более низкого иерархического уровня нежели Figure (весь рисунок), 
                                на котором непосредственно будут располагаться различные 
                                графические элементы. Axes похож на Frame в веб-дизайне, 
                                то есть это область, на которой можно размещать графические примитивы. 
                                При этом в matploltib непосредственно на Figure нельзя рисовать 
                                (изменение цвета фона не считается за полноценное рисование) и 
                                соответственно нужен хотя бы один экземпляр axes.
                                Область рисования Axes является второй "матрёшкой" 
                                (после Figure) или контейнером, на который можно 
                                наносить другие элементы рисунка (или контейнеры), 
                                в первую очередь координатные оси Axis.
                            </p>
                            <p>
                                При создании области рисования создаётся экземпляр класса 
                                <span class="code">matplotlib.axes._axes.Axes</span>. 
                                Этот класс является, пожалуй, центром вселенной matplotlib. 
                                Он включает большинство всех элементов рисунка Artists, 
                                которые используются при создании рисунка, а также большую 
                                часть вспомогательных методов для настройки этих методов. 
                                Также у данного класса есть родственный класс 
                                <span class="code">matplotlib.axes._subplots.AxesSubplot</span>, 
                                который создаётся при создании мультиокон subplots.
                            </p>
                            <button class="accordion">Пример:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">import matplotlib.pyplot as plt<br>fig = plt.figure()<br>print (u'Список областей рисования <br>        после создания объекта fig %s \n' % fig.axes)<br>plt.scatter(0.,1.)<br>print (u'Список областей рисования <br>        после вызова комманды scatter %s \n' % fig.axes)<br><br>plt.show()</pre>
                                </p>
                                <p>
                                    Список областей рисования после создания объекта fig [] 
                                    Список областей рисования после вызова команды scatter [<matplotlib.axes._subplots.AxesSubplot object at 0x10B90410>]
                                </p>
                                <img src="img/matplotlib/p_7/figure_1.png" class="image" height="200" alt="lorem">
                            </div>
                            <p>
                                После создания экземпляра fig типа Figure список областей рисования 
                                fig.axes пуст. Но стоит вызвать любую графическую команду, 
                                создающую графический примитив, и в нём появляется экземпляр 
                                типа AxesSubplot. Таким образом, при работе с интерфейсом 
                                pyplot область рисования создаётся неявно, но она существует 
                                и именно на ней располагаются многие графические элементы 
                                (линии, текст и т.д.).
                            </p>
                            <button class="accordion">Пример:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">import matplotlib.pyplot as plt<br>import numpy as np<br><br>x = [0,1,2,3,4,5,6,7,8,9,10]<br>y = [-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11]<br><br>fig = plt.figure()<br># Первая область рисования (мультиокно 1)<br>ax = fig.add_subplot(211)<br>line = ax.plot(x, y, '-', color='blue', linewidth=2)<br>print('Lines on the axes:', type(line), line)<br># Вторая область рисования (мультиокно 2)<br>ax2 = fig.add_subplot(212)<br>n, bins, rectangles = ax2.hist(np.random.randn(1000),<br>        50, facecolor='yellow')<br>print('Patches on the axes:', <br>        len(ax2.patches), rectangles)<br><br>for ax in fig.axes:<br>    ax.grid(True)<br><br>plt.show()</pre>
                                </p>
                                <p>
                                    Lines on the axes: <class 'list'> [<matplotlib.lines.Line2D object at 0x012DF6D0>]
                                    Patches on the axes: 50 <a list of 50 Patch objects>
                                </p>
                                <img src="img/matplotlib/p_7/figure_2.png" class="image" height="200" alt="lorem">
                            </div>
                            <p>
                                При вызове метода <b class="red">ax.plot()</b> создаётся экземпляр 
                                <b class="red">matplotlib.lines.Line2D()</b>, 
                                эта линия обновляется по всем свойствам Line2D, 
                                которые были переданы в виде ключевых слов (keyword arguments), 
                                добавляется в контейнер Axes.lines и возвращается пользователю 
                                в виде списка линий. Методы, которые создают геометрические 
                                фигуры patches (например, plt.bar() создаёт ряд прямоугольников rectangles), 
                                добавляют patches в список Axes.patches.
                            </p>
                            <h4>Создание областей рисования</h4>
                            <p>
                                Чтобы создать область рисования типа Axes или AxesSubplot, 
                                существует ряд способов. Одним из стандартных способов создания 
                                области рисования является метод <b class="red">fig.add_axes()</b> 
                                экземпляра fig объекта Figure. В качестве обязательного параметра 
                                rect метод просит указать последовательность из координат 
                                начальной точки (x, y), а также ширины и высоты от неё до другого 
                                угла прямоугольника. Значения должны быть выражены в относительных 
                                единицах от 0 до 1 включительно.
                            </p>
                            <p>
                                Весь рисунок Figure по сути имеет начальную точку (0., 0.) 
                                и ширину/высоту (1., 1.). Поэтому относительно определения 
                                границ области рисования стоит помнить следующее: 
                                подписям координатных осей (axis labels), заголовкам (titles) и 
                                подписям делений координатных осей (tick labels) нужно место.
                            </p>
                            <button class="accordion">Пример:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">import matplotlib.pyplot as plt<br>fig = plt.figure()<br>x = np.arange(20)<br>y = np.exp(-np.sin(x))<br>x0 = 0.05<br>y0 = 0.05<br>dx = 0.9<br>dy = 0.9<br>rect = [x0, y0, dx, dy]<br>ax = fig.add_axes(rect)<br>ax.plot(x, y, 'g')<br>ax.text(7.5, 0.25, u'Зелёный график', color='g')<br>ax.grid(True)<br># В отличие от интерфейса pyplot, <br>#команды для назначения подписей<br># нужно употреблять с приставкой set_<br>ax.set_title(u'Метод add_axes')<br>ax.set_xlabel(u'Ось абсцисс')<br>ax.set_ylabel(u'Ось ординат')<br>print ('Тип ax: %s' % type(ax))<br><br>plt.show()</pre>
                                </p>
                                <p>
                                    Тип ax: <class 'matplotlib.axes._axes.Axes'>
                                </p>
                                <img src="img/matplotlib/p_7/figure_3.png" class="image" height="200" alt="lorem">
                            </div>
                            <p>
                                Также можно создавать области рисования с помощью метода 
                                <b class="red">fig.add_subplot()</b>, который позволяет создавать 
                                мультиокона (subplots) или мультиоконные рисунки. 
                                Создаваемая таким способом область рисования имеет другой, 
                                но родственный, класс - <b class="red">AxesSubplot</b>. 
                                В качестве обязательного параметра subplot просит указать триплет 
                                (набор из 3 цифр), который определяет место области на рисунки. 
                                Для создания одной области рисования типа AxesSubplot 
                                или просто subplot, триплет равен 111.
                            </p>
                            <button class="accordion">Пример:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">fig = plt.figure()<br>x = np.arange(20)<br>y = np.exp(-np.sin(x))<br>ax = fig.add_subplot(111)<br>ax.plot(x, y, 'g')<br>ax.text(7.5, 0.25, u'Зелёный график', color='g')<br>ax.grid(True)<br># В отличие от интерфейса pyplot,<br>#команды для назначения подписей<br># нужно употреблять с приставкой set_<br>ax.set_title(u'Метод add_subplot')<br>ax.set_xlabel(u'Ось абсцисс')<br>ax.set_ylabel(u'Ось ординат')<br>print ('Тип ax: %s' % type(ax))<br><br>plt.show()</pre>
                                </p>
                                <p>
                                    Тип ax: <class 'matplotlib.axes._subplots.AxesSubplot'>
                                </p>
                                <img src="img/matplotlib/p_7/figure_4.png" class="image" height="200" alt="lorem">
                            </div>
                            <p>
                                Ничто не мешает комбинировать методы add_subplot и add_axes на одном рисунке Figure. 
                                Стоит, однако, помнить, что размещая явно область рисования методом 
                                <b class="red">fig.add_axes()</b>, можно перекрыть другие созданные области 
                                рисования. Иногда это оказывается полезным (создание "окна в окне"), 
                                а иногда это может привести к неприятному эффекту.
                            </p>
                            <p>Правила хорошего кода</p>
                            <ul>
                                <li>
                                    <b class="red">Явно создавать экземпляр Figure:</b>
                                    <pre class="code">import matplotlib.pyplot as plt<br>fig = plt.figure()</pre>
                                </li>
                                <li>
                                    <b class="red">Создавать хотя бы одну область рисования Axes:</b>
                                    <p>
                                        <span class="code">ax = fig.add_subplot(111)</span><br>
                                        или<br>
                                        <span class="code">ax = fig.add_axes[0.05, 0.05, 0.9, 0.9]</span>
                                    </p>
                                </li>
                                <li>
                                    <b class="red">
                                        Интерфейс pyplot далее мы будем использовать редко, 
                                        за исключением следующих случаев:
                                    </b>
                                    <ul>
                                        <li>
                                            <span class="code">plt.figure()</span>
                                        </li>
                                        <li>
                                            <span class="code">plt.tight_layout()</span>
                                        </li>
                                        <li>
                                            <span class="code">plt.show()</span>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                            <p>
                                Считается хорошим тоном не использовать неявный импорт типа 
                                "<span class="code">from matplotlib.pyplot import *</span>" или 
                                "<span class="code">from pylab import *</span>". Лучше использовать 
                                явный импорт: "<b class="red">from matplotlib import rcParams as rc</b>". 
                                Также при создании достаточно сложных рисунков не стоит 
                                использовать интерфейс pyplot. Он хорош для ознакомления 
                                и быстрой визуализации черновиков. Но для создания high quality plots, 
                                которые требуются для полиграфии и при публикациях в научных журналах, 
                                лучше использовать методы axes, а не pyplot.
                            </p>
                            <h4>Круговые и прямоугольные области рисования</h4>
                            <p>
                                Как и Figure, область рисования Axes имеет атрибут patch, 
                                который является прямоугольным (Rectangle) для декартовой 
                                системы координат и круговым (Circle) для полярной системы координат. 
                                Этот patch определяет форму, фон и границы создаваемой области рисования.
                            </p>
                            <button class="accordion">Пример:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">import matplotlib.pyplot as plt<br>import numpy as np<br>x = np.arange(20)<br>y = np.exp(-x)*np.sin(x)<br>fig = plt.figure()<br># Обычный график в декартовых координатах<br>ax = fig.add_subplot(121, polar=False)<br>ax.plot(x, y, 'r')<br>rect = ax.patch <br>rect.set_facecolor('green')<br>ax.grid(True)<br># График в полярных координатах<br>ax2 = fig.add_subplot(122, polar=True)<br>ax2.plot(x, y, 'g')<br>rect = ax2.patch  # Круговой<br>rect.set_facecolor('red')<br><br>plt.show()</pre>
                                </p>
                                <img src="img/matplotlib/p_7/figure_5.png" class="image" height="200" alt="lorem">
                            </div>
                            <h4>Методы области рисования Axes</h4>
                            <p>
                                Все графические команды, применимые для интерфейса pyplot, 
                                применимы и для Axes. Разница заключается лишь в том, 
                                что вызывать их нужно не от plt (matplotlib.pyplot), 
                                а от экземпляра типа Axes или AxesSubplot.
                            </p>
                            <p>
                                C методами настройки посложнее: почти все функции имеют аналоги, 
                                но бывают синтаксические различия. Например, чтобы сделать 
                                подпись оси ординат в интерфейсе pyplot мы использовали метод plt.ylabel(). 
                                Для экземпляра области рисования ax подобный метод 
                                вызывается через метод <b class="red">ax.set_xlabel()</b>.
                            </p>
                            <p><b class="red">SET & GET</b></p>
                            <p>
                                Вообще говоря, в matplotlib при работе с 
                                различными свойствами элементов рисунка 
                                поддерживается система "set-get". Её суть состоит в том, 
                                что если нужно получить текущее значение атрибута или 
                                свойства объекта, то нужно вызвать его с помощью соответствующей 
                                команды-функции с приставкой "<b class="red">get_</b>". Например, чтобы получить список, 
                                состоящий из положений главных делений на оси абсцисс 
                                из области рисования ax, то нужно указать.
                            </p>
                            <p><span class="code">current_xticks = ax.get_xticks()</span></p>
                            <p>
                                А чтобы изменить этот список на пользовательский, 
                                нужно вызвать аналогичную команду, но с приставкой 
                                "<b class="red">set_</b>". В случае с делениями оси 
                                абсцисс это выглядит так:
                            </p>
                            <p><span class="code">new_xticks = ax.set_xticks(custom_xticks)</span></p>
                            <p>
                                Существует множество вспомогательных методов 
                                Axes для создания и изменения свойств элементов рисунков 
                                и графических примитивов, то есть множество 
                                графических команд. Всё, что доступно для pyplot, 
                                доступно и для axes-экземпляров. 
                                Далее приводятся некоторые из них:
                            </p>
                            <hr>
                            <p><b class="red">Вспомогательный метод -> Описание -> Artist -> Контейнер</b></p>
                            <hr>
                            <ul>
                                <li><b class="red">ax.annotate -> текстовая подпись -> Annotate -> ax.texts</b></li>
                                <li><b class="red">ax.text -> текст -> Text -> ax.texts</b></li>
                                <li><b class="red">ax.bar -> столбчатая диаграмма -> Rectangle -> ax.patches</b></li>
                                <li><b class="red">ax.errorbar -> график погрешностей -> Line2D и Rectangle -> ax.lines и ax.patches</b></li>
                                <li><b class="red">ax.fill -> заливка области -> Polygon -> ax.patches</b></li>
                                <li><b class="red">ax.hist -> гистограмма -> Rectangle -> ax.patches</b></li>
                                <li><b class="red">ax.imshow -> изображение -> AxesImage -> ax.images</b></li>
                                <li><b class="red">ax.legend -> легенда -> Legend -> ax.legends</b></li>
                                <li><b class="red">ax.plot -> XY график -> Line2D -> ax.lines</b></li>
                                <li><b class="red">ax.scatter -> точечная диаграмма -> PolygonCollection -> ax.collections</b></li>
                            </ul>
                            <button class="accordion">Пример:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">x = np.arange(10)<br>y = np.arange(-1, -11, -1)<br>fig = plt.figure()<br>ax = fig.add_subplot(211)<br>line = ax.plot(x, y, '-', color='blue', linewidth=2)<br>print('Lines:', type(line), line)<br># Изменяем цвет подписей делений оси <br>#OX с помощью "set-get" технологии<br><br>for label in ax.get_xticklabels():<br>    label.set_color('orange')<br><br>ax2 = fig.add_subplot(212)<br>n, bins, rectangles = ax2.hist(np.random.randn(1000),<br>        bins=50, facecolor='yellow')<br>print('Patches:', len(ax2.patches), rectangles)<br><br>for ax in fig.axes:<br>    ax.grid(True)<br><br>plt.show()</pre>
                                </p>
                                <img src="img/matplotlib/p_7/figure_6.png" class="image" height="200" alt="lorem">
                            </div>
                            <p>
                                При создании того или иного графического объекта на текущей 
                                области рисования он добавляется в соответствующий его типу контейнер. 
                                Ниже представлен краткий список таких Artists-контейнеров, которые есть у Axes.
                            </p>
                            <hr>
                            <p><b class="red">Axes атрибут - Описание</b></p>
                            <hr>
                            <ul>
                                <li><b class="red">patch</b> - экземпляр Rectangle для фона (background) Axes;</li>
                                <li><b class="red">artists</b> - список экземпляров Artist;</li>
                                <li><b class="red">collections</b> - список экземпляров Collection;</li>
                                <li><b class="red">images</b> - список экземпляров AxesImage;</li>
                                <li><b class="red">legends</b> - список экземпляров Legend;</li>
                                <li><b class="red">lines</b> - список экземпляров Line2D;</li>
                                <li><b class="red">patches</b> - список экземпляров Patch;</li>
                                <li><b class="red">texts</b> - список экземпляров Text;</li>
                                <li><b class="red">xaxis</b> - экземпляр matplotlib.axis.XAxis;</li>
                                <li><b class="red">yaxis</b> - экземпляр matplotlib.axis.YAxis;</li>
                            </ul>
                            <p>
                                XAxis и YAxis являются очень важными Artist-контейнерами. 
                                Через обращение к ним можно изменять свойства отрисовки делений 
                                (ticks) и подписей (labels) координатных осей. Например, 
                                с их помощью можно изменить размер шрифта подписей делений 
                                оси абсцисс XAxis с помощью вспомогательных методов Axes.
                            </p>
                            <button class="accordion">Пример:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">import matplotlib.pyplot as plt<br>import numpy as np<br><br>x = np.arange(10)<br>y = np.arange(-1, -11, -1)<br><br>fig = plt.figure()<br>ax = fig.add_subplot(211)<br>line = ax.plot(x, y, '-', color='blue', linewidth=2)<br>print('Lines:', type(line), line)<br><br># Изменяем цвет подписей делений оси<br>#OX с помощью работы с контейнером XAxis<br>for label in ax.xaxis.get_ticklabels():<br>    label.set_color('red')<br>    label.set_rotation(-45)<br>    label.set_fontsize(12)<br><br>ax2 = fig.add_subplot(212)<br>n, bins, rectangles = ax2.hist(np.random.randn(1000),<br>        bins=50, facecolor='yellow')<br>print('Patches:', len(ax2.patches), rectangles)<br><br>for axes in fig.axes:<br>    axes.grid(True)<br><br>plt.show()</pre>
                                </p>
                                <img src="img/matplotlib/p_7/figure_7.png" class="image" height="200" alt="lorem">
                            </div>
                            <p>
                                В настройках matplotlib у области рисования Axes имеется несколько 
                                атрибутов, которые заданы по умолчанию. Именно эти параметры 
                                определяют свойства графических элементов 
                                (цвет линии, наличие вспомогательной сетки grid, 
                                цвет и размер шрифта подписей координатных осей) 
                                для каждого вновь созданного тем или иным способом экземпляра Axes.
                            </p>
                            <ul>
                                <li><b class="red">u'axes.edgecolor': u'k'</b></li>
                                <li><b class="red">u'axes.facecolor': (1, 1, 1, 0)</b></li>
                                <li><b class="red">u'axes.formatter.limits': [-7, 7]</b></li>
                                <li><b class="red">u'axes.formatter.use_locale': False</b></li>
                                <li><b class="red">u'axes.formatter.use_mathtext': False</b></li>
                                <li><b class="red">u'axes.formatter.useoffset': True</b></li>
                                <li><b class="red">u'axes.grid': False</b></li>
                                <li><b class="red">u'axes.grid.which': u'major'</b></li>
                                <li><b class="red">u'axes.hold': True</b></li>
                                <li><b class="red">u'axes.labelcolor': u'k'</b></li>
                                <li><b class="red">u'axes.labelsize': u'medium'</b></li>
                                <li><b class="red">u'axes.labelweight': u'normal'</b></li>
                                <li><b class="red">u'axes.linewidth': 1.0</b></li>
                                <li><b class="red">u'axes.titlesize': u'large'</b></li>
                                <li><b class="red">u'axes.titleweight': u'normal'</b></li>
                                <li><b class="red">u'axes.unicode_minus': True</b></li>
                                <li><b class="red">u'axes.xmargin': 0.0</b></li>
                                <li><b class="red">u'axes.ymargin': 0.0</b></li>
                            </ul>
                            <p>
                                Изменяя значения их непосредственно в файле matplotlibrc 
                                или по ходу программы с помощью rcParams, можно добиться 
                                пользовательской настройки шрифтов, цвета и других параметров 
                                области рисования axes. Описанные выше свойства применяются 
                                ко всем вновь созданным экземплярам типа Axes. Очевидно, 
                                что разные области рисования могут иметь разные параметры 
                                в рамках одного рисунка.
                            </p>
                            <button class="accordion">Пример:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">import matplotlib.pyplot as plt<br>import numpy as np<br>from matplotlib import rcParams<br><br>rcParams['axes.grid'] = True<br>rcParams['axes.facecolor'] = 'orange'<br>rcParams['axes.labelcolor'] = 'red'<br>rcParams['axes.labelsize'] = 'large'<br>rcParams['axes.labelweight'] = 'bold'<br><br>k = 0.1<br>b = -0.7<br><br>x = np.arange(10)<br>y = k*x + b<br><br>fig = plt.figure()<br><br>ax = fig.add_subplot(111)<br>ax.barh(x, y)<br>ax.set_xlabel(u'Ось абсцисс')<br>ax.set_ylabel(u'Ось ординат')<br>ax.grid(True)<br><br>plt.show()</pre>
                                </p>
                                <img src="img/matplotlib/p_7/figure_8.png" class="image" height="200" alt="lorem">
                            </div>
                        </div>
                        <h3 id="15.8">15.8 Мультиоконные рисунки:</h3>
                        <div class="text-in-card">
                            <h4>Методы создания мультиокон</h4>
                            <p>
                                В matplotlib реализовано несколько спобов создания 
                                рисунков с несколькими областями для диаграмм (multi-panel plots):
                            </p>
                            <ul>
                                <li>
                                    <b class="red">fig.add_axes()</b> - базовый метод, 
                                    удобен при создании диаграммы-врезки;
                                </li>
                                <li>
                                    <b class="red">fig.add_subplot()</b> - добавление одного subplot на рисунок. 
                                    Удобно для отображения 2-3 диаграмм;
                                </li>
                                <li>
                                    <b class="red">plt.subplot()</b> - аналогичный предыдущему по результату метод для pyplot;
                                </li>
                                <li>
                                    <b class="red">plt.subplots()</b> - удобный метод для 
                                    автоматизированного создания нескольких subplots;
                                </li>
                                <li>
                                    <b class="red">plt.GridSpec()</b> - метод для объединения ячеек subplots в 
                                    более сложные конфигурации. Позволяет создавать разные по 
                                    форме subplots на рисунке;
                                </li>
                            </ul>
                            <p>
                                Первые два метода (с приставкой <b class="red">add_</B>) являются более низкоуровнемыми, 
                                и для их вызова требуется объект Figure. Последние три метода 
                                реализованы в pyplot интерфейсе. Каждый из этих методов создаёт 
                                один или более экземпляров типа subplot или axes. 
                                Хотя метод <b class="red">fig.add_axes</b> создаёт объект типа Axes, а все остальные - 
                                типа AxesSubplot, то есть разные типы объектов, они являются родственными, 
                                и работать с ними можно одними и теми же методами.
                            </p>
                            <p>
                                Самым простым способом разбить, то есть поделить, 
                                рисунок на несколько частей является способ 
                                <b class="red">fig.add_subplot()</b>. Смысл создания 
                                subplots состоит в том, что они наполняют рисунок ячейками 
                                (как в таблице) в каждой из которой теперь можно создавать 
                                свой собственный график или диаграмму (или карту-схему).
                            </p>
                            <p>
                                Метод <b class="red">fig.add_subplot()</b> всегда имеет три обязательных аргумента: 
                                число ячеек по вертикали (число строк), число ячеек по 
                                горизонтали (число столбцов) и номер ячейки 
                                (отсчёт ведётся от 1 слева направо, сверху вниз). 
                                Три числа перечисленные через запятую (3,2,5) или 
                                триплет в виде одного числа (325), переданные методу 
                                fig.add_subplot(), создают экземпляр (instance) 
                                "<b class="red">matplotlib.axes._subplots.AxesSubplot</b>", что является подвидом 
                                более широкого класса "<b class="red">matplotlib.axes</b>".
                            </p>
                            <p>
                                <b class="red">fig.add_subplot()</b> оптимален, когда необходимо быстро изобразить 
                                несколько (обычно 2-3) графиков-диаграмм рядом. 
                                Желательно при этом, чтобы они не перекрывались, 
                                за исключением случаев, когда области рисунка 
                                "слипаются" и образуют общие границы 
                                (как по оси абсцисс, так и по оси ординат).
                            </p>
                            <button class="accordion">Пример:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">import matplotlib.pyplot as plt<br><br>fig = plt.figure()<br><br>tri = 211<br>ax1 = fig.add_subplot(tri)<br>ax1.set_title(u'Область 1')<br>ax2 = fig.add_subplot(2, 1, 2)<br>ax2.set_title(u'Область 2')<br><br># Узнаём координаты областей, которые занимают subplots<br>print(u'Область 1', ax1)<br>print(type(ax1))<br>print(u'Область 2',ax2)<br><br># Нарисуем в каждом subplot линию сетки<br>for ax in fig.axes:<br>    ax.grid(True)<br><br>plt.show()</pre>
                                </p>
                                <p>
                                    Область 1 AxesSubplot(0.125,0.536818;0.775x0.343182)
                                    <class 'matplotlib.axes._subplots.AxesSubplot'>
                                    Область 2 AxesSubplot(0.125,0.125;0.775x0.343182)
                                </p>
                                <img src="img/matplotlib/p_8/figure_1.png" class="image" height="200" alt="lorem">
                            </div>
                            <p>
                                Аналогичного результата можно добиться и "в лоб", 
                                то есть самостоятельно задать границы нужных областей. 
                                Для прямого выделения положения областей на рисунке 
                                нужно использовать метод <b class="red">fig.add_axes()</b>. 
                                На рисунке в относительных координатах (от 0 до 1) 
                                можно задать несколько (сколько угодно) областей, 
                                на каждой из которых можно будет рисовать графики и 
                                диаграммы (не забываем про карты и изображения-фотографии). 
                                Каждая область задаётся отдельно и требует указать параметры 
                                границы в виде списка [левая, нижняя, ширина, высота]. 
                                Стоит отметить, что этот метод позволяет задать многие 
                                важные настройки создаваемой области рисования и в частности 
                                тип области рисования (если параметр <b class="red">polar=True</b> или 
                                <b class="red">projection='polar'</b>, то область рисования будет 
                                не прямоугольной, а круговой).
                            </p>
                            <button class="accordion">Пример:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">import matplotlib.pyplot as plt<br><br>fig = plt.figure()<br><br># В примере для задания границ<br>#областей была использована информация<br># о границах subplots из предыдущего примера<br><br>ax1 = fig.add_axes([0.125, 0.547727,<br>        0.775, 0.352273])<br>ax1.set_title(u'Область 1')<br>ax2 = fig.add_axes([0.125, 0.125, 0.775, 0.352273])<br>ax2.set_title(u'Область 2')<br><br># Узнаём координаты областей, которые занимают subplots<br>print(u'Область 1', ax1)<br>print(type(ax1))<br>print(u'Область 2',ax2)<br><br># Нарисуем в каждом subplot линию сетки<br>for ax in fig.axes:<br>    ax.grid(True)<br><br>plt.show()</pre>
                                </p>
                                <p>
                                    Область 1 Axes(0.125,0.547727;0.775x0.352273)
                                    <class 'matplotlib.axes._axes.Axes'>
                                    Область 2 Axes(0.125,0.125;0.775x0.352273)
                                </p>
                                <img src="img/matplotlib/p_8/figure_1.png" class="image" height="200" alt="lorem">
                            </div>
                            <p>В примерах области ax1 - это экземпляры разных классов:</p>
                            <ul>
                                <li><b class="red">ax1 axes -> matplotlib.axes._axes.Axes</b></li>
                                <li><b class="red">ax1 subplots -> matplotlib.axes._subplots.AxesSubplot</b></li>
                            </ul>
                            <p>
                                Если вы хотите изменить размер и размещение 
                                экземпляра subplot после того, как он был создан, 
                                то можно использовать метод ax.set_position().
                            </p>
                            <ul>
                                <li><b class="red">Пример: ax.set_position([0.1,0.1, 0.5, 0.5])</b></li>
                            </ul>
                            <h4>Близкое расположение областей рисования</h4>
                            <p>
                                Если создавать области рисования с помощью метода <b class="red">fig.add_axes()</b>, 
                                то созданные области, которые имеют общее место на рисунке, 
                                будут перекрывать друг друга.
                            </p>
                            <p>
                                Вновь создавамая область рисования типа subplot 
                                вписывается в рисунок в границах, определяемых 
                                соответствующими параметрами rcParams:
                            </p>
                            <ul>
                                <li><b class="red">rcParams['figure.subplot.left'] = 0.125</b> - левая граница</li>
                                <li><b class="red">rcParams['figure.subplot.right'] = 0.9</b> - правая граница</li>
                                <li><b class="red">rcParams['figure.subplot.bottom'] = 0.125</b> - нижняя граница</li>
                                <li><b class="red">rcParams['figure.subplot.top'] = 0.9</b> - верхняя граница</li>
                            </ul>
                            <p>
                                При использования методов <b class="red">fig.add_subplot()</b> 
                                или <b class="red">plt.subplots()</b> 
                                по умолчанию оставляется некоторое свободное пространство 
                                между создаваемыми областями. Изменяя размер 
                                этих "буферов" с помощью соответствующих 
                                параметров настройки rcParams, можно добиться 
                                эффекта соединения или склейки.
                            </p>
                            <ul>
                                <li>
                                    <b class="red">rcParams['figure.subplot.hspace'] = 0.2</b> 
                                    - определяет совокупное вертикальное расстояние между subplots;
                                </li>
                                <li>
                                    <b class="red">rcParams['figure.subplot.wspace'] = 0.2</b> 
                                    - определяет совокупное горизонтальное расстояние между subplots;
                                </li>
                            </ul>
                            <p>
                                Для аналогичной настройки можно воспользоваться методом 
                                pyplot <b class="red">plt.tight_layout()</b>. Данный метод позволяет 
                                "навести красоту" одной строчкой. Часто это очень 
                                экономит время от "вылизывания" пустяковых графиков 
                                до приличного вида. Метод имеет четыре параметра:
                            </p>
                            <ul>
                                <li>
                                    <b class="red">pad</b> - расстояние между краями рисунка Figure 
                                    и краями subplots, выраженное в виде доли fontsize;
                                </li>
                                <li>
                                    <b class="red">h_pad</b> - совокупное расстояние по вертикали 
                                    между subplots. По умолчанию имеет значения 
                                    pad_inches (rcParams['savefig.pad_inches']);
                                </li>
                                <li>
                                    <b class="red">w_pad</b> - расстояние по горизонтали между 
                                    краями соседних subplots. По умолчанию имеет 
                                    значения pad_inches (rcParams['savefig.pad_inches']);
                                </li>
                                <li>
                                    <b class="red">rect</b> - если задан, то это прямоугольник 
                                    (левый, низ, правый, верх) в относительных 
                                    координатах figure, в который будут вписаны 
                                    все области subplots (включая подписи). 
                                    По умолчанию (0, 0, 1, 1);
                                </li>
                            </ul>
                            <p>
                                В совокупности нижние четыре параметра - 
                                это те же самые параметры, которые используются 
                                в качестве входящих для параметра rect в 
                                методе <b class="red">plt.tight_layout()</b>. Данным методом 
                                можно определять взаимное (не но отдельное) 
                                положение subplots и сдвигать их, как отдаляя 
                                их друг от друга, так и сближая 
                                (отрицательные значения h_pad и w_pad).
                            </p>
                            <button class="accordion">Пример №1:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">import matplotlib.pyplot as plt<br><br>fig = plt.figure()<br><br>ax1 = fig.add_subplot(211)<br>ax1.set_title(u'Две области слиплись')<br>ax2 = fig.add_subplot(212)<br><br># Чтобы подписи осей координатных<br>#сеток не сливались разнесём их<br># в разные стороны - одну оставим слева,<br>#а другую вынесем направо<br>ax1.tick_params(axis='x', labelbottom=False,<br>        labeltop=False, top=True, bottom=False)<br>ax2.tick_params(axis='y', labelleft=False,<br>        labelright=True, left=False, right=True)<br># Узнаём координаты областей, которые занимают subplots<br>print(u'Область 1', ax1)<br>print(type(ax1))<br>print(u'Область 2',ax2)<br><br># Нарисуем в каждом subplot линию сетки<br>for ax in fig.axes:<br>    ax.grid(True)<br><br># Параметр подобран эмпирически, на глаз. Это скверно<br>plt.tight_layout(h_pad = -1.)<br><br>plt.show()</pre>
                                </p>
                                <p>
                                    Область 1 AxesSubplot(0.125,0.536818;0.775x0.343182)
                                    <class 'matplotlib.axes._subplots.AxesSubplot'>
                                    Область 2 AxesSubplot(0.125,0.125;0.775x0.343182)
                                </p>
                                <img src="img/matplotlib/p_8/figure_2.png" class="image" height="200" alt="lorem">
                            </div>
                            <button class="accordion">Пример №2:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">import matplotlib.pyplot as plt<br>import numpy as np<br><br>fig = plt.figure()<br><br>N = 100<br>x = np.arange(N)<br>y = np.random.random(N)*30.<br><br># Область ax1 нарисуется первой<br>ax1 = fig.add_axes([0.,0.,1.0,1.0])<br># Область ax2 перекроет область ax1 и закроет её часть<br>ax2 = fig.add_axes([0.5,0.5,0.5,0.5])<br><br>rect0 = [0.0, 0.0]<br><br>ax1.plot(rect0, 'r')<br>ax1.plot(x, y, 'green')<br><br>ax2.plot(rect0, 'c')<br>ax2.hist(y, 20, edgecolor='k', facecolor='r')<br>ax2.tick_params(axis='y', which='major', direction='inout',<br>        left=True, right=True, labelleft=False, labelright=True)<br>ax2.tick_params(axis='x', which='major', direction='inout',<br>        bottom=True, top=True, labelbottom=False, labeltop=True)<br><br>print(u'Область 1', ax1)<br>print(type(ax1))<br>print(u'Область 2',ax2)<br><br>for ax in fig.axes:<br>    ax.grid(True)<br><br>plt.show()</pre>
                                </p>
                                <p>
                                    Область 1 Axes(0,0;1x1)
                                    <class 'matplotlib.axes._axes.Axes'>
                                    Область 2 Axes(0.5,0.5;0.5x0.5)
                                </p>
                                <img src="img/matplotlib/p_8/figure_3.png" class="image" height="200" alt="lorem">
                            </div>
                            <h4>Автоматизированное создание мультиокон</h4>
                            <p>
                                Для создания множества областей удобно не 
                                просто добавлять их на рисунок последовательно, 
                                по одному, а всего одной строчкой разбить 
                                рисунок на несколько областей рисования. 
                                Это позволяет сделать, например, метод 
                                <b class="red">plt.subplots()</b>, который требует указать 
                                число строк и столбцов создаваемой таблицы 
                                каждая из ячеек которой и есть объект-экземпляр 
                                subplots. Метод возвращает объект типа 
                                figure и массив из созданных subplots. Их можно 
                                перебрать в цикле "в лоб", но лучше пользоваться 
                                перебором из списка <b class="red">fig.axes</b>, куда автоматически 
                                добавляются все области рисования текущего рисунка fig.
                            </p>
                            <button class="accordion">Пример:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">import numpy as np<br>import matplotlib.pyplot as plt<br><br>fig, subplots = plt.subplots(nrows=2,<br>        ncols=2, sharex=True, sharey=True)<br><br>x = np.arange(20)<br><br>i = -1<br>for ax in fig.axes:<br>    i += 1<br>    y = np.random.rand(np.size(x))<br>    ax.grid(True)<br>    ax.text(0.5, 0.9, str(i+1), color='red')<br>    ax.plot(x, y)<br>    if((i+1)%2 == 0):<br>        ax.tick_params(axis='y',<br>                labelleft=False,<br>                labelright=True,<br>                left=False,<br>                right=True)<br>    if((i==0) or (i==1)):<br>        ax.tick_params(axis='x',<br>                labelbottom=False,<br>                labeltop=False,<br>                left=False,<br>                right=True)<br>    if((i==1) or (i==2)):<br>        ax.tick_params(axis='y',<br>                labelleft=False,<br>                labelright=False,<br>                left=False,<br>                right=False)<br>    if(i==3):<br>        ax.tick_params(axis='x',<br>                labelbottom=False,<br>                labeltop=False)<br>    if(i==1):<br>        ax.tick_params(axis='x',<br>                labelbottom=False,<br>                labeltop=True)<br>    if(i==0):<br>        ax.tick_params(axis='y',<br>                left=True,<br>                right=False)<br><br># Параметры подобраны эмпирически, на глаз<br>plt.tight_layout(h_pad = 1, w_pad = 1)<br><br>plt.show()</pre>
                                </p>
                                <img src="img/matplotlib/p_8/figure_4.png" class="image" height="200" alt="lorem">
                            </div>
                            <h4>Мультиокна разных размеров. Gridspec</h4>
                            <p>
                                Методы <b class="red">fig.add_subplot()</b> и <b class="red">plt.subplots()</b> 
                                позволяют разбить рисунок на равные по размерам 
                                области и в этом состоит одно из их основных преимуществ. 
                                Оъединить ячейки subplots в более сложные конструкции 
                                позволяет метод <b class="red">plt.subplot2grid()</b>, который 
                                также именуется как метод Gridspec.
                            </p>
                            <p>
                                Создание ячеек осуществляется при помощи метода 
                                <b class="red">subplot2grid()</b>, которому необходимо задать 
                                число строк и столбцов в виде кортежа, а также 
                                расположение ячеек в виде кортежа номеров от 0 
                                до максимального числа ячеек N-1. То есть для 
                                создания таблицы 2x2 нужно задать размер (2,2) 
                                и расположение в пределах от (0,0) до (1,1).
                            </p>
                            <button class="accordion">Пример №1:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">import matplotlib.pyplot as plt<br>import matplotlib.gridspec as gridspec<br><br># 3,3 - три столбца и три ячейки<br>ax = plt.subplot2grid((3, 1), (0, 0))<br><br>print(type(ax))<br><br># это запись эквивалентна более детальной записи<br>gs = gridspec.GridSpec(3, 1)<br>ax = plt.subplot(gs[0, 0])<br>ax.grid(True)<br># Положение текста задано в относительных координатах<br>ax.text(0.3, 0.5, u'Метод Gridspec', <br>        fontsize=14, transform=ax.transAxes)<br><br>plt.show()</pre>
                                </p>
                                <img src="img/matplotlib/p_8/figure_5.png" class="image" alt="lorem">
                            </div>
                            <button class="accordion">Пример №2:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">import matplotlib.pyplot as plt<br>import matplotlib.gridspec as gridspec<br><br>fig = plt.figure()<br><br>ax1 = plt.subplot2grid((2,2), (0, 0))<br>ax2 = plt.subplot2grid((2,2), (0, 1))<br>ax3 = plt.subplot2grid((2,2), (1, 0))<br>ax4 = plt.subplot2grid((2,2), (1, 1))<br><br>i = -1<br>jj = [0, 0, 1, 1]<br>kk = [0, 1, 0, 1]<br>for ax in fig.axes:<br>    i += 1<br>    stext = 'ax%d - %d, %d' % (i+1, jj[i], kk[i])<br>    ax.text(0.4, 0.5, stext, color='b')<br>    ax.grid(True)<br><br>plt.show()<br></pre>
                                </p>
                                <img src="img/matplotlib/p_8/figure_6.png" height="200" class="image" alt="lorem">
                            </div>
                            <p>
                                Главным преимуществом данного метода является то, 
                                что получаемые subplots могут быть разных форм и 
                                размеров. При этом конфигурация задаётся 
                                в виде объединения ячеек, а не через указание 
                                явных границ, как это можно было бы сделать 
                                с помощью метода <b class="red">ax.add_axes()</b>.
                            </p>
                            <p>
                                Для объединения ячеек при создании 
                                таблицы-сетки нужно добавить следующие 
                                параметры в метод <b class="red">subplot2grid</b>:
                            </p>
                            <ul>
                                <li><b class="red">colspan</b> - объединить столбы;</li>
                                <li><b class="red">rowspan</b> - объединить строки;</li>
                            </ul>
                            <p>
                                Значение соответствующих параметров показывает 
                                сколько ячеек сетки объединить. Причём отсчёт 
                                ведётся от точки локализации ячейки включая её. 
                                Если нужно объединить и столбцы и строки, то 
                                указываются оба параметра одновременно.
                            </p>
                            <button class="accordion">Пример №1:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">import matplotlib.pyplot as plt<br>import matplotlib.gridspec as gridspec<br><br>fig = plt.figure()<br><br># Сетка состоит из 4 строк и 3 столбцов.<br>#Первая ячейка имеет номер (0,0),<br># а последняя - (3,2)<br>egrid = (4,3)<br>ax1 = plt.subplot2grid(egrid, (0, 0), colspan=3)<br>ax2 = plt.subplot2grid(egrid, (1, 0), rowspan=2)<br>ax3 = plt.subplot2grid(egrid, (1, 1), <br>        rowspan=2, colspan=2)<br>ax4 = plt.subplot2grid(egrid, (3, 0), colspan=2)<br>ax5 = plt.subplot2grid(egrid, (3, 2))<br><br>for i, ax in enumerate(fig.axes):<br>    ax.text(0.5, 0.5, "ax%d" % (i+1), va="center", ha="center", <br>            color='red', transform=ax.transAxes)<br>    ax.grid(True)<br><br># Настройка расстояний между <br>#границами созданных subplots<br>plt.tight_layout()<br><br>plt.show()</pre>
                                </p>
                                <img src="img/matplotlib/p_8/figure_7.png" height="200" class="image" alt="lorem">
                            </div>
                            <button class="accordion">Пример №2:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">import matplotlib.pyplot as plt<br>import matplotlib.gridspec as gridspec<br>from matplotlib import rcParams<br><br># Левая граница subplots на рисунке<br>rcParams['figure.subplot.left'] = 0.1<br># Правая граница subplots на рисунке<br>rcParams['figure.subplot.right'] = 0.95<br># Нижняя граница subplots на рисунке<br>rcParams['figure.subplot.bottom'] = 0.05<br># Верхняя граница subplots на рисунке<br>rcParams['figure.subplot.top'] = 0.95<br><br># Изменение параметров wspace и hspace методом rcParams<br><br># Общая высота (вертикаль), выделенная для свободного<br>#пространства между subplots<br>rcParams['figure.subplot.hspace'] = 0.2<br># Общая ширина (горизонталь), выделенная для<br>#свободного пространства между subplots<br>rcParams['figure.subplot.wspace'] = 0.2<br><br>N = 50<br>x = np.arange(N)<br>y = np.random.rand(np.size(x))<br><br>fig = plt.figure()<br># Сетка состоит из 4 строк и 3 столбцов.<br>#Первая ячейка имеет номер (0,0),<br># а последняя - (3,2)<br>egrid = (4,3)<br>ax1 = plt.subplot2grid(egrid, (0, 0), colspan=3)<br>ax2 = plt.subplot2grid(egrid, (1, 0), rowspan=2)<br>ax3 = plt.subplot2grid(egrid, (1, 1), rowspan=2, colspan=2)<br>ax4 = plt.subplot2grid(egrid, (3, 0), colspan=2)<br>ax5 = plt.subplot2grid(egrid, (3, 2))<br><br>for i, ax in enumerate(fig.axes):<br>        ax.plot(x, y, 'k')<br>        ax.text(0.2, 0.75, "ax%d" % (i+1),<br>                va="center", ha="center",<br>                color='blue', transform=ax.transAxes,<br>                fontsize='large')<br>        ax.grid(True)<br><br># Изменение параметров wspace и<br>#hspace методом fig.subplots_adjust()<br>fig.subplots_adjust(wspace=0.4, hspace=0.4)<br><br>plt.show()</pre>
                                </p>
                                <img src="img/matplotlib/p_8/figure_8.png" height="200" class="image" alt="lorem">
                            </div>
                        </div>
                        <h3 id="15.9">15.9 Координатные оси Axis:</h3>
                        <div class="text-in-card">
                            <p>
                                Axis (не путать с областями рисования Axes) - это третья "матрёшка" 
                                (после Figure и Axes) или контейнер в matplotlib, которая 
                                привязана к области рисования Axes и на которой 
                                располагаются деления осей (ticks), подписи делений 
                                (tick labels) и подписи осей (axis labels). 
                                Координатные оси являются экземплярами класса <b class="red">matplotlib.axis.Axis</b>.
                            </p>
                            <p>
                                Любая область рисования Axes содержит два особых 
                                Artist-контейнера: <b class="red">XAxis</b> и <b class="red">YAxis</b>. 
                                Они отвечают за отрисовку делений (ticks) и подписей (labels) координатных осей, 
                                которые хранятся как экземпляры в переменных xaxis и yaxis. 
                                Чтобы обратиться к экземпляру axis, отвечающему за ось ординат, 
                                нужно обратиться к контейнеру yaxis соответствующей области рисования ax. 
                                Причём запись "<b class="red">yax=ax.get_yaxis()</b>" идентична записи 
                                "<b class="red">yax=ax.yaxis</b>".
                            </p>
                            <p>
                                Каждый экземпляр axis содержит атрибут подписей (label) 
                                координатной оси и список главных (major ticks) 
                                и вспомогательных (minor ticks) делений, 
                                а также является хранилищем для экземпляров делений (ticks). 
                                Деления - это экземпляры класса <b class="red">matplotlib.axis.Tick</b>, 
                                которые визуализируют деления (их размер, цвет, толщину и т.д.) 
                                и подписи к ним. Деления создаются динамически исходя из 
                                области изменения переданных данных. В результате на 
                                координатной оси появляются и хранятся экземпляры 
                                классов <b class="red">matplotlib.axis.XTick</b> и 
                                <b class="red">matplotlib.axis.YTick</b>.
                            </p>
                            <button class="accordion">Пример:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">import matplotlib.pyplot as plt<br>import numpy as np<br><br>fig = plt.figure()<br>ax = fig.add_subplot(111)<br>x = np.arange(100)<br>y = -np.exp(-0.3*x) + 2.33<br>ax.plot(x, y, 'k')<br>xax = ax.xaxis<br># или xax = ax.get_xaxis()<br><br>xlocs = xax.get_ticklocs()<br>print ('Major X-ticks locations:', xlocs)<br>xlabels = xax.get_ticklabels()<br>print ('Major X-ticks labels:', xlabels)<br>xlines = xax.get_ticklines()<br>print ('Major X-ticks tick lines:', xlines)<br><br># Линии вспомогательной сетки (главные деления)<br>#только по оси абсцисс<br>xax.grid(True)<br><br>for label in xlabels:<br>    # цвет подписи деленений оси OX<br>    label.set_color('blue')<br>    # поворот подписей деленений оси OX<br>    label.set_rotation(45)<br>    # размер шрифта подписей делений оси OX<br>    label.set_fontsize(14)<br><br>plt.show()</pre>
                                </p>
                                <img src="img/matplotlib/p_9/figure_1.png" class="image" height="200" alt="lorem">
                            </div>
                            <h4>Главные и вспомогательные деления</h4>
                            <p>
                                В matplotlib деления на координатной оси могут быть 
                                <b class="red">главными (major ticks)</b> 
                                или <b class="red">вспомогательными (minor ticks)</b>. 
                                По умолчанию наносятся главные деления, к ним привязывается 
                                нанесение вспомогательной сетки grid, за которую отвечает параметр 
                                <b class="red">axes.grid.which': u'major' из rcParams</b>. 
                                Работа со вспомогательными делениями ничем не отличается от работы 
                                с главными делениями: используются те же методы, но явно указывается 
                                тип делений через определённый атрибут. 
                                Обычно этот атрибут называется 
                                <b class="red">which (принимает значения 'major'/'minor') или булевый атрибут minor</b>.
                            </p>
                            <p>
                                Ниже представлен список некоторых методов Axis. 
                                Они применяются к экземплярам xaxis или yaxis. 
                                Так как при работе с атрибутами поддерживается идеология "<b class="red">set-get</b>", 
                                то списке указаны методы только с приставкой "<b class="red">set_</b>". 
                                Для получения значений атрибутов какой-либо характеристики, 
                                нужно в методе заменить приставку "<b class="red">set</b>" на "<b class="red">get</b>": 
                                <b class="red">set_scale -> get_scale; get_data_interval -> set_data_interval</b> 
                                и так далее.
                            </p>
                            <hr>
                            <p><b class="red">Вспомогательный метод -> Описание</b></p>
                            <hr>
                            <ul>
                                <li>
                                    <b class="red">set_scale</b> -> определяет характер изменений значений на оси: 
                                    линейный 'linear' (по умолчанию) или 'log' логарифмический;
                                </li>
                                <li>
                                    <b class="red">set_view_interval</b> -> 
                                    экземпляр интервала области изменения отображений по оси axis;
                                </li>
                                <li>
                                    <b class="red">set_data_interval</b> -> 
                                    экземпляр интервала области изменения данных по оси axis;
                                </li>
                                <li>
                                    <b class="red">set_gridlines</b> -> список линий сетки для Axis;
                                </li>
                                <li>
                                    <b class="red">set_label</b> -> подпись оси, экземпляр Text;
                                </li>
                                <li>
                                    <b class="red">set_ticklabels</b> -> 
                                    подписи делений, список экземпляров Text. 
                                    Тип делений определяет параметр minor=True/False;
                                </li>
                                <li>
                                    <b class="red">set_ticklines</b> -> 
                                    конфигурация делений, список экземпляров Line2D. 
                                    Тип делений определяет параметр minor=True/False;
                                </li>
                                <li>
                                    <b class="red">set_ticklocs</b> -> 
                                    положение делений. 
                                    Тип делений определяет параметр minor=True/False;
                                </li>
                                <li>
                                    <b class="red">set_major_locator</b> -> 
                                    экземпляр matplotlib.ticker.Locator 
                                    для главных (major) делений;
                                </li>
                                <li>
                                    <b class="red">set_major_formatter</b> -> 
                                    экземпляр matplotlib.ticker.Formatter для главных делений;
                                </li>
                                <li>
                                    <b class="red">set_major_ticks</b> -> список экземпляров Tick для главных делений;
                                </li>
                                <li>
                                    <b class="red">set_minor_locator</b> -> 
                                    экземпляр matplotlib.ticker.Locator 
                                    для вспомгательных (minor) делений;
                                </li>
                                <li>
                                    <b class="red">set_minor_formatter</b> -> 
                                    экземпляр matplotlib.ticker.Formatter 
                                    для вспомогательных делений;
                                </li>
                                <li>
                                    <b class="red">set_minor_ticks</b> -> 
                                    список экземпляров Tick для вспомогательных делений;
                                </li>
                                <li>
                                    <b class="red">grid</b> -> 
                                    определяет будет ли отображаться линии сетки для 
                                    главной или вспомогательных делений 
                                    (параметр which='major'/'minor');
                                </li>
                            </ul>
                            <button class="accordion">Пример:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">fig = plt.figure()<br><br>ax = fig.add_subplot(111)<br>rect = ax.patch<br>rect.set_facecolor('lightslategray')<br>rect.set_alpha(0.25)<br><br>x = np.arange(100)<br>y = np.exp(-0.3*x) + 2.33<br><br>ax.plot(x, y, 'green')<br><br>xax = ax.xaxis   # экземпляр xaxis<br><br>print('Major X-ticks tick lines:',<br>        xax.get_ticklines())<br>print('Major X-ticks location:',<br>        xax.get_ticklocs())<br>print('Major X-ticks labels:',<br>        xax.get_ticklabels())<br><br>print('Major X-ticks tick lines:',<br>        xax.get_ticklines(minor=True))<br>print('Minor X-ticks location:',<br>        xax.get_ticklocs(minor=True))<br>print ('Minor X-ticks labels:',<br>        xax.get_ticklabels(minor=True))<br><br># вспомогательная сетка для главных делений<br>ax.grid(True, which=u'major',<br>                color='w',<br>                linewidth=1.,<br>                linestyle='solid')<br><br># вспомогательная сетка для вспомогательных делений<br>ax.grid(True, which=u'minor', color='b')<br><br># Ось абсцисс<br>for label in ax.xaxis.get_ticklabels():<br>    # label - это экземпляр текста Text<br>    label.set_color('red')<br>    label.set_rotation(-45)<br>    label.set_fontsize(15)<br><br># Ось ориднат<br>for line in ax.yaxis.get_ticklines():<br>    # line - это экземпляр плоской линии Line2D<br>    line.set_color('blue')<br>    # задаём цвет линии деления<br>    line.set_markersize(2)<br>    # задаём длину линии деления<br>    line.set_markeredgewidth(1)<br>    # задаём толщину линии деления<br><br>print ('----------------------------')<br>print (u'Тип изменения оси:', xax.get_scale())<br>print (u'Область изменения отображения данных:',<br>        xax.get_view_interval())<br>print (u'Область изменения отображения данных:',<br>        xax.get_data_interval())<br>print (u'Линии сетки:', xax.get_gridlines())<br>print (u'Подпись оси:', xax.get_label())<br>print (u'Подписи делений:', xax.get_ticklabels())<br>print (u'Линии делений:', xax.get_ticklines())<br>print (u'Расположение делений:',<br>        xax.get_ticklocs())<br>print (u'locator главных делений:',<br>        xax.get_major_locator())<br>print( u'formatter главных делений:',<br>        xax.get_major_formatter())<br>print (u'Список главных делений оси:',<br>        xax.get_major_ticks())<br>print( u'locator вспомогательных делений:',<br>        xax.get_minor_locator())<br>print(u'formatter вспомогательных делений:',<br>        xax.get_minor_formatter())<br>print(u'Список вспомогательных делений оси:',<br>        xax.get_minor_ticks())<br>print ('----------------------------')<br><br>plt.show()<br></pre>
                                </p>
                                <img src="img/matplotlib/p_9/figure_2.png" class="image" height="200" alt="lorem">
                            </div>
                            <h4>Настройка координатной оси</h4>
                            <p>
                                Одним из способов привести координатную ось 
                                в нужный пользователю вид заключается 
                                в применении методов "set-get" для объектов типа Axes:
                            </p>
                            <ul>
                                <li>
                                    <b class="red">ax.get_xticks()</b> - 
                                    получить список местоположения делений 
                                    (по умолчанию главных) на оси абсцисс;
                                </li>
                                <li>
                                    <b class="red">ax.set_xticklabels()</b> - 
                                    задать значения подписей для 
                                    текущего местоположения делений 
                                    (по умолчанию главных) на оси абсцисс;
                                </li>
                                <li>
                                    <b class="red">ax.get_yticks()</b> - 
                                    получить список местоположения делений 
                                    (по умолчанию главных) на оси ординат;
                                </li>
                                <li>
                                    <b class="red">ax.set_yticklabels()</b> - 
                                    задать значения подписей для текущего 
                                    местоположения делений (по умолчанию главных) 
                                    на оси ординат;
                                </li>
                            </ul>
                            <p>
                                Методы <b class="red">\*ticklabels()</b> принимают множество параметров, 
                                с помощью которых, можно настроить внешний вид 
                                (цвет, поворот вокруг оси, шрифт, стиль шрифта и т.д.) 
                                текстовой подписи. Любая подпись - это экземпляр Text 
                                и работать с ним нужно соответствующими методами.
                            </p>
                            <button class="accordion">Пример:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">import matplotlib.pyplot as plt<br>import numpy as np<br><br>x = np.arange(-5, 6)<br>y = np.exp(-0.3*x) + 2.33<br><br>fig = plt.figure()<br>ax1 = fig.add_subplot(211)<br>ax1.plot(x, y)<br>ax1.grid(True)<br><br>ax2 = fig.add_subplot(212)<br>ax2.plot(x, y)<br>ax2.grid(True)<br><br>xticks = ax2.get_xticks()<br>yticks = ax2.get_yticks()<br><br>xx = np.arange(-10, 11, 2)<br>yy = np.arange(0, 11)<br><br>print('Xticks:', xticks)<br>print('Yticks:', yticks)<br><br>xlabels = []<br>ylabels = []<br>for i in xx:<br>xlabels.append('X point %d' % i)<br><br>for j in yy:<br>    ylabels.append('Y point %d' % j)<br><br>ax2.set_xticks(xx)<br>ax2.set_yticks(yy)<br>ax2.set_yticklabels(ylabels, color='green')<br>ax2.set_xticklabels(xlabels,<br>        color='green', rotation=315)<br><br>yticklabels = ax2.get_yticklabels()<br>print('Yticklabels: %s' % type(yticklabels))<br>print('Каждый label - это %s' % (type(yticklabels[0])))<br><br>plt.show()</pre>
                                </p>
                                <img src="img/matplotlib/p_9/figure_3.png" class="image" height="200" alt="lorem">
                            </div>
                            <p>
                                Для облегчения доступа к настройкам делений, 
                                требующим работы непосредственно с экземплярами Ticks, 
                                в matplotlib был сделан метод <b class="red">ax.tick_params</b>, 
                                который позволяет быстро и просто настраивать расположение 
                                и отображение делений координатных осей и их подписей. 
                                Ниже приводится список атрибутов данного метода:
                            </p>
                            <ul>
                                <li>
                                    <b class="red">axis : ['x' | 'y' | 'both']</b> - 
                                    экземпляр Axis на котором находятся деления; по умолчанию 'both';
                                </li>
                                <li>
                                    <b class="red">reset : [True | False]</b> - 
                                    если True, то значения всех параметров 
                                    сбрасываются на значения по умолчанию. 
                                    По умолчанию равен False;
                                </li>
                                <li>
                                    <b class="red">which : ['major' | 'minor' | 'both']</b> - 
                                    определяет принадлежность к типу делений. 
                                    По умолчанию 'major';
                                </li>
                                <li>
                                    <b class="red">direction : ['in' | 'out' | 'inout']</b> - 
                                    определяет направление делений 
                                    (внутрь, вовне или и снаружи и внутри);
                                </li>
                                <li>
                                    <b class="red">length</b> - длина деления в точках (points);
                                </li>
                                <li>
                                    <b class="red">width</b> - ширина деления в точках (points);
                                </li>
                                <li>
                                    <b class="red">color</b> - цвет деления. 
                                    Возможен любой цвет, приемлимый в matplotlib;
                                </li>
                                <li>
                                    <b class="red">pad</b> - расстояние в точках между делением и подписью к нему;
                                </li>
                                <li>
                                    <b class="red">labelsize</b> - размер шрифта подписи деления 
                                    в виде строки (например, 'large') или числа;
                                </li>
                                <li>
                                    <b class="red">labelcolor</b> - цвет подписи деления. Возможен любой цвет, приемлимый в matplotlib;
                                </li>
                                <li>
                                    <b class="red">colors</b> - изменяет цвет деления и цвет подписи 
                                    деления на одно значение. Возможен любой цвет, 
                                    приемлимый в matplotlib;
                                </li>
                                <li>
                                    <b class="red">zorder</b> - zorder деления и подписи деления;
                                </li>
                                <li>
                                    <b class="red">bottom, top, left, right : [bool | 'on' | 'off']</b> - 
                                    каждый из параметров контролирует отображение 
                                    делений на соответствующей оси;
                                </li>
                                <li>
                                    <b class="red">labelbottom, labeltop, labelleft, labelright : [bool | 'on' | 'off']</b> - 
                                    каждый из параметров контролирует отображение подписи делений 
                                    на соответствующей оси;
                                </li>
                            </ul>
                            <p>
                                Правда метод tick_params не имеет параметра rotation. 
                                Чтобы повернуть подписи делений, нужно воспользоваться 
                                иным способом, например указать этот параметр явно через 
                                <b class="red">метод ax.set_xticklabels</b>.
                            </p>
                            <button class="accordion">Пример №1:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">import matplotlib.pyplot as plt<br>import numpy as np<br><br>x = np.arange(-5, 6)<br>y = np.exp(-0.3*x) + 2.33<br><br>fig = plt.figure()<br>ax1 = fig.add_subplot(121)<br>ax1.plot(x, y)<br>ax1.grid(True)<br><br># Настройка оси главных делений для оси абсцисс<br>ax1.tick_params(axis='x', which='major',<br>                direction='inout',<br>                bottom=True, top=False,<br>                left=True, right=False,<br>                color='b', labelcolor='g',<br>                labelbottom=True, labeltop=False,<br>                labelleft=True, labelright=False)<br># Настройка оси главных делений для оси ординат<br>ax1.tick_params(axis='y', which='major',<br>                direction='inout',<br>                bottom=True, top=False,<br>                left=True, right=False,<br>                color='r', labelcolor='pink',<br>                labelbottom=True, labeltop=False,<br>                labelleft=True, labelright=False)<br><br># Метод tick_params не имеет параметра rotation.<br>#Поэтому чтобы повернуть подписи<br># нужно сделать это явно через метод set_xticklabels<br>xticks = ax1.get_xticks()<br>ax1.set_xticklabels(xticks, rotation=45)<br><br>ax2 = fig.add_subplot(122, frameon=False)<br>ax2.plot(x, y)<br>ax2.grid(True)<br><br>ax2.tick_params(axis='x', which='major',<br>                direction='out',<br>                bottom=True, top=True,<br>                left=True, right=True,<br>                color='blue', labelcolor='grey',<br>                labelbottom=True, labeltop=True,<br>                labelleft=True, labelright=True)<br>ax2.tick_params(axis='y', which='minor',<br>                direction='inout',<br>                bottom=True, top=False,<br>                left=True, right=False,<br>                color='r', labelcolor='pink',<br>                labelbottom=True, labeltop=False,<br>                labelleft=True, labelright=False)<br><br>plt.tight_layout()<br>plt.show()</pre>
                                </p>
                                <img src="img/matplotlib/p_9/figure_4.png" class="image" height="200" alt="lorem">
                            </div>
                            <button class="accordion">Пример №2:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">import matplotlib.pyplot as plt<br>import numpy as np<br><br>x = np.arange(-90, 92.5 , 2.5)<br>y = 113.3*np.cos(x*np.pi/180.)<br>z = 113.3*np.sin(x*np.pi/180.)<br><br>fig = plt.figure()<br><br>ax = fig.add_subplot(211)<br>ax.plot(x, y)<br><br>ax.tick_params(axis='x', which='major',<br>               labelleft=False, labelright=False,<br>               labeltop=True, labelbottom=True,<br>               bottom=True, top=True,<br>               direction='in', length=10,<br>               width=4, colors='g')<br><br>old_major = ax.get_xticks()<br>N = 0.25<br>lag = (old_major[1] - old_major[0])*N<br>new_minor = np.arange(old_major[0] +<br>                lag, old_major[-1], 2*lag)<br>ax.set_xticks(new_minor, minor = True)<br><br>ax.tick_params(axis='x', which='minor',<br>               labeltop=True, labelbottom=True,<br>               bottom=True, top=True,<br>               direction='inout', length=5,<br>               width=2, colors='cyan')<br><br>ax.tick_params(axis='y',<br>               labelleft='off', labelright='off',<br>               left=False, right=False)<br><br>ax.grid(True, which='major')<br>ax.grid(True, which='minor')<br><br>ax.yaxis.set_label_position('left')<br>ax.set_ylabel(u'Слева')<br>ax.xaxis.set_label_position('top')<br>ax.set_xlabel(u'Сверху')<br><br># ************************************************<br>ax = fig.add_subplot(212)<br><br>ax.plot(x, y)<br>ax.tick_params(axis='both', reset=True)<br><br>ax.tick_params(axis='y', which='major',<br>               labelleft=True, labelright=True,<br>               left=True, right=True,<br>               direction='out', length=10,<br>               width=1., colors='r')<br><br>old_major = ax.get_yticks()<br>N = 0.25<br>lag = (old_major[1] - old_major[0])*N<br>new_minor = np.arange(old_major[0] + lag, old_major[-1], 2*lag)<br>ax.set_yticks(new_minor, minor = True)<br><br>ax.tick_params(axis='y', which='minor',<br>               labelleft=True, labelright=True,<br>               left=True, right=True,<br>               direction='inout', length=5,<br>               width=1., colors='k')<br><br>ax.tick_params(axis='x',<br>               labeltop=False, labelbottom=False,<br>               bottom=False, top=False)<br><br>ax.yaxis.set_label_position('right')<br>ax.set_ylabel(u'Справа', rotation=270)<br><br>ax.xaxis.set_label_position('bottom')<br>ax.set_xlabel(u'Снизу')<br><br>ax.grid(True, axis='y', which='major', color='red')<br>ax.grid(True, axis='y', which='minor', color='k')<br><br>plt.show()</pre>
                                </p>
                                <img src="img/matplotlib/p_9/figure_5.png" class="image" height="200" alt="lorem">
                            </div>
                        </div>
                        <h3 id="15.10">15.10 Деления координатной оси Ticks:</h3>
                        <div class="text-in-card">
                            <p>
                                Деления (ticks) неотделимы от координатной 
                                оси на которой они находятся. Однако свойства 
                                самих делений (цвет, длина, толщина и др.), 
                                и их подписей (кегль, поворот, цвет шрифта, шрифт и др.), 
                                а также связанные с ними линии вспомогательной сетки grid, 
                                удобно хранить в отдельном хранилище-контейнере Ticks, 
                                а не в контейнере Axis.
                            </p>
                            <h4>Контейнер Ticks</h4>
                            <p>
                                Контейнер <b class="red">matplotlib.axis.Tick</b> - это последний и 
                                самый низкоуровневый из Artists-контейнеров, 
                                самая маленькая "матрёшка". Он содержит экземпляры 
                                делений (ticks), линий вспомогательной сетки 
                                (grid lines) и подписей (labels) для верхних 
                                (upper ticks) и нижних делений (lower ticks). 
                                К каждому из них есть прямой доступ как к 
                                одному из атрибуту экземпляра Tick. Также контейнер 
                                существуют логические переменные с помощью которых 
                                можно определить с какой стороны будут нанесены 
                                подписи и деления: для оси ординат справа/слева, 
                                а для оси абсцисс - сверху/снизу в прямоугольной 
                                системе координат.
                            </p>
                            <p>
                                Для работы непросредственно с экземпляром Tick, 
                                необходимо "спуститься" к нему с более высоких контейнеров-уровней.
                                <br>
                                <b class="red">Axes - Axis(YAxis) - методы "set-get" -> ax.yaxis.get_major_ticks()</b>
                            </p>
                            <p>Для такого объекта определены следующие атрибуты:</p>
                            <hr>
                            <p><b class="red">Атрибут Tick -> Описание</b></p>
                            <hr>
                            <ul>
                                <li>
                                    <b class="red">tick1line</b> - экземпляр Line2D;
                                </li>
                                <li><b class="red">tick2line</b> - экземпляр Line2D;</li>
                                <li><b class="red">gridline</b> - экземпляр Line2D;</li>
                                <li><b class="red">label1</b> - экземпляр Text;</li>
                                <li><b class="red">label2</b> - экземпляр Text;</li>
                                <li>
                                    <b class="red">gridOn</b> - 
                                    логическая переменная, разрешающая рисовать tickline;
                                </li>
                                <li>
                                    <b class="red">tick1On</b> - 
                                    логическая переменная, разрешающая рисовать первую tickline;
                                </li>
                                <li>
                                    <b class="red">tick2On</b> - логическая переменная, разрешающая рисовать вторую tickline;
                                </li>
                                <li>
                                    <b class="red">label1On</b> - 
                                    логическая переменная, разрешающая рисовать tick label;
                                </li>
                                <li>
                                    <b class="red">label2On</b> - 
                                    логическая переменная, разрешающая рисовать tick label;
                                </li>
                            </ul>
                            <p>
                                Атрибуты с номером 1 - это стандартно 
                                отображаемые деления, которые располагаются слева и/или снизу.
                            </p>
                            <p>
                                Атрибуты с номером 2 - соответственно справа и/или снизу.
                            </p>
                            <button class="accordion">Пример:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">import numpy as np<br>import matplotlib as mpl<br>import matplotlib.pyplot as plt<br><br>fig = plt.figure()<br>ax = fig.add_subplot(111)<br><br>rect = ax.patch<br>rect.set_facecolor('k')<br><br>N = 31<br>x = np.arange(N)<br>y = 100*np.random.rand(N)<br><br>ax.plot(x, y, color='red', linewidth=2.0)<br><br>formatter = mpl.ticker.FormatStrFormatter(u'%.2f руб.')<br>ax.yaxis.set_major_formatter(formatter)<br><br>for tick in ax.yaxis.get_major_ticks():<br>    print('Major ticks on Y-axis %s' % type(tick))<br>    tick.label1On = True<br>    tick.label1.set_color('green')<br>    tick.label2On = True<br>    tick.label2.set_color('blue')<br>    # серые деления на оси ОY слева<br>    tick.tick1line.set_color('grey')<br>    tick.tick1line.set_markeredgewidth(2)<br>    tick.tick1line.set_markersize(1)<br>    # линии вспомогательной сетки для оси OX<br>    tick.gridOn = True<br>    tick.gridline.set_color('white')<br>    tick.gridline.set_linewidth(1)<br><br>for tick in ax.xaxis.get_major_ticks():<br>    print('Major ticks on X-axis %s' % type(tick))<br>    tick.label1On = True<br>    tick.label1.set_color('red')<br>    tick.label2On = True<br>    tick.label2.set_color('orange')<br>    # розовые деления на оси ОX сверху<br>    tick.tick2line.set_color('pink')<br>    tick.tick2line.set_markeredgewidth(20)<br>    tick.tick2line.set_markersize(250)<br>    # линии вспомогательной сетки для оси OY<br>    tick.gridOn = True<br>    tick.gridline.set_color('yellow')<br>    tick.gridline.set_linewidth(1.)<br><br>plt.show()</pre>
                                </p>
                                <img src="img/matplotlib/p_10/figure_1.png" class="image" height="200" alt="lorem">
                            </div>
                            <h4>Locator и Formatter</h4>
                            <p>
                                Деления могут быть как главными (major ticks), 
                                так и вспомогательными (minor ticks). Работа 
                                с делениями в обоих случаях одинаковая.
                            </p>
                            <p>
                                Однако, если главные деления будут автоматически 
                                созданы при вызове графической команды 
                                (например ax.plot() или ax.hist()), и с ними, 
                                соответственно, можно работать c помощью 
                                <b class="red">ax.xaxis.get_major_ticks()</b> или 
                                <b class="red">ax.yaxis.get_major_ticks()</b>, то 
                                вспомогательные деления необходимо задавать вручную. 
                                Удобнее всего это делать с помощью методов 
                                <b class="red">Formatter</b> и <b class="red">Locator</b>.
                            </p>
                            <p>
                                Методы Locator и Formatter относятся к модулю 
                                <b class="red">matplotlib.ticker</b>. 
                                Этот модуль содержит классы, позволяющие наиболее 
                                полно определять форматирование и местоположение делений. 
                                Это самый низкоуровневый способ форматирования делений 
                                на координатных осях.
                            </p>
                            <p>
                                Контейнеры коодинатных осей XAxis и YAxis имеют 
                                специальные методы для работы с объектами типа Formatter: 
                                <b class="red">.set_major/minor_locator()</b> и 
                                <b class="red">.set_major/minor_formatter()</b>. Например:
                            </p>
                            <ul>
                                <li><b class="red">xax.set_major_locator()</b>;</li>
                                <li><b class="red">xax.set_major_formatter()</b>;</li>
                                <li><b class="red">yax.set_minor_locator()</b>;</li>
                                <li><b class="red">yax.set_minor_formatter()</b>;</li>
                            </ul>
                            <p>
                                В качестве входящих данных данным методам нужно передать 
                                какой-либо экземпляр класса из модуля 
                                <b class="red">matplotlib.ticker</b>, например, 
                                <b class="red">matplotlib.ticker.MultipleLocator</b>.
                            </p>
                            <pre class="code">from matplotlib.ticker import MultipleLocator, FormatStrFormatter<br><br>majorLocator   = MultipleLocator(5)<br>majorFormatter = FormatStrFormatter('%d')<br><br>print(type(majorLocator))<br>print(type(majorFormatter))</pre>
                            <p>
                                Класс Locator является базовым классом для всех 
                                производных классов-локаторов, отвечающих за 
                                расположение делений. Локаторы работают с 
                                автомасштабированием в пределах области изменения данных, 
                                и исходя из этого определяют положение делений на оси. 
                                Одним из наиболее удобных является полуавтоматический 
                                локатор <b class="red">MultipleLocator</b>. В качестве входящих 
                                данных он принимает целое число, например 10, и самостоятельно 
                                подбирает пределы изменений на оси и располагает деления в местах, 
                                кратных заданному числу.
                            </p>
                            <p>
                                Cубкласс <b class="red">AutoMinorLocator()</b> позволяет 
                                автоматически определить положение вспомогательных делений. 
                                В качестве входящего параметра даётся целое число 
                                n - число промежутков, разделённых вспомогательными 
                                делениями, между двумя главными делениями. Это один 
                                их самых простых способов задать положение и значения 
                                вспомогательных делений. Форматирование подписей 
                                к таким делениям (их строковое представление), легче всего 
                                осуществить с помощью методов-форматеров.
                            </p>
                            <p>
                                Класс <b class="red">Formatter</b> является базовым для всех 
                                производных классов-форматеров, отвечающих за форматирование делений. 
                                Форматеры в качестве входящих данных принимают 
                                строку формата, например "<span class="code">%d</span>", которая применяется к подписи 
                                каждого деления. Разные субклассы предоставляют разный функционал. 
                                Так субкласс <b class="red">NullFormatter()</b> позволяет скрыть 
                                все подписи на выбранной оси.
                            </p>
                            <button class="accordion">Пример №1:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">import numpy as np<br>import matplotlib.pyplot as plt<br>from matplotlib.ticker import MultipleLocator,<br>                            FormatStrFormatter,<br>                            AutoMinorLocator,<br>                            NullFormatter<br><br>majorLocator   = MultipleLocator(5)<br># Автоматический подбор промежуточных делений.<br># Количество созданных делений равно n-1<br>minorLocator   = AutoMinorLocator(n=3)<br><br>majorFormatter = FormatStrFormatter('%d')<br>minorFormatter = FormatStrFormatter('%.2f')<br><br>N = 10<br>x = np.arange(-N, N+1, 1)<br>y = (np.random.random(len(x))*2.-1)*N<br><br>fig = plt.figure(figsize=(8, 6))<br>ax = fig.add_subplot(111)<br><br>ax.plot(x, y)<br><br>xax = ax.xaxis<br>yax = ax.yaxis<br><br>xax.set_major_locator(majorLocator)<br>xax.set_major_formatter(majorFormatter)<br>yax.set_major_locator(majorLocator)<br>yax.set_major_formatter(majorFormatter)<br><br>xax.set_minor_locator(minorLocator)<br>xax.set_minor_formatter(minorFormatter)<br>yax.set_minor_locator(minorLocator)<br>yax.set_minor_formatter(NullFormatter())<br># скрываем подписи вспомогательных делений по оси OY<br><br>ax.grid(True, which='major',<br>        color='k', linestyle='solid')<br><br>ax.grid(True, which='minor',<br>                color='grey',<br>                linestyle='dashed',<br>                alpha=0.5)<br>#yax.grid(True, which='minor',<br>                color='grey',<br>                linestyle='dashed',<br>                alpha=0.5)<br><br>#for label in xax.get_ticklabels():<br>#    label.set_color('red')<br>#    label.set_rotation(30)<br>#    label.set_fontsize(12)<br><br># для вспомогательных<br>#for the minor ticks, use no labels;<br>#default NullFormatter<br><br>plt.show()</pre>
                                </p>
                                <img src="img/matplotlib/p_10/figure_2.png" class="image" height="200" alt="lorem">
                            </div>
                            <button class="accordion">Пример №2:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">import numpy as np<br>import matplotlib.pyplot as plt<br>from matplotlib.ticker import MultipleLocator,<br>                            FormatStrFormatter,<br>                            AutoMinorLocator,<br>                            NullFormatter<br><br>majorLocator   = MultipleLocator(5)<br># Автоматический подбор промежуточных делений.<br># Количество созданных делений равно n-1<br>minorLocator   = AutoMinorLocator(n=3)<br><br>majorFormatter = FormatStrFormatter('%d')<br>minorFormatter = FormatStrFormatter('%.2f')<br><br>N = 10<br>x = np.arange(-N, N+1, 1)<br>y = (np.random.random(len(x))*2.-1)*N<br><br>fig = plt.figure(figsize=(8, 6))<br>ax = fig.add_subplot(111)<br><br>ax.plot(x, y)<br><br>xax = ax.xaxis<br>yax = ax.yaxis<br><br>xax.set_major_locator(majorLocator)<br>xax.set_major_formatter(majorFormatter)<br>yax.set_major_locator(majorLocator)<br>yax.set_major_formatter(majorFormatter)<br><br>xax.set_minor_locator(minorLocator)<br>xax.set_minor_formatter(minorFormatter)<br>yax.set_minor_locator(minorLocator)<br>yax.set_minor_formatter(NullFormatter())<br># скрываем подписи вспомогательных делений по оси OY<br><br>ax.grid(True, which='major',<br>                color='k',<br>                linestyle='solid')<br><br>ax.grid(True, which='minor',<br>                color='grey',<br>                linestyle='dashed',<br>                alpha=0.5)<br>#yax.grid(True, which='minor',<br>                color='grey',<br>                linestyle='dashed',<br>                alpha=0.5)<br><br>#for label in xax.get_ticklabels():<br>#    label.set_color('red')<br>#    label.set_rotation(30)<br>#    label.set_fontsize(12)<br># для вспомогательных<br>#for the minor ticks, use no labels;<br>#default NullFormatter<br><br>plt.show()</pre>
                                </p>
                                <img src="img/matplotlib/p_10/figure_3.png" class="image" height="200" alt="lorem">
                            </div>
                            <p>
                                Также некоторые элементы форматирования делений и 
                                их подписей вынесены в настройки rcParams:
                            </p>
                            <ul>
                                <li>
                                    <b class="red">xtick.color='k'</b> - 
                                    цвет делений по оси абсцисс;
                                </li>
                                <li>
                                    <b class="red">xtick.direction='in'</b> - 
                                    направление деления [] по оси абсцисс;
                                </li>
                                <li>
                                    <b class="red">xtick.labelsize='medium'</b> - 
                                    размер подписи деления на оси абсцисс;
                                </li>
                                <li>
                                    <b class="red">xtick.major.pad=4.0</b> - 
                                    расстояние от координатной оси для главных делений оси абсцисс;
                                </li>
                                <li>
                                    <b class="red">xtick.major.size=4.0</b> - 
                                    размер главного деления оси абсцисс;
                                </li>
                                <li>
                                    <b class="red">xtick.major.width=0.5</b> - толщина главного деления оси абсцисс;
                                </li>
                                <li>
                                    <b class="red">xtick.minor.pad=4.0</b> - 
                                    расстояние от координатной оси для вспомогательных делений оси абсцисс;
                                </li>
                                <li>
                                    <b class="red">xtick.minor.size=2.0</b> - 
                                    размер вспомогательного деления;
                                </li>
                                <li>
                                    <b class="red">xtick.minor.width=0.5</b> - 
                                    толщина вспомогательного деления;
                                </li>
                                <li>
                                    <b class="red">ytick.color='k'</b> - 
                                    цвет делений по оси ординат;
                                </li>
                                <li>
                                    <b class="red">ytick.direction='in'</b> - 
                                    направление деления [] по оси ординат;
                                </li>
                                <li>
                                    <b class="red">ytick.labelsize='medium'</b> - 
                                    размер подписи деления на оси абсцисс;
                                </li>
                                <li>
                                    <b class="red">ytick.major.pad=4.0</b> - 
                                    расстояние от координатной оси для главных делений оси ординат;
                                </li>
                                <li>
                                    <b class="red">ytick.major.size=4.0</b> - 
                                    размер главного деления оси ординат;
                                </li>
                                <li>
                                    <b class="red">ytick.major.width=0.5</b> - 
                                    толщина главного деления оси ординат;
                                </li>
                                <li>
                                    <b class="red">ytick.minor.pad=4.0</b> - 
                                    расстояние от координатной оси для вспомогательных делений оси ординат;
                                </li>
                                <li>
                                    <b class="red">ytick.minor.size=2.0</b> - 
                                    размер главного деления оси ординат;
                                </li>
                                <li>
                                    <b class="red">ytick.minor.width=0.5</b> - 
                                    толщина главного деления оси ординат;
                                </li>
                            </ul>
                        </div>
                        <h3 id="15.11">15.11 Особенности координатных осей:</h3>
                        <div class="text-in-card">
                            <h4>Дополнительная координатная ось</h4>
                            <p>
                                Иногда требуется нанести на один рисунок две величины, 
                                имеющие общие единицы измерения по одной оси, 
                                но разные по другой. Например, это могут быть временные 
                                ряды сильно отличающихся по масштабу величин. 
                                Или ряды величин, имеющих разные единицы измерения. 
                                В таких случаях удобно нарисовать дополнительную 
                                координатную ось (обычно - ординат).
                            </p>
                            <p>
                                Такую возможность обеспечивает метод 
                                <b class="red">ax.twinx()</b> для оси OX и метод 
                                <b class="red">ax.twiny()</b> для оси OY. В результате создаётся 
                                ещё одна область рисования, совпадающая по размерам 
                                с исходной. На каждой области рисуются соответствюущие 
                                значения, при этом с помощью пользовательской настройки 
                                подписей осей ординат можно добиться, чтобы вспомогательные 
                                сетки grid обеих областей совпадали.
                            </p>
                            <button class="accordion">Пример:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">from matplotlib import rcParams<br>import matplotlib.pyplot as plt<br>import numpy as np<br><br>x = np.arange(-2*np.pi, 2*np.pi, 0.2)<br>y = np.sin(x) * np.cos(x)<br>f = np.sin(x) + np.cos(x)<br><br>fig = plt.figure()<br>ax1 = fig.add_subplot(111)<br>ax2 = ax1.twinx()<br># Создаём вторую область рисования ax2<br>print('Результат работы метода twinx %s' % type(ax2))<br><br>ax1.plot(x, f, label = u'Сумма cos и sin', color='green')<br>ax1.set_xlabel(u'Аргумент')<br>ax1.set_ylabel(u'Функция 1', color='green')<br>ax1.grid(True, color='green')<br>ax1.tick_params(axis='y', labelcolor='green')<br><br>ax2.plot(x, y*333,<br>        label = u'Произведение cos и sin', color='red')<br>ax2.set_ylabel(u'Функция 2', color='red')<br>ax2.grid(linestyle='dashed', color='red')<br>ax2.tick_params(axis='y', labelcolor='red')<br><br>ax1.set_title(u'Несколько разномасштабных переменных')<br><br>plt.show()</pre>
                                </p>
                                <img src="img/matplotlib/p_11/figure_1.png" class="image" height="200" alt="lorem">
                            </div>
                            <h4>Работа с легендой дополнительной оси</h4>
                            <button class="accordion">Пример:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">from matplotlib import rcParams<br>import matplotlib.pyplot as plt<br>import numpy as np<br><br>x = np.arange(-2*np.pi, 2*np.pi, 0.2)<br>y = np.sin(x) * np.cos(x)<br>f = np.sin(x) + np.cos(x)<br><br>fig = plt.figure()<br># Явно задаём область рисования в виде четырёхуголника<br>ax1 = fig.add_subplot(111)<br>ax2 = ax1.twinx() # Создаём вторую шкалу ax2<br><br>ax1.plot(x, f, label = u'Сумма cos и sin', color='green')<br>ax1.set_xlabel(u'Аргумент')<br>ax1.set_ylabel(u'Функция 1', color='green')<br>ax1.grid(linestyle='dashed', color='green')<br><br>ax2.plot(x, y*333,<br>        label = u'Произведение cos и sin', color='red')<br>ax2.set_ylabel(u'Функция 2', color='red')<br>ax2.grid(linestyle='dashed', color='red')<br>#ax2.legend()<br><br>ax1.set_title(u'Несколько разномасштабных переменных')<br><br># Легенда для всего рисунка fig<br>plt.legend(loc='lower left')<br>plt.show()</pre>
                                </p>
                                <img src="img/matplotlib/p_11/figure_2.png" class="image" height="200" alt="lorem">
                            </div>
                            <p>
                                Несмотря на то, что было указано нарисовать легенду ко всему рисунку, 
                                отобразилась легенда только для одной координатной оси из двух!
                                На самом деле обе подписи легенды отобразились верно, 
                                но более новая легенда перезатёрла предыдущую. 
                                Потери можно избежать, если указать другое место расположения. 
                                Чтобы каждая подпись была в своём месте, 
                                нужно воспользоваться методом 
                                <b class="red">ax.legend()</b>, а не <b class="red">plt.legend()</b>.
                            </p>
                            <p>
                                Расположение легенды задаётся параметром 
                                <b class="red">loc</b> метода legend(), 
                                который принимает значения в виде цифр <b class="red">(1-9)</b>, 
                                начиная от верхнего левого угла и заканчивая нижним правым, 
                                и в виде условных обозначений. 
                                Значение <b class="red">loc='best'</b> автоматически выберет 
                                место на рисунке, где легенда меньше всего будет "портить" график. 
                                Также можно убрать рамку вокруг легенды для визуального уменьшения 
                                места (<b class="red">frameon=False</b>), занимаемого легендой, 
                                снижая тем самым геометрическое давление рисунка в целом.
                            </p>
                            <button class="accordion">Пример:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">import matplotlib.pyplot as plt<br>import numpy as np<br><br>x = np.arange(-2*np.pi, 2*np.pi, 0.2)<br>y = np.sin(x) * np.cos(x)<br>f = np.sin(x) + np.cos(x)<br><br>fig = plt.figure()<br>ax1 = fig.add_subplot(111)<br>ax2 = ax1.twinx() # Создаём вторую шкалу ax2<br><br>ax1.plot(x, f, label = u'Сумма cos и sin',<br>        color='green')<br>ax1.set_xlabel(u'Аргумент')<br>ax1.set_ylabel(u'Функция 1', color='green')<br>ax1.grid(linestyle='dashed', color='green')<br>ax1.legend(loc=2)<br><br>ax2.plot(x, y*333, label = u'Произведение cos и sin',<br>        color='red')<br>ax2.set_ylabel(u'Функция 2', color='red')<br>ax2.grid(linestyle='dashed', color='red')<br>ax2.legend(loc=1)<br><br>plt.title(u'Несколько разномасштабных переменных')<br><br>plt.show()</pre>
                                </p>
                                <img src="img/matplotlib/p_11/figure_3.png" class="image" height="200" alt="lorem">
                            </div>
                            <h4>Единая легенда</h4>
                            <p>
                                Если есть необходимость объединить обе легенды, 
                                сделав её единой, то можно пойти на следующую хитрость:
                            </p>
                            <button class="accordion">Пример:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">import matplotlib.pyplot as plt<br>import numpy as np<br><br>x = np.arange(-2*np.pi, 2*np.pi, 0.2)<br>y = np.sin(x) * np.cos(x)<br>f = np.sin(x) + np.cos(x)<br><br>fig = plt.figure()<br>ax1 = fig.add_subplot(111)<br>line1 = ax1.plot(x, f,<br>        label = u'Сумма cos и sin',<br>        color='green')<br>ax1.set_xlabel(u'Аргумент')<br>ax1.set_ylabel(u'Функция 1', color='green')<br>ax1.grid(linestyle='dashed', color='green')<br><br>ax2 = ax1.twinx() # Создаём вторую шкалу ax2<br>line2 = ax2.plot(x, y*333,<br>        label = u'Произведение cos и sin',<br>        color='red')<br>ax2.set_ylabel(u'Функция 2', color='red')<br>ax2.grid(linestyle='dashed', color='red')<br><br>lns = line1 + line2<br>labs = [l.get_label() for l in lns]<br>ax1.legend(lns, labs, loc=3)<br><br>plt.title(u'Общая легенда для двух осей')<br><br>plt.show()</pre>
                                </p>
                                <img src="img/matplotlib/p_11/figure_4.png" class="image" height="200" alt="lorem">
                            </div>
                            <h4>Графики с логарифмическими координатными осями</h4>
                            <p>
                                Иногда очень удобно использовать не стандартную равномерную шкалу 
                                на координатных осях, а логарифмическую.
                            </p>
                            <p>
                                Сделать шкалу координатной оси логарифмической позволяют методы 
                                <b class="red">plt.xscale('log')/plt.yscale('log')</b> 
                                или для областей рисования - 
                                <b class="red">ax.set_xscale('log')/ax.set_yscale('log')</b>.
                            </p>
                            <hr>
                            <p>
                                Из определения натурального логарифма и экспоненты вытекает следующий факт: 
                                если ось ординат имеет логарифмическую шкалу, то график функции, 
                                которая равна экспоненте от аргумента, будет выглядеть как прямая линия.
                            </p>
                            <hr>
                            <button class="accordion">Пример:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">import matplotlib.pyplot as plt<br>import numpy as np<br><br>x = np.arange(20)<br>y = np.exp(x)<br><br>fig = plt.figure()<br><br># 1 x и y=x<br>ax = fig.add_subplot(221)<br>ax.plot(x, x)<br>ax.grid(True)<br>ax.set_xlabel('x', fontsize=14)<br>ax.set_ylabel('y = x', fontsize=14)<br><br># 2 x и y=exp(x)<br>ax = fig.add_subplot(222)<br>ax.plot(x, y)<br>ax.grid()<br>ax.set_xlabel('x', fontsize=14)<br>ax.set_ylabel('y = exp(x)', fontsize=14)<br><br># 3 x и y=exp(x). OY с log шкалой<br>ax = fig.add_subplot(223)<br>ax.set_yscale('log')<br># log здесь - натуральный логарифм!<br># для работы с типом axis -> ax.set_yscale('log')<br>ax.plot(x, y)<br>ax.grid()<br>ax.set_xlabel('x', fontsize=14)<br>ax.set_ylabel('y = exp(x)', fontsize=14)<br>ax.set_title(u'OY log шкала', loc='center')<br><br># 4  x и y=x. OX с log шкалой<br>ax = fig.add_subplot(224)<br>ax.set_xscale('log')<br># log здесь - натуральный логарифм!<br>ax.plot(x, x)<br>ax.grid()<br>ax.set_xlabel('x', fontsize=14)<br>ax.set_ylabel('y = x', fontsize=14)<br>ax.set_title(u'OX log шкала', loc='center')<br><br># Автоматическое форматирование риснука<br>plt.tight_layout()<br><br>plt.show()</pre>
                                </p>
                                <img src="img/matplotlib/p_11/figure_5.png" class="image" height="200" alt="lorem">
                            </div>
                            <p>
                                Для того, чтобы выразить 
                                обе координатные оси в логарифмических шкалах, 
                                существует метод <b class="red">plt.loglog()</b> или 
                                <b class="red">ax.loglog()</b>.
                            </p>
                            <button class="accordion">Пример:</button>
                            <div class="panel">
                                <p>
                                    <pre class="code">x = np.arange(50)<br>y = np.exp(x)<br><br>fig = plt.figure()<br><br># 1 Обычные шкалы<br>ax = fig.add_subplot(211)<br>ax.plot(x, y)<br>ax.set_xlabel('x', fontsize=14)<br>ax.set_ylabel('y = exp(x)', fontsize=14)<br>ax.grid(True)<br><br># Log шкалы<br>ax = fig.add_subplot(212)<br>ax.loglog()<br>ax.plot(x, y)<br>ax.set_xlabel('x', fontsize=14)<br>ax.set_ylabel('y = exp(x)', fontsize=14)<br>ax.set_title(u'OY log и OX log шкалы')<br>ax.grid(True)<br><br>plt.tight_layout()<br><br>plt.show()</pre>
                                </p>
                                <img src="img/matplotlib/p_11/figure_6.png" class="image" height="200" alt="lorem">
                            </div>
                        </div>
                        <h3 id="15.12">15.12 Графики в полярной системе координат:</h3>
                    </div>
                </div>
            </div>
        </div>
        </div>
        <script src="script/jquery-3.4.1.js"></script>
        <script src="script/script.js"></script>
    </body>
</html>