<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <title>Python</title>
        <link href="css/grid.css" rel="stylesheet">
        <link href="css/font.css" rel="stylesheet">
        <link href="css/style.css" rel="stylesheet">
    </head>

    <body>
        <div class="container">
            <div class="row">
                <div class="col-6">
                    <div class="header-h1 header-h1-left">
                        <h1>Методичка по Python</h1>
                    </div>
                    <h2>1. Операторы:</h2>
                    <div class="card">
                        <h3><b>1.1 Арифметические операторы:</b> <span class="code">+, -, *, /, //, %, **</span></h3>
                        <div class="text-in-card">
                            <p>В пояснении нужнаются пожалуй только операторы <span class="code">//</span> и <span class="code">%</span></p>
                            <p>
                                Целочисленное деление <span class="code">//</span> - Деление в котором 
                                возвращается только целая часть результата.
                            </p>
                            <p>
                                Примеры: 
                                <br><b class="red">12 // 5 в результате будет 2</b>
                                <br><b class="red">4 // 3 в результате будет 1</b>
                            </p>
                            <p>
                                Деление по модулю <span class="code">%</span> - Делит левый операнд на правый и возвращает остаток.
                            </p>
                            <p>
                                Примеры: 
                                <br><b class="red">7 % 2 в результате будет 1</b>
                                <br><b class="red">13.2 % 5 в результате 3.2</b>
                            </p>
                        </div>
                        <h3><b>1.2 Битовые операторы:</b> <span class="code">&, |, ^, >>, <<, ~</span></h3> 
                        <div class="text-in-card">
                            <p>
                                Переменные типа int хранятся в двоичной системе счисления в виде 
                                последовательности бит. Биты нумеруются от 0, биты будем записывать 
                                справа налево (то есть бит с номером 0 будет записан самым правым, 
                                а самый старший бит — самым левым).
                            </p>
                            <p>
                                Для двух переменных одинакового скалярного типа определены битовые операции:
                                <br><b class="red">& битовое И (AND)</b>
                                <br><b class="red">| битовое ИЛИ (OR)</b>
                                <br><b class="red">^ битовое ИСКЛЮЧАЮЩЕЕ ИЛИ (XOR)</b>
                                <br><b class="red">~ битовое ОТРИЦАНИЕ (NOT) — унарная операция.</b>
                            </p>
                            <p>
                                Битовые операторы работают следующим образом. 
                                Берутся два операнда, и к каждой паре соответствующих бит для левого 
                                и правого операнда применяется данная операция, результатом 
                                будет переменная того же типа, каждый бит которой есть результат 
                                применения соответствующей логической операции к соответствующим 
                                битам двух операндов. 
                            </p>
                            <p>
                                Рассмотрим пример:
                                <br><b class="red">a = 5     #0b101</b>
                                <br><b class="red">b = 6     #0b110</b>
                                <br><b class="red">c = a & b #0b100 == 4</b>
                                <br><b class="red">d = a | b #0b111 == 7</b>
                                <br><b class="red">e = a ^ b #0b11 == 3</b>
                                <br><b class="red">f =  ~ a  #0b1...11111010 == -6</b>
                            </p>
                            <p>
                                Есть еще две операции, работающие с битами: это битовые сдвиги. 
                                Их два: сдвиг влево и вправо. Оператор a >> n возвращает число, 
                                которое получается из a сдвигом всех бит на n позиций вправо, 
                                при этом самые правые n бит отбрасываются. 
                            </p>
                            <p>
                                Например:
                                <br><b class="red">a = 43      #0b101011</b>
                                <br><b class="red">b = a >> 1  #0b10101 == 21</b>
                                <br><b class="red">c = a >> 2  #0b1010 == 10</b>
                            </p>
                        </div>
                        <h3>
                            <b>1.3 Операторы присваивания:</b> 
                            <br><span class="code">=, +=, -=, *=, /=, %=, //=, **=, &=, |=, ^=, >>=, <<=</span>
                        </h3>
                        <h3>
                            <b>1.4 Операторы сравнения:</b> 
                            <span class="code">==, !=, >, <, >=, <=</span>
                        </h3>
                        <div class="text-in-card">
                            <p>
                                Результатом выполнения операторов сравнения являются значения: True и False.
                            </p>
                        </div>
                        <h3>
                            <b>1.5 Логические операторы:</b> 
                            <span class="code">and, or, not</span>
                        </h3>
                        <div class="text-in-card">
                            <p>
                                Логические операторы используются для объединения операторов сравнения,
                                в операциях с логическим типом данных и в операторах ветвления.
                            </p>
                            <p>
                                <span class="code">and</span> - Логический оператор "И". Условие будет истинным если оба операнда истина.
                                <br><span class="code">first_number > 0 and second_number < 20 #True если оба True</span>
                            </p>
                            <p>Примеры:
                                <br><b class="red">True and True равно True.</b>
                                <br><b class="red">True and False равно False.</b>
                                <br><b class="red">False and True равно False.</b>
                                <br><b class="red">False and False равно False.</b>
                            </p>
                            <p>
                                <span class="code">or</span> - Логический оператор "ИЛИ". Если хотя бы один из операндов истинный, то и все выражение будет истинным.
                                <br><span class="code">first_number > 5 or second_number < 20 #True если хотябы один True</span>
                            </p>
                            <p>Примеры:
                                <br><b class="red">True or True равно True.</b>
                                <br><b class="red">True or False равно True.</b>
                                <br><b class="red">False or True равно True.</b>
                                <br><b class="red">False or False равно False.</b>
                            </p>
                            <p>
                                <span class="code">not</span> - Логический оператор "НЕ". Изменяет логическое значение операнда на противоположное.
                                <br><span class="code">not first_number == second_number #True если было False</span>
                            </p>
                            <p>Примеры:
                                <br><b class="red">not True равно False.</b>
                                <br><b class="red">not False равно True.</b>
                            </p>
                        </div>
                        <h3>
                            <b>1.6 Операторы идентификации:</b> 
                            <span class="code">is, is not</span>
                        </h3>
                        <div class="text-in-card">
                            <p>Операторы идентификации сравнивают ячейки памяти двух объектов.</p>
                            <p>
                                <span class="code">is</span> - Возвращает истину, если переменные по обе стороны от точки 
                                оператора указывают на тот же объект и ложь в противном случае.
                            </p>
                            <p>
                                <span class="code">is not</span> - Возвращает ложным, если 
                                переменные по обе стороны от точки оператора указывают на тот же объект и 
                                верно в противном случае.
                            </p>
                            <p>
                                Примеры:
                                <pre class="code">a = ["apple", "banana"]<br>b = ["apple", "banana"]<br>c = a<br>a is c # Вернёт True т.к. это один и тот же объект<br>a is b # Вернёт True т.к. это разные объекты<br>a == b # Вернёт True т.к. контект объектов одинаков</pre>
                            </p>
                            <p>Последний пример показывает разницу между <span class="code">is</span> и <span class="code">==</span></p>
                        </div>
                        <h3>
                            <b>1.7 Операторы членства:</b> 
                            <span class="code">in, not in</span>
                        </h3>
                        <div class="text-in-card">
                            <p>Операторы идентификации сравнивают ячейки памяти двух объектов.</p>
                            <p>
                                <span class="code">in</span> - Истина, если он находит переменную в указанной 
                                последовательности и ложь в противном случае.
                            </p>
                            <p>
                                <span class="code">not in</span> - Истина, если он не находит переменную в указанной 
                                последовательности и ложь в противном случае.
                            </p>
                            <p>
                                Примеры:
                                <pre class="code">a = ["apple", "banana"]<br>"banana" in a #Выдаст True<br>"pineapple" not a #Выдаст True</pre>
                            </p>
                        </div>
                    </div>
                    <h2>3. Логические операторы:</h2>
                    <div class="card">
                        <h3><b>3.1 Оператор ветвления:</b> <span class="code">if</span></h3>
                        <div class="text-in-card">
                            <p>
                                Оператор условного выбора ветви Python-программы. 
                                Его можно использовать для направления выполнения программы по двум различным ветвям.
                                Чтобы написать несколько условий ветвления нужно использовать конструкцию elif, 
                                слово else используется если условие не подходит. Синтаксис:
                                <pre class="code">number = 15<br>conclusion = ''<br><br>if number < 0:<br>    conclusion = 'Number is less than zero'<br>elif number == 0:<br>    conclusion = 'Number equals to zero'<br> elif number < 1:<br>    conclusion = 'Number is greater than zero but less than one'<br>else:<br>    conclusion = 'Number bigger than or equal to one'</pre>
                            </p>
                        </div>
                        <h3><b>3.2 Цикл for (и функция range()):</b> <span class="code">for, range()</span></h3>
                        <div class="text-in-card">
                            <p>
                                Оператор Python for перебирает элементы любой последовательности 
                                (списка или строки) в том порядке, что они появляются в последовательности. 
                                А функция, range(x,y,z) создаёт массив из чисел от x до y c шагом z 
                                (если аргумент только 1 то от 0 до этого аргумента).
                                <br>Например:
                                <pre class="code">for number in range(5):<br>    iterated_numbers.append(number)<br><br>assert iterated_numbers == [0, 1, 2, 3, 4]</pre>
                            </p>
                        </div>
                        <h3><b>3.3 Цикл while:</b> <span class="code">while</span></h3>
                        <div class="text-in-card">
                            <p>
                                Цикл while выполняется до тех пор, пока условие остается верным. 
                                <br>Например:
                                <pre class="code">number = 2<br>power = 5<br><br>result = 1<br><br>while power > 0:<br>    result *= number<br>    power -= 1</pre>
                            </p>
                        </div>
                        <h3><b>3.4 Инструкция break:</b> <span class="code">break</span></h3>
                        <div class="text-in-card">
                            <p>
                                Оператор break, выходит из внутреннего цикла «for» или «while».
                                <br>Пример:
                                <pre class="code">number_to_be_found = 42<br>number_of_iterations = 0<br><br>for number in range(100):<br>    if number == number_to_be_found:<br>        # Выходим из цикла.<br>        break<br>    else:<br>        number_of_iterations += 1
                                </pre>
                            </p>
                        </div>
                        <h3><b>3.5 Оператор continue:</b> <span class="code">continue</span></h3>
                        <div class="text-in-card">
                            <p>
                                Оператор continue, прерывает настоящую итерацию 
                                цикла и продолжает цикл со следующей итерации.
                                <br>Пример:
                                <pre class="code">for number in range(0, 10):<br>if number % 2 == 0:<br>    even_numbers.append(number)<br>    # Итерация препрывается и начинается новая<br>    continue<br>rest_of_the_numbers.append(number)</pre>
                            </p>
                        </div>
                    </div>
                    <h2>4. Функции:</h2>
                    <div class="card">
                        <h3>4.1 Инициализация функции: <span class="code">def</span></h3>
                        <div class="text-in-card">
                            <p>
                                Ключевое слово def вводит определение функции. 
                                За ним должно следовать имя функции и заключенный в скобки список формальных параметров. 
                                Операторы, которые формируют тело функции, начинаются с следующей строки 
                                и должны быть с отступом. Слово return указывает на вывод.
                                <pre class="code">def greet(name):<br>    return 'Hello, ' + name</pre>
                            </p>
                            <p>
                                Можно вкладывать функции друг в друга:
                                <pre class="code">def greet_again(name):<br>    def get_message():<br>        return 'Hello, '<br><br>    result = get_message() + name<br>    return result</pre>
                            </p>
                            <p>
                                Вызвать функцию можно по её имени:
                                <br><span class="code">greet_again('John') == 'Hello, John'</span>
                            </p>
                        </div>
                        <h3>4.2 Область видимости переменных: <span class="code">global, nonlocal</span></h3>
                        <div class="text-in-card">
                            <p>
                                У переменных в Python есть область видимости. 
                                В зависимости от места в коде, где переменная была определена, 
                                определяется и область видимости, то есть, где переменная будет доступна.
                                <br>При использовании имен переменных в программе, Python каждый раз ищет, 
                                создает или изменяет эти имена в соответствующем пространстве имен. 
                                Пространство имен, которое доступно в каждый момент, зависит от области, в которой находится код.
                            </p>
                            <p>
                                У Python есть правило LEGB, которым он пользуется при поиске переменных.
                                <ul>
                                    <li>
                                        L (local) - в локальной (внутри функции).
                                    </li>
                                    <li>
                                        E (enclosing) - в локальной области объемлющих функций 
                                        (это те функции, внутри которых находится наша функция).
                                    </li>
                                    <li>
                                        G (global) - в глобальной (в скрипте)
                                    </li>
                                    <li>
                                        B (built-in) - в встроенной (зарезервированные значения Python)
                                    </li>
                                </ul>
                            </p>
                            <p>
                                Оператор global объявляет переменную доступной для блока кода, следующим за оператором.4
                                Её можно применять к переменным внутри функции.
                                <br><pre class="code">def my_func(a, b):<br>    global x<br>    print(x)<br>    x = 5<br>    print(x) <br> <br>x = 10<br>my_func(1, 2)<br>print(x) #10 5 5</pre>
                            </p>
                            <p>
                                С помощью nonlocal мы можем добавлять переопределение области во внутреннюю область. 
                                <pre class="code">def counter():<br>    num = 0<br>    def incrementer():<br>        nonlocal num<br>        num += 1<br>        return num<br>    return incrementer</pre>
                            </p>
                        </div>
                        <h3>4.3 Аргументы функции.</h3>
                        <div class="text-in-card">
                            <p>
                                Можно указать значение аргументов функции по умолчанию. 
                                Тогда функцию можно вызывать с меньшим количеством аргументов.
                                <br>Пример:
                                <pre class="code">def power_of(number, power=2):<br>    return number ** power<br><br>power_of(3) == 9</pre>
                            </p>
                            <p>
                                Аргументы - ключевые слова используются при вызове функции. 
                                Благодаря ключевым аргументам, вы можете задавать произвольный 
                                (то есть не такой каким он описан, при создании функции) порядок аргументов.
                                <pre class="code">def person(name, age):<br>    print name, "is", age, "years old"<br><br> # Мы можем вызвать функцию вот так<br><br>person(age = 23, name = "John")</pre>
                            </p>
                            <p>
                                Функция также может принимать переменное количество позиционных аргументов, 
                                тогда перед именем ставится *:
                                <pre class="code">def func(*args):<br>    return args<br><br>func(1, 2, 3, 'abc') == (1, 2, 3, 'abc')</pre>
                            </p>
                            <p>
                                Как видно из примера, args - это кортеж из всех переданных 
                                аргументов функции, и с переменной можно работать также, как и с кортежем.
                            </p>
                            <p>
                                Функция может принимать и произвольное число именованных аргументов, 
                                тогда перед именем ставится **:
                                <pre class="code">def func(**kwargs):<br>    return kwargs<br><br>func(a=1, b=2, c=3) == {'a': 1, 'c': 3, 'b': 2}<br>func() == {}<br>func(a='python') == {'a': 'python'}</pre>
                            </p>
                            <p>
                                В переменной kwargs у нас хранится словарь, с которым мы, опять-таки, 
                                можем делать все, что нам заблагорассудится.
                            </p>
                        </div>
                        <h3>4.4 Анонимные (Лямбда) функции: <span class="code">lambda</span></h3>
                        <div class="text-in-card">
                            <p>
                                Анонимные функции могут содержать лишь одно выражение, 
                                но и выполняются они быстрее. Анонимные функции создаются с помощью инструкции lambda. 
                                Кроме этого, их не обязательно присваивать переменной, 
                                как делали мы инструкцией def func():
                                <pre class="code">func = lambda x, y: x + y<br>func(1, 2) == 3<br>func('a', 'b') == 'ab'<br>(lambda x, y: x + y)(1, 2) == 3<br>(lambda x, y: x + y)('a', 'b') == 'ab'</pre>
                            </p>
                            <p>
                                lambda функции, в отличие от обычной, не требуется инструкция return, 
                                а в остальном, ведет себя точно так же:
                                <pre class="code">func = lambda *args: args<br>func(1, 2, 3, 4) == (1, 2, 3, 4)</pre>
                            </p>
                        </div>
                        <h3>4.5 Документация функций: <span class="code">"""..."""</span></h3>
                        <div class="text-in-card">
                            <p>
                                Документирование кода в python - достаточно важный аспект, 
                                ведь от нее порой зависит читаемость и быстрота понимания вашего кода, 
                                как другими людьми, так и вами через полгода. Чтобы задокументировать объект 
                                нужно перед кодом этого объекта записать """ doc """. Тогда его можно получить с
                                помощью метода __doc__. 
                                <br>Например:
                                <pre class="code">def do_nothing():<br>    """Do nothing, but document it.<br>    No, really, it doesn't do anything.<br>    """<br>    pass<br>do_nothing.__doc__ <br>#"""Do nothing, but document it. No, really, it doesn't do anything."""</pre>
                            </p>
                        </div>
                        <h3>4.6 Декораторы.</h3>
                        <div class="text-in-card">
                            <p>
                                Декоратор — это функция, которая позволяет обернуть другую функцию для расширения 
                                её функциональности без непосредственного изменения её кода. 
                                Вот почему декораторы можно рассматривать как практику метапрограммирования, 
                                когда программы могут работать с другими программами как со своими данными. 
                            </p>
                            <p>
                                Тот факт, что всё является объектами, открывает перед нами множество возможностей. 
                                Мы можем сохранять функции в переменные, передавать их в качестве аргументов и 
                                возвращать из других функций. Можно даже определить одну функцию внутри другой. 
                                Иными словами, функции — это объекты первого класса. Мы знаем и о функциях высших порядков
                                в математике это, например, производная d/dx, которая принимает в себя функцию и 
                                возвращает функцию.
                            </p>
                            <p>
                                Посмотрим на пример декоратора:
                                <pre class="code">def decorator_function(func):<br>    def wrapper():<br>        print('Функция-обёртка!')<br>        print('Оборачиваемая функция: {}'.format(func))<br>        print('Выполняем обёрнутую функцию...')<br>        func()<br>        print('Выходим из обёртки')<br>    return wrapper</pre>
                            </p>
                            <p>
                                Теперь посмотрим на декоратор в действии:
                                <pre class="code">@decorator_function<br>def hello_world():<br>    print('Hello world!')<br><br>hello_world()<br>#Оборачиваемая функция: <function hello_world at 0x032B26A8><br>#Выполняем обёрнутую функцию...<br>#Hello world!<br>#Выходим из обёртки</pre>
                            </p>
                            <p>
                                Просто добавив <span class="code">@decorator_function</span> перед определением 
                                функции <span class="code">hello_world()</span>, мы модифицировали её поведение. 
                                Выражение с <span class="code">@</span> является всего лишь синтаксическим сахаром для 
                                <span class="code">hello_world = decorator_function(hello_world)</span>.
                                <br>Иными словами, выражение <span class="code">@decorator_function</span> вызывает 
                                <span class="code">decorator_function()</span> с <span class="code">hello_world</span> 
                                в качестве аргумента и присваивает имени <span class="code">hello_world</span> 
                                возвращаемую функцию.
                            </p>
                            <p>
                                Ещё примеры:
                                <pre class="code">def benchmark(func):<br>    import time<br>    <br>    def wrapper():<br>        start = time.time()<br>        func()<br>        end = time.time()<br>        print('[*] Время выполнения: {} секунд.'.format(end-start))<br>    return wrapper<br><br>@benchmark<br>def fetch_webpage():<br>    import requests<br>    webpage = requests.get('https://google.com')<br><br>fetch_webpage()</pre>
                            </p>
                            <p>
                                Здесь мы создаём декоратор, замеряющий время выполнения функции. 
                                Далее мы используем его на функции, которая делает GET-запрос 
                                к главной странице Google. Чтобы измерить скорость, мы сначала 
                                сохраняем время перед выполнением обёрнутой функции, выполняем её, 
                                снова сохраняем текущее время и вычитаем из него начальное.
                            </p>
                        </div>
                    </div>
                    <h2>7. Ошибки и исключения:</h2>
                    <div class="card">
                        <h3><b>7.1 Оператор try:</b> <span class="code">try, except, else, finally</span></h3>
                        <div class="text-in-card">
                        <p>
                            Оператор try используется для обработки исключений. 
                            Когда возникает ошибка или исключение, как мы ее называем, 
                            Python обычно останавливается и генерирует сообщение-ошибку. 
                            Эти исключения могут быть обработаны с помощью оператора try.
                            Блок «try» позволяет проверить блок кода на наличие ошибок. 
                            Блок «except» позволяет вам обработать ошибку. 
                            Блок "else" позволяет выполнить код, если ошибок не было. 
                            Блок "finally" позволяет выполнять код независимо от результата блоков try и except.
                            <br>Например:
                            <pre class="code">message = ''<br>try:<br>    print(not_existing_variable)  # noqa: F821<br>except NameError:<br>    message += 'Something went wrong.'<br>finally:<br>    message += 'The "try except" is finished.'</pre>
                        </p>
                        </div>
                        <h3>7.2 Создание исключений: <span class="code">raise</span></h3>
                        <div class="text-in-card">
                            <p>
                                Оператор raise позволяет программисту принудительно вызвать указанное исключение.
                                Например, мы можем вызвать исключение NameError и отловить его в try:
                                <pre class="code">try:<br>    raise NameError('HiThere') <br>except NameError:<br>    exception_is_caught = True<br><br>assert exception_is_caught</pre>
                            </p>
                            <p>
                                Мы можем создавать собственные исключения с помощью классов:
                                <pre class="code">class MyCustomError(Exception):<br>"""Example of MyCustomError exception."""<br>def __init__(self, message):<br>    super().__init__(message)<br>    self.message = message<br><br>custom_exception_is_caught = False<br><br>try:<br>    raise MyCustomError('My custom message')<br>except MyCustomError:<br>    custom_exception_is_caught = True</pre>
                            </p>
                        </div>
                    </div>
                    <h2>9. Дополнения:</h2>
                    <div class="card">
                        <h3>9.1 Оператор "пропуск": <span class="code">pass</span></h3>
                        <div class="text-in-card">
                            <p>
                                Оператор pass ничего не делает. Он может использоваться, когда оператор 
                                требуется синтаксически, но программа не требует никаких действий 
                                (Аналог return, только ничего не делает).
                            </p>
                        </div>
                        <h3>9.2 Генераторы: <span class="code">yield</span></h3>
                        <div class="text-in-card">
                            <p>
                                Генератор - это функция, возвращающая подвид итератора, генерирующий значения.
                                Итератор генератора — это объект, порождаемый функцией-генератором.
                                <br>Выглядят функции-генераторы также как и обычные, но содержат 
                                выражения с ключевым словом yield для последовательного генерирования значений, 
                                которые могут быть использованы в циклах for in, либо их получения при помощи 
                                функции next().
                            </p>
                            <p>
                                На каждой <span class="code">yield</span> работа функции временно приостанавливается, при этом 
                                сохраняется состояние исполнения, включая локальные переменные, 
                                указатель на текущую инструкцию, внутренний стек и состояние обработки исключения. 
                                При последующем обращении к итератору генератора (при вызовах его методов) функция 
                                продолжает своё исполнение с места, на котором была приостановлена. 
                                Этим функции-генераторы отличаются от обычных функций, при вызове которых 
                                исполнение всякий раз начинается с начала.
                                <br>Если функция достигает инструкции return, либо конца 
                                (без указания упомянутой инструкции), возбуждается исключение StopIteration и 
                                итератор исчерпывает себя.
                                <pre class="code">def my_animal_generator():<br><br>    yield 'корова'<br><br>    for animal in ['кот', 'собака', 'медведь']:<br>       yield animal<br><br>    yield 'кит'<br><br>for animal in my_animal_generator():<br>    print(animal)<br># корова кот собака медведь кит</pre>
                            </p>
                        </div>
                    </div>
                    <h2>10. Стандартные библиотеки:</h2>
                    <div class="card">
                        <h3>10.1 Библиотека Math.</h3>
                        <div class="text-in-card">
                            <p>
                                Модуль math – один из наиважнейших в Python. Этот модуль предоставляет обширный функционал для работы с числами.
                                <br><span class="code">import math</span>
                                <ul>
                                    <li>
                                        <span class="code">math.ceil(X)</span> – округление до ближайшего большего числа.
                                    </li>
                                    <li>
                                        <span class="code">math.copysign(X, Y)</span> - возвращает число, имеющее модуль такой же, как и у числа X, а знак - как у числа Y.
                                    </li>
                                    <li>
                                        <span class="code">math.fabs(X)</span> - модуль X.
                                    </li>
                                    <li>
                                        <span class="code">math.factorial(X)</span> - факториал числа X.
                                    </li>
                                    <li>
                                        <span class="code">math.floor(X)</span> - округление вниз.
                                    </li>
                                    <li>
                                        <span class="code">math.fmod(X, Y)</span> - остаток от деления X на Y.
                                    </li>
                                    <li>
                                        <span class="code">math.frexp(X)</span> - возвращает мантиссу и экспоненту числа.
                                    </li>
                                    <li>
                                        <span class="code">math.ldexp(X, i)</span> - X * 2<sup>i</sup>. 
                                        Функция, обратная функции math.frexp().
                                    </li>
                                    <li>
                                        <span class="code">math.fsum(последовательность)</span> - сумма всех членов последовательности. 
                                        Эквивалент встроенной функции sum(), но math.fsum() более точна для чисел с плавающей точкой.
                                    </li>
                                    <li>
                                        <span class="code">math.isfinite(X)</span> - является ли X числом.
                                    </li>
                                    <li>
                                        <span class="code">math.isinf(X)</span> - является ли X бесконечностью.
                                    </li>
                                    <li>
                                        <span class="code">math.isnan(X)</span> - является ли X NaN (Not a Number - не число).
                                    </li>
                                    <li>
                                        <span class="code">math.modf(X)</span> - возвращает дробную и целую часть числа X. Оба числа имеют тот же знак, что и X.
                                    </li>
                                    <li>
                                        <span class="code">math.trunc(X)</span> - усекает значение X до целого.
                                    </li>
                                    <li>
                                        <span class="code">math.exp(X)</span> - e<sup>X</sup>.
                                    </li>
                                    <li>
                                        <span class="code">math.expm1(X)</span> - e<sup>X</sup> - 1. При X → 0 точнее, чем math.exp(X)-1.
                                    </li>
                                    <li>
                                        <span class="code">math.log(X, [base])</span> - логарифм X по основанию base. Если base не указан, вычисляется натуральный логарифм.
                                    </li>
                                    <li>
                                        <span class="code">math.log1p(X)</span> - натуральный логарифм (1 + X). При X → 0 точнее, чем math.log(1+X)
                                    </li>
                                    <li>
                                        <span class="code">math.log10(X)</span> - логарифм X по основанию 10.
                                    </li>
                                    <li>
                                        <span class="code">math.log2(X)</span> - логарифм X по основанию 2.
                                    </li>
                                    <li>
                                        <span class="code">math.pow(X, Y)</span> - X<sup>Y</sup>.
                                    </li>
                                    <li>
                                        <span class="code">math.sqrt(X)</span> - квадратный корень из X.
                                    </li>
                                    <li>
                                        <span class="code">math.acos(X)</span> - арккосинус X. В радианах.
                                    </li>
                                    <li>
                                        <span class="code">math.asin(X)</span> - арксинус X. В радианах.
                                    </li>
                                    <li>
                                        <span class="code">math.atan(X)</span> - арктангенс X. В радианах.
                                    </li>
                                    <li>
                                        <span class="code">math.atan2(Y, X)</span> - арктангенс Y/X. В радианах. 
                                        С учетом четверти, в которой находится точка (X, Y).
                                    </li>
                                    <li>
                                        <span class="code">math.cos(X)</span> - косинус X (X указывается в радианах).
                                    </li>
                                    <li>
                                        <span class="code">math.sin(X)</span> - синус X (X указывается в радианах).
                                    </li>
                                    <li>
                                        <span class="code">math.tan(X)</span> - тангенс X (X указывается в радианах).
                                    </li>
                                    <li>
                                        <span class="code">math.hypot(X, Y)</span> - вычисляет гипотенузу треугольника 
                                        с катетами X и Y (math.sqrt(x * x + y * y))
                                    </li>
                                    <li>
                                        <span class="code">math.degrees(X)</span> - конвертирует радианы в градусы.
                                    </li>
                                    <li>
                                        <span class="code">math.radians(X)</span> - конвертирует градусы в радианы.
                                    </li>
                                    <li>
                                        <span class="code">math.cosh(X)</span> - вычисляет гиперболический косинус.
                                    </li>
                                    <li>
                                        <span class="code">math.sinh(X)</span> - вычисляет гиперболический синус.
                                    </li>
                                    <li>
                                        <span class="code">math.tanh(X)</span> - вычисляет гиперболический тангенс.
                                    </li>
                                    <li>
                                        <span class="code">math.acosh(X)</span> - вычисляет обратный гиперболический косинус.
                                    </li>
                                    <li>
                                        <span class="code">math.asinh(X)</span> - вычисляет обратный гиперболический синус.
                                    </li>
                                    <li>
                                        <span class="code">math.atanh(X)</span> - вычисляет обратный гиперболический тангенс.
                                    </li>
                                    <li>
                                        <span class="code">math.erf(X)</span> - функция ошибок.
                                    </li>
                                    <li>
                                        <span class="code">math.erfc(X)</span> - дополнительная функция ошибок (1 - math.erf(X)).
                                    </li>
                                    <li>
                                        <span class="code">math.gamma(X)</span> - гамма-функция X.
                                    </li>
                                    <li>
                                        <span class="code">math.lgamma(X)</span> - натуральный логарифм гамма-функции X.
                                    </li>
                                    <li>
                                        <span class="code">math.pi</span> - pi = 3,1415926...
                                    </li>
                                    <li>
                                        <span class="code">math.e</span> - e = 2,718281...
                                    </li>
                                </ul>
                            </p>
                        </div>
                        <h3>10.2 Библиотека random.</h3>
                        <div class="text-in-card">
                            <p>
                                Модуль random позволяет генерировать случайные числа.
                                Python порождает случайные числа на основе формулы, так что они не на самом деле случайные, 
                                а, как говорят, псевдослучайные. Этот способ удобен для большинства приложений 
                                (кроме онлайновых казино).
                                <br><span class="code">import random</span>
                                <ul>
                                    <li>
                                        <span class="code">random.random()</span> — 
                                        возвращает псевдослучайное число от 0.0 до 1.0
                                    </li>
                                    <li>
                                        <span class="code">random.seed(<Параметр>)</span> — настраивает генератор 
                                        случайных чисел на новую последовательность. 
                                        По умолчанию используется системное время. 
                                        Если значение параметра будет одиноким, то генерируется одинокое число:
                                        <pre class="code">random.seed(20)<br>random.random()<br>0.9056396761745207<br><br>random.random()<br>0.6862541570267026<br><br>random.seed(20)<br>random.random()<br>0.9056396761745207<br><br>random.random()<br>0.7665092563626442</pre>
                                    </li>
                                    <li>
                                        <span class="code">random.uniform(<Начало>, <Конец>)</span> — возвращает 
                                        псевдослучайное вещественное число в диапазоне от <Начало> до <Конец>.
                                    </li>
                                    <li>
                                        <span class="code">random.randint(<Начало>, <Конец>)</span> — возвращает псевдослучайное целое 
                                        число в диапазоне от <Начало> до <Конец>.
                                    </li>
                                    <li>
                                        <span class="code">random.choince(<Последовательность>)</span> — возвращает 
                                        случайный элемент из любой последовательности (строки, списка, кортежа):
                                        <pre class="code">random.choice('Chewbacca') #'h'<br>random.choice([1,2,'a','b']) #2</pre>
                                    </li>
                                    <li>
                                        <span class="code">random.randrange(<Начало>, <Конец>, <Шаг>)</span> — 
                                        возвращает случайно выбранное число из последовательности.
                                    </li>
                                    <li>
                                        <span class="code">random.shuffle(<Список>)</span> — перемешивает 
                                        последовательность (изменяется сама последовательность). 
                                        Поэтому функция не работает для неизменяемых объектов.
                                    </li>
                                </ul>
                            </p>
                            <p>
                                <b>Вероятностные распределения</b>
                                <ul>
                                    <li>
                                        <span class="code">random.triangular(low, high, mode)</span> — случайное число с плавающей точкой, low ≤ N ≤ high. Mode - распределение.
                                    </li>
                                    <li>
                                        <span class="code">random.betavariate(alpha, beta)</span> — бета-распределение. alpha>0, beta>0. Возвращает от 0 до 1.
                                    </li>
                                    <li>
                                        <span class="code">random.expovariate(lambd)</span> — экспоненциальное распределение. 
                                        lambd равен 1/среднее желаемое. Lambd должен быть отличным от нуля. 
                                        Возвращаемые значения от 0 до плюс бесконечности, если lambd положительно, 
                                        и от минус бесконечности до 0, если lambd отрицательный.
                                    </li>
                                    <li>
                                        <span class="code">random.gammavariate(alpha, beta)</span> — гамма-распределение. 
                                        Условия на параметры alpha>0 и beta>0.
                                    </li>
                                    <li>
                                        <span class="code">random.gauss(значение, стандартное отклонение)</span>
                                         — распределение Гаусса.
                                    </li>
                                    <li>
                                        <span class="code">random.lognormvariate(mu, sigma)</span> — логарифм нормального распределения. 
                                        Если взять натуральный логарифм этого распределения, 
                                        то вы получите нормальное распределение со средним mu и стандартным отклонением sigma. 
                                        mu может иметь любое значение, и sigma должна быть больше нуля.
                                    </li>
                                    <li>
                                        <span class="code">random.normalvariate(mu, sigma)</span> — нормальное распределение. 
                                        mu — среднее значение, sigma — стандартное отклонение.
                                    </li>
                                    <li>
                                        <span class="code">random.vonmisesvariate(mu, kappa)</span> — mu — средний угол, выраженный в 
                                        радианах от 0 до 2π, и kappa — параметр концентрации, который должен быть 
                                        больше или равен нулю. Если каппа равна нулю, 
                                        это распределение сводится к случайному углу в диапазоне от 0 до 2π.
                                    </li>
                                    <li>
                                        <span class="code">random.paretovariate(alpha)</span> — распределение Парето.
                                    </li>
                                    <li>
                                        <span class="code">random.weibullvariate(alpha, beta)</span> — распределение Вейбулла.
                                    </li>
                                </ul>
                            </p>
                        </div>
                    </div>
                </div>

                <div class="col-6">
                    <h2>2. Типы данных:</h2>
                    <div class="card">
                        <h3>
                            <b>2.1 Числа (включая booleans):</b> 
                            <span class="code">int, bool, float, complex</span>
                        </h3>
                        <div class="text-in-card">
                            <p>
                                В Python есть 3 числовых типа:
                                <ul>
                                    <li>int - Integer, целые числа.
                                        <ul>
                                            <li>
                                                bool - Boolean, логический тип данных, 
                                                принимает значения True или False, которые можно заменить на 1 и 0.
                                            </li>
                                        </ul>
                                    </li>
                                    <li>float - числа с плавающей точкой, аналог вещественных чисел.</li>
                                    <li>complex - комплексные числа.</li>
                                </ul>
                            </p>
                            <p>
                                Примеры:
                                <pre class="code">a=-177463 #int<br>q = True #bool<br>b=-35.59 #float<br>c=35e3 #== 35000 float<br>w_1=5+6j #complex<br>w_2=3-2j #complex<br>w_1*w_2==27+8j</pre>
                            </p>
                        </div>
                        <h3>
                            <b>2.2 Строки и их методы:</b> 
                            <span class="code">'...', "..."</span>
                        </h3>
                        <div class="text-in-card">
                            <p>
                                Помимо чисел, Python может манипулировать строками, 
                                которые могут быть определены несколькими способами. 
                                Они могут быть заключены в одинарные кавычки ('...')<span class="code">name_1 = 'John'</span>
                                или двойные кавычки ("...") <span class="code">name_2 = "John"</span>, разницы в этих 2-х определениях нет.
                            </p>
                            <p>
                                Символ \ экранирует кавычки, чтобы они тоже 
                                отображались в строке <span class="code">string_eg = 'doesn\'t'</span>. 
                                А символ <span class="code">\n</span> переносит строку на новую строчку.
                            </p>
                            <p>
                                Строки могут быть проиндексированы, причем первый символ имеет индекс 0.
                               Нет отдельного типа символов; символ - это просто строка.
                               Можно индексировать строку и с конца, но тогда начать нужно с -1. 
                               В дополнение к индексации, поддерживаются срезы, позволяющие получить набор символов из начальной строки.
                               <br>Примеры:
                               <pre class="code">word = 'Python'<br>word[0] == 'P'<br>word[5] == 'n'<br>word[-1] == 'n'<br>word[-2] == 'o'<br>word[0:2] == 'Py' # это срез.</pre>
                            </p>
                            <p>
                                Строки так же можно складывать <span class="code">'J'+'ython' == 'Jython'</span> или умножать <span class="code">3 * 'J' == 'JJJ'</span>.
                            </p>
                            <p>
                                Методы для работы со строками:
                                <ul>
                                    <li>
                                        Метод strip() удаляет все пробелы в начале и в конце строки.
                                        <br><span class="code">strip(" Python ") == "Python"</span>
                                    </li>
                                    <li>
                                        len() возвращает длину строки.
                                        <br><span class="code">len("Python") == 6</span>
                                    </li>
                                    <li>
                                        Метод lower() возвращает строку в нижнем регистре.
                                        <br><span class="code">"PyThon".lower() == 'python'</span>
                                    </li>
                                    <li>
                                        Метод upper() возвращает строку в верхнем регистре.
                                        <br><span class="code">"PyThon".upper() == 'PYTHON'</span>
                                    </li>
                                    <li>
                                        Метод replace() заменяет строку другой строкой.
                                        <br><span class="code">"Python".replace('P', 'J') == 'Jython'</span>
                                    </li>
                                    <li>
                                        Метод split() разбивает строку на подстроки, 
                                        если он находит экземпляры разделителя. Если разделитель не указан, 
                                        то разбивает по символам.
                                        <br><span class="code">"Hello, World".split(',') == ['Hello', ' World!']</span>
                                        <br><span class="code">"Python".split() == ['P', 'y', 't', 'h', 'o', 'n']</span>
                                    </li>
                                    <li>
                                        Метод capitalize() преобразует первый символ в верхний регистр.
                                        <br><span class="code">'low letter at the beginning'.capitalize() == 'Low letter at the beginning'</span>
                                    </li>
                                    <li>
                                        Метод count() возвращает количество раз, когда указанная строка встречается в начальной строке.
                                        <br><span class="code">'low letter at the beginning'.count('t') == 4</span>
                                    </li>
                                    <li>
                                        Метод find() ищет в строке указанную подстроку и возвращает позицию, где она была найдена.
                                        <br><span class="code">'Hello, welcome to my world'.find('welcome') == 7</span>
                                    </li>
                                    <li>
                                        Метод title() преобразует первый символ каждого слова 
                                        (наборы символов разделённые пробелом) в верхний регистр.
                                        <br><span class="code">'Welcome to my world'.title() == 'Welcome To My World'</span>
                                    </li>
                                    <li>
                                        Метод join() объединяет элементы кортежа (передаваемого аргументом), 
                                        разделяя их строкой к которой мы этот метот и применяем.
                                        <br><span class="code">my_tuple = ('John', 'Peter', 'Vicky')</span>
                                        <br><span class="code">', '.join(my_tuple) == 'John, Peter, Vicky'</span>
                                    </li>
                                    <li>
                                        Метод isalpha() возвращает True если все символы в строке являются буквами.
                                        <br><span class="code">'CompanyX'.isalpha() == True</span>
                                        <br><span class="code">'Company33X'.isalpha() == False</span>
                                    </li>
                                    <li>
                                        Метод isdecimal() возвращает True если все символы в строке являются цифрами.
                                        <br><span class="code">'1234'.isdecimal() == True</span>
                                        <br><span class="code">'12fff34'.isdecimal() == False</span>
                                    </li>
                                </ul>
                            </p>
                            <p>
                                В строки можно вставлять аргументы если перед строкой поставить f :
                                <pre class="code">year = 2018<br>event = 'conference'<br>f'Results of the {year} {event}' == 'Results of the 2018 conference'</pre>
                            </p>
                            <p>
                                С помощью метода str() в струку можно преобразовывать другие типы данных: 
                                <span class="code">str(5) == '5'</span>
                                А метод repr() делает строки так как они записаны: 
                                <pre class="code">a = 10 * 3.25<br>b = 200 * 200<br>repr((a, b, ('spam', 'eggs'))) == "(32.5, 40000, ('spam', 'eggs'))"</pre>
                            </p>
                        </div>
                        <h3>
                            <b>2.3 Списки и их методы:</b> 
                            <span class="code">[...]</span>
                        </h3>
                        <div class="text-in-card">
                            <p>
                                Python знает несколько составных типов данных, 
                                используемых для группировки. Наиболее универсальным является 
                                список, который определяется как набор элементов, разделенных запятыми, 
                                в квадратных скобках <span class="code">squares = [1, 4, 9, 16, 25]</span>. 
                                Список может содержать элементы разных типов, 
                                но обычно все эти элементы имеют один и тот же тип данных.
                            </p>
                            <p>
                                Списки так же как и строки индексируются и срезаются:
                                <pre class="code">squares = [1, 4, 9, 16, 25]<br>squares[0] == 1<br>squares[-3:] == [9, 16, 25]</pre>
                            </p>
                            <p>
                                Списки также поддерживают такие операции, как конкатенация (сложение, склейка) 
                                <br><span class="code">[1, 4, 9] + [36, 49, 64] == [1, 4, 9, 36, 49, 64]</span>
                            </p>
                            <p>
                                Списки в отличии от строк являются изменяемыми:
                                <pre class="code">cubes = [1, 8, 27, 65, 125]<br>cubes[3] = 64 #== [1, 8, 27, 64, 125] <br>cubes[1:2] = [1, 2] #== [1, 1, 1, 64, 125]</pre>
                            </p>
                            <p>
                                С помощью метода append() можно добавить элемент в конец списка 
                                <span class="code">[1, 8, 27, 64, 125].append(7 ** 3) == [1, 8, 27, 64, 125, 343]</span>.
                                Можно создавать вложенные (многомерные списки) <span class="code">mixed_list == [['a', 'b', 'c'], [1, 2, 3]]</span>.
                                Так же можно очистить список с помощью среза 
                                <pre class="code">letters = ['a', 'b', 'f', 'g']<br> letters[:] = [] # == []</pre> 
                            </p>
                            <p>
                                Методы для работы со списками:
                                <ul>
                                    <li>
                                        Функция len() возвращает длину списка:
                                        <br><span class="code">len(['a', 'b', 'c', 'd']) == 4</span>
                                    </li>
                                    <li>
                                        Метод remove(x) удаляет первый элемент со значением x:
                                        <br><span class="code">['orange', 'apple', 'pear'].remove('apple') == ['orange', 'pear']</span>
                                    </li>
                                    <li>
                                        Метод insert(i, x) вставляет элемент x на позицию i:
                                        <br><span class="code">['apple, 'orange'].insert(0, 'grape') == ['grape', 'apple, 'orange']</span>
                                    </li>
                                    <li>
                                        Метод index(x, start, end) возвращает позицию первого 
                                        вхождения элемента x начиная со start до end (не обязательные аргументы)
                                        <pre class="code">[1,3,8,3,7].index(3, 2) == 3 <br>[1,3,8,3,7].index(3) == 1</pre>
                                    </li>
                                    <li>
                                        Метод count(x) возвращает количество вхождений элемента x:
                                        <br><span class="code">[3,5,7,2,4,3].count(3) == 2</span>
                                    </li>
                                    <li>
                                        Метод copy() возвращает копию списка:
                                        <br><span class="code">a = [3,6,3,3].copy() #a == [3,6,3,3]</span>
                                    </li>
                                    <li>
                                        Метод reverse() возвращает "перевёрнутый" список:
                                        <br><span class="code">[1,2,4,5].reverse() == [5,4,2,1]</span>
                                    </li>
                                    <li>
                                        Метод sort(key=None, reverse=False) сортирует список 
                                        (если нужно сортировать не цифры, то лучше прочитать подробнее)
                                        <br><span class="code">[2,4,73,1,4,3].sort() == [1,2,3,4,4,73]</span>
                                    </li>
                                    <li>
                                        Метод pop() удаляет последний элемент списка и возвращает его
                                        <pre class="code">fruits == ['banana', 'kiwi', 'apple', 'banana']<br>fruits.pop() == 'banana'<br>fruits == ['banana', 'kiwi', 'apple']</pre>
                                    </li>
                                    <li>
                                        Метод clear() удаляет список:
                                        <br><span class="code">fruits.clear() == []</span>
                                    </li>
                                    <li>
                                        Приписка del позволяет удалить элемент по его индексу:
                                        <pre class="code">numbers = [-1, 1, 66.25, 333, 333, 1234.5]<br>del numbers[0]<br>numbers == [1, 66.25, 333, 333, 1234.5]</pre>
                                    </li>
                                </ul>
                            </p>
                            <p>
                                Можно автоматизировать создание списков, например с помощью цикла:
                                <pre class="code">squares = []<br>for number in range(10):<br>squares.append(number ** 2)<br><br>assert squares == [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</pre>
                            </p>
                            <p>
                                С помощью лямбда функции: 
                                <br><span class="code">squares = list(map(lambda x: x ** 2, range(10)))</span>
                                <br>Или с помощью конструктора списков: 
                                <br><span class="code">combinations = [(x, y) for x in [1, 2, 3] for y in [3, 1, 4] if x != y]</span>
                                <br>Так же можно применять функции в элементам списка: 
                                <br><span class="code">abs_vector = [abs(x) for x in vector] #Применяем модуль ко всем элементам списка vector</span>
                            </p>
                        </div>
                        <h3>
                            <b>2.4 Кортежи:</b> 
                            <span class="code">(...)</span>
                        </h3>
                        <div class="text-in-card">
                            <p>
                                Кортеж - это коллекция, которая упорядочена и неизменна. 
                                В Python кортежи пишутся с круглые скобки.
                            </p>
                            <p>
                                Кортежи индексируются:
                                <pre class="code">fruits_tuple = ("apple", "banana", "cherry")<br>fruits_tuple[1] == "banana"</pre>
                            </p>
                            <p>
                                Кортежи могут быть вложенными или пустыми: 
                                <br><span class="code">nested_tuple == ((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))</span>
                                <br><span class="code">tuple == ()</span>
                            </p>
                            <p>
                                Фунция len() возвращает длинну массива: <br><span class="code">len(("apple")) == 1</span>
                            </p>
                        </div>
                        <h3>
                            <b>2.5 Наборы и их методы:</b> 
                            <span class="code">{...}</span>
                        </h3>
                        <div class="text-in-card">
                            <p>
                                Набор - это неупорядоченная и неиндексированная коллекция (Аналог множеств). 
                                В Python наборы пишутся с помощью фигурных скобок. Наборы также поддерживают 
                                математические операции, такие как объединение, пересечение, разность и 
                                симметричная разница.
                                <br><span class="code">fruits_set = {"apple", "banana", "cherry"}</span>
                            </p>
                            <p>
                                Методы для работы с наборами:
                                <ul>
                                    <li>
                                        С помощью конструкции in можно узнать есть ли указанный элемент в наборе:
                                        <br><span class="code">"apple" in {"apple", "banana", "cherry"} == True</span>
                                    </li>
                                    <li>
                                        С помощью функции len() можно узнать длинну набора:
                                        <br><span class="code">len({"apple", "banana", "cherry"}) == 3</span>
                                    </li>
                                    <li>
                                        С помощью метода add() можно добавить элемент в конец набора:
                                        <br><span class="code">{"apple", "banana", "cherry"}.add("pineapple") == {"apple", "banana", "cherry", "pineapple"}</span>
                                    </li>
                                    <li>
                                        Метод remove(x) позволяет удали элемент x:
                                        <br><span class="code">{"apple", "banana", "cherry"}.remove("apple") == {"banana", "cherry"}</span>
                                    </li>
                                    <li>
                                        С помощью метода set() мы можем разбить другой объект в набор, 
                                        заметим что элементы в наборе не повторяются:
                                        <br><span class="code">set('abracadabra') == {'a', 'r', 'b', 'c', 'd'}</span>
                                    </li>
                                    <li>
                                        Мы можем найти разность наборов (удаляет повторяющиеся элементы):
                                        <br><span class="code">{'a', 'r', 'b', 'c', 'd'} - {'a', 'l', 'c', 'z', 'm'} == {'r', 'b', 'd'}</span>
                                    </li>
                                    <li>
                                        Операция объединения (|):
                                        <br><span class="code">{'a', 'r', 'b', 'c', 'd'} | {'a', 'l', 'c', 'z', 'm'} == {'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}</span>
                                    </li>
                                    <li>
                                        Операция пересечения (&):
                                        <br><span class="code">{'a', 'r', 'b', 'c', 'd'} & {'a', 'l', 'c', 'z', 'm'} == {'a', 'c'}</span>
                                    </li>
                                    <li>
                                        Операция симметричной разности (^):
                                        <br><span class="code">{'a', 'r', 'b', 'c', 'd'} ^ {'a', 'l', 'c', 'z', 'm'} == {'r', 'd', 'b', 'm', 'z', 'l'}</span>
                                    </li>
                                </ul>
                            </p>
                        </div>
                        <h3>
                            <b>2.6 Словари:</b> 
                            <span class="code">{ key:values }</span>
                        </h3>
                        <div class="text-in-card">
                            <p>
                                Словарь - это неупорядоченная, изменяемая и 
                                индексируемая коллекция. В Python словари есть написано в 
                                фигурных скобках, и они имеют ключи и значения.
                                <pre class="code">fruits_dictionary = {<br>    'cherry': 'red',<br>    'apple': 'green',<br>    'banana': 'yellow',<br>}</pre>
                            </p>
                            <p>
                                Что можно делать со словарями?
                                <ul>
                                    <li>
                                        Можно искать значение по ключу:
                                        <br><span class="code">fruits_dictionary['apple'] == 'green'</span>
                                    </li>
                                    <li>
                                        Чтобы проверить, есть ли один ключ в словаре, 
                                        используйте ключевое слово in.
                                        <br><span class="code">'apple' in fruits_dictionary == True</span>
                                    </li>
                                    <li>
                                        Можно изменить значение в ключе:
                                        <br><span class="code">fruits_dictionary['apple'] = 'red'</span>
                                    </li>
                                    <li>
                                        Можно добавить новый ключ со значением:
                                        <br><span class="code">fruits_dictionary['pineapple'] = 'yellow'</span>
                                    </li>
                                    <li>
                                        Функция list() возвращает множество ключей словаря:
                                        <br><span class="code">list(fruits_dictionary) == ['cherry', 'apple', 'banana', 'pineapple']</span>
                                    </li>
                                    <li>
                                        Функция sorted() возвращает отсортированное множество ключей:
                                        <br><span class="code">sorted(fruits_dictionary) == ['apple', 'banana', 'cherry', 'pineapple']</span>
                                    </li>
                                    <li>
                                        С помощью конструкции del можно удалить пару ключ-значение (удаляется по ключу):
                                        <br><span class="code">del fruits_dictionary['pineapple']</span>
                                    </li>
                                    <li>
                                        Можно составить словарь с помощью конструктора словарей:
                                        <br><span class="code">dictionary_via_expression = {x: x**2 for x in (2, 4, 6)}</span>
                                    </li>
                                </ul>
                            </p>
                        </div>
                        <h3>
                            <b>2.7 Приведение типов:</b> 
                            <span class="code">int(), float(), str()</span>
                        </h3>
                        <div class="text-in-card">
                            <p>
                                Python является объектно-ориентированным языком, 
                                и поэтому он использует классы для определения типов данных, включая его примитивные типы.
                                Поэтому приведение в python выполняется с помощью функций конструктора:
                                <ul>
                                    <li>
                                        int() - создает целое число из целочисленного типа, 
                                        типа float (округляя к предыдущему целому числу) или строкового типа 
                                        (при условии, что строка представляет собой целое число). Примеры:
                                        <pre class="code">int(1) == 1<br>int(2.8) == 2<br>int('3') == 3</pre>
                                    </li>
                                    <li>
                                        float() - создает число с плавающей точкой из целочисленного типа, 
                                        типа float или строкового типа данных 
                                        (При условии что строка это число с плавающей точкой или целое число). Примеры:
                                        <pre class="code">float(1) == 1.0<br>float(2.8) == 2.8<br>float("3") == 3.0<br>float("4.2") == 4.2</pre>
                                    </li>
                                    <li>
                                        str() - создает строку из множетсва типов данных, 
                                        включая строки, целые числа и числа с плавающей точкой. Примеры:
                                        <pre class="code">str("s1") == 's1'<br>str(2) == '2'<br>str(3.0) == '3.0'</pre>
                                    </li>
                                </ul>
                            </p>
                        </div>
                    </div>
                    <h2>5. Классы:</h2>
                    <div class="card">
                        <h3>5.1 Инициализация класса: <span class="code">class</span>:</h3>
                        <div class="text-in-card">
                            <p>
                                Python - это объектно-ориентированный язык программирования. 
                                Все в Python является объектом, со своими свойствами и методами. 
                                Класс это на конструктор объектов или «план» для создания объектов.
                            </p>
                            <p>
                                Создание класса в Python начинается с инструкции class. Вот так будет выглядеть минимальный класс:
                                <pre class="code">class C:<br>    pass</pre>
                            </p>
                            <p>
                                Класс состоит из объявления (инструкция class), 
                                имени класса (нашем случае это имя C) и тела класса, которое 
                                содержит атрибуты и методы (в нашем минимальном классе есть только одна инструкция pass).
                            </p>
                            <p>
                                Для того чтобы создать объект класса необходимо воспользоваться следующим синтаксисом:
                                <br><span class="code">имя_объекта = имя_класса()</span>
                            </p>
                            <p>
                                Класс может содержать атрибуты и методы. Ниже представлен класс, 
                                содержащий атрибуты color (цвет), width (ширина), height (высота).
                                <pre class="code">class Rectangle:<br>    color = “green”<br>    width = 100<br>    height = 100</pre>
                            </p>
                            <p>
                                Доступ к атрибуту класса можно получить следующим образом:
                                <br><pre class="code">rect1 = Rectangle()<br>print(rect1.color)</pre>
                            </p>
                            <p>
                                Метод – это функция находящаяся внутри класса, выполняющая определенную работу, 
                                которая, чаще всего, предполагает доступ к атрибутам созданного объекта. 
                                Слово self указывает методу, с каким объектом он работает, это позволяет работать 
                                со свойствами этого объекта.
                                <pre class="code">class Rectangle:<br>    width = 100<br>    height = 100<br>    def square(self):<br>        return self.width * self.height</pre>
                            </p>
                        </div>
                        <h3>5.2 Конструктор класса: <span class="code">__init__(self)</span>:</h3>
                        <div class="text-in-card">
                            <p>
                                Конструктор класса позволяет задать определенные параметры объекта при его создании. 
                                Таким образом появляется возможность создавать объекты с уже заранее заданными атрибутами. 
                                Конструктором класса является метод: <span class="code"> __init__(self)</span>
                                <pre class="code">class Rectangle:<br>def __init__(self, color="green", width=100, height=100):<br>    self.color = color<br>    self.width = width<br>    self.height = height<br><br>def square(self):<br>    return self.width * self.height</pre>
                            </p>
                        </div>
                        <h3>5.3 Наследование.</h3>
                        <div class="text-in-card">
                            <p>
                                В организации наследования участвуют как минимум два класса: 
                                класс родитель и класс потомок. При этом возможно множественное наследование, 
                                в этом случае у класса потомка есть несколько родителей.
                                <br>Синтаксически создание класса с указанием его родителя/ей выглядит так:
                                <br><span class="code">class имя_класса(имя_родителя1, [имя_родителя2,…, имя_родителя_n])</span>
                                <pre class="code">class Figure:<br>    def __init__(self, color):<br>        self.color = color<br><br>    def get_color(self):<br>        return self.color<br><br>class Rectangle(Figure):<br>    def __init__(self, color, width=100, height=100):<br>        super().__init__(color)<br>        self.width = width<br>        self.height = height<br><br>    def square(self):<br>        return self.width*self.height<br><br>rect1 = Rectangle("blue")<br>print(rect1.get_color())<br>print(rect1.square())<br>rect2 = Rectangle("red", 25, 70)<br>print(rect2.get_color())<br>print(rect2.square())</pre>
                            </p>
                        </div>
                        <h3>5.4 Полиморфизм.</h3>
                        <div class="text-in-card">
                            <p>
                                Полиморфизм - переопределение методов базового класса в классе наследнике. 
                                Добавим в базовый класс метод info(), который печатает сводную информацию по 
                                объекту класса Figure и переопределим этот 
                                метод в классе Rectangle, где добавим дополнительные данные и вывод.
                                <pre class="code">class Figure:<br>    def __init__(self, color):<br>        self.color = color<br><br>    def get_color(self):<br>        return self.color<br><br>    def info(self):<br>        print("Figure")<br>        print("Color: " + self.color)<br><br>class Rectangle(Figure):<br>    def __init__(self, color, width=100, height=100):<br>        super().__init__(color)<br>        self.width = width<br>        self.height = height<br><br>    def square(self):<br>        return self.width * self.height<br><br>    def info(self):<br>        print("Rectangle")<br>        print("Color: " + self.color)<br>        print("Width: " + str(self.width))<br>        print("Height: " + str(self.height))<br>        print("Square: " + str(self.square()))<br><br>fig1 = Figure("green")<br>print(fig1.info())<br>rect1 = Rectangle("red", 24, 45)<br>print(rect1.info())</pre>
                            </p>
                        </div>
                    </div>
                    <h2>6. Модули:</h2>
                    <div class="card">
                        <div class="text-in-card">
                            <p>
                                Модулем в Python называется любой файл с программой.
                                Подключить модуль можно с помощью инструкции import. 
                                К примеру, подключим модуль os для получения текущей директории:
                                <br><span class="code">import os</span>
                                <br>Стоит отметить, что если указанный атрибут модуля не будет найден, 
                                возбудится исключение AttributeError. А если не удастся найти модуль для 
                                импортирования, то ImportError.
                            </p>
                            <p>
                                Если название модуля слишком длинное, или оно вам не нравится 
                                по каким-то другим причинам, то для него можно создать псевдоним, 
                                с помощью ключевого слова as.
                                <br><span class="code">import math as m</span>
                                <br>Теперь доступ ко всем атрибутам модуля math осуществляется только 
                                с помощью переменной m, а переменной math в этой программе уже не будет 
                                (если, конечно, вы после этого не напишете import math, тогда модуль 
                                будет доступен как под именем m, так и под именем math).
                            </p>
                            <p>
                                Подключить определенные атрибуты модуля можно с помощью инструкции from. 
                                Она имеет несколько форматов:
                                <pre class="code">from <Название модуля> import <Атрибут 1> [ as <Псевдоним 1> ], <br>    [<Атрибут 2> [ as <Псевдоним 2> ] ...]<br>from <Название модуля> import *</pre>
                            </p>
                            <p>
                                Первый формат позволяет подключить из модуля только указанные вами атрибуты. 
                                Для длинных имен также можно назначить псевдоним, указав его после ключевого слова as.
                                <br><span class="code">from math import e, ceil as c</span>
                                <br>Второй формат инструкции from позволяет 
                                подключить все (точнее, почти все) переменные из модуля.
                            </p>
                            <p>
                                Чтобы импортировать свой модуль, 
                                нужно указать название файла-модуля, который находится в той же папке.
                                Пути поиска модулей указаны в переменной sys.path.
                                В него включены текущая директория (то есть модуль можно оставить в папке с основной программой), 
                                а также директории, в которых установлен python. Кроме того, переменную sys.path можно изменять вручную, 
                                что позволяет положить модуль в любое удобное для вас место 
                                (главное, не забыть в главной программе модифицировать sys.path).
                            </p>
                        </div>
                    </div>
                    <h2>8. Файлы:</h2>
                    <div class="card">
                        <h3>8.1 Открытие, закрытие файла: <span class="code">open(), close()</span></h3>
                        <div class="text-in-card">
                            <p>
                                Перед тем как прочесть и записать что-либо в файл, его следует открыть. 
                                Чтобы открыть файл в Python используется встроенная функция 
                                <span class="code">open()</span>. При вызове, эта функция создает объект типа файл, 
                                с которым в дальнейшем можно работать.
                                <br>Синтаксис функции open() в Python.
                                <br><span class="code">my_file = open(имя_файла [, режим_доступа][, буферизация])</span>
                                <br>имя_файла: строка, содержащая имя файла с расширением. Например, "my_file.txt":
                                <ul>
                                    <li>
                                        имя_файла: строка, содержащая имя файла с расширением. Например, "my_file.txt".
                                    </li>
                                    <li>
                                        режим_доступа: строка, которой мы указываем для чего открывается файл: 
                                        для чтения, записи, добавления информации, и т.д. Например, "w". 
                                        По умолчанию файл открывается для чтения - "r".
                                    </li>
                                    <li>
                                        буферизация: Целое число. Если значение аргумента указано 
                                        0 - файл открывается без буферизации, 1 с построчной буферизацией, 
                                        больше одного процесс буферизации выполняется с указанным размером буфера. 
                                        Отрицательное число - разер буфера будет равен системному.
                                    </li>
                                </ul>
                            </p>
                            <p>
                                Список режимов доступа к файлу в Python:
                                <ul>
                                    <li>
                                        r - Открывает файл только для чтения. Указатель стоит в начале файла.
                                    </li>
                                    <li>
                                        rb - Открывает файл для чтения в двоичном формате. Указатель стоит в начале файла.
                                    </li>
                                    <li>
                                        r+ - Открывает файл для чтения и записи. Указатель стоит в начале файла.
                                    </li>
                                    <li>
                                        rb+ - Открывает файл для чтения и записи в двоичном формате. Указатель стоит в начале файла.
                                    </li>
                                    <li>
                                        w - Открывает файл только для записи. Указатель стоит в начале файла. 
                                        Создает файл с именем имя_файла, если такового не существует.
                                    </li>
                                    <li>
                                        wb - Открывает файл для записи в двоичном формате. Указатель стоит в начале файла. 
                                        Создает файл с именем имя_файла, если такового не существует.
                                    </li>
                                    <li>
                                        w+ - Открывает файл для чтения и записи. Указатель стоит в начале файла. 
                                        Создает файл с именем имя_файла, если такового не существует.
                                    </li>
                                    <li>
                                        wb+ - Открывает файл для чтения и записи в двоичном формате. 
                                        Указатель стоит в начале файла. Создает файл с именем имя_файла, 
                                        если такового не существует.
                                    </li>
                                    <li>
                                        a - Открывает файл для добавления информации в файл. 
                                        Указатель стоит в конце файла. Создает файл с именем имя_файла, если такового не существует.
                                    </li>
                                    <li>
                                        ab - Открывает файл для добавления в двоичном формате. 
                                        Указатель стоит в конце файла. Создает файл с именем имя_файла, 
                                        если такового не существует.
                                    </li>
                                    <li>
                                        a+ - Открывает файл для добавления и чтения. Указатель стоит в конце файла. 
                                        Создает файл с именем имя_файла, если такового не существует.
                                    </li>
                                    <li>
                                        ab+ - Открывает файл для добавления и чтения в двоичном формате. 
                                        Указатель стоит в конце файла. Создает файл с именем имя_файла, 
                                        если такового не существует.
                                    </li>
                                </ul>
                            </p>
                            <p>
                                <b>Атрибуты файлового объекта в Python.</b> 
                                Как только файл был открыт и у вас появился файловый объект, 
                                вы можете получить следующую информацию о нем:
                                <ul>
                                    <li>
                                        file.closed - Возвращает True если файл был закрыт.
                                    </li>
                                    <li>
                                        file.mode - Возвращает режим доступа, с которым был открыт файл.
                                    </li>
                                    <li>
                                        file.name - Возвращает имя файла.
                                    </li>
                                    <li>
                                        file.softspace - Возвращает False если при выводе содержимого файла 
                                        следует отдельно добавлять пробел.
                                    </li>
                                </ul>
                            </p>
                            <p>
                                Метод файлового объекта close() автоматически закрывает файл, 
                                при этом теряется любая несохраненная информация. 
                                Работать с файлом (читать, записывать) после этого нельзя.
                                Python автоматически закрывает файл если файловый объект к которому он привязан 
                                присваивается другому файлу. Однако, хорошей практикой будет 
                                вручную закрывать файл командой close().
                                <br>Пример:
                                <pre class="code">my_file = open("some.txt")<br>print("Имя файла: ", my_file.name)<br>print("Файл закрыт: ", my_file.closed)<br>my_file.close()<br>print("А теперь закрыт: ", my_file.closed)</pre>
                            </p>
                        </div>
                        <h3>8.2 Чтение и запись файлов: <span class="code">write(), read()</span></h3>
                        <div class="text-in-card">
                            <p>
                                Метод write() записывает любую строку в открытый файл. 
                                Важно помнить, что строки в Python могут содержать двоичные данные, 
                                а не только текст.
                                Метод write() не добавляет символ переноса строки ('\n') в конец файла.
                                <br>Пример:
                                <pre class="code"> my_file = open("some.txt", "w")<br>my_file.write("Мне нравится Python!\nЭто классный язык!")<br>my_file.close()</pre>
                            </p>
                            <p>
                                Метод read() читает строку из открытого файла 
                                <span class="code">my_file.read([count])</span>.
                                <br>Необязательный параметр count - это количество байт, которые следует 
                                прочитать из открытого файла. Этот метод читает информацию с начала файла и, 
                                если параметр count не указан, до конца файла.
                                <br>Например:
                                <pre class="code">my_file = open("some.txt")<br>my_string = my_file.read()<br>print("Было прочитано:")<br>print(my_string)<br>my_file.close()</pre>
                            </p>
                            <p>
                                После того как вы вызвали метод read() на файловом объекте, 
                                если вы повторно вызовете read(), то увидите лишь пустую строку. 
                                Это происходит потому, что после первого прочтения указатель находится в конце файла. 
                                Для того чтобы узнать позицию указателя можно использовать метод tell().
                                <pre class="code">my_file = open("some.txt")<br>my_file.read(10)<br>print ("Я на позиции:", my_file.tell())<br>my_file.close()</pre>
                            </p>
                            <p>
                                Чтобы перейти на нужную нам позицию, следует использовать другой метод - seek().
                                <br><span class="code">my_file.seek(0)</span>
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </body>
</html>